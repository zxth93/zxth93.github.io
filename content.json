{"meta":{"title":"Hexo","subtitle":"","description":"","author":"zxth93","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-05-03T13:06:12.269Z","updated":"2022-05-03T13:06:12.270Z","comments":true,"path":"2022/05/03/hello-world/","link":"","permalink":"http://example.com/2022/05/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"LeetCode-backtrack类总结","slug":"LeetCode-backtrack类总结","date":"2018-03-30T13:02:21.000Z","updated":"2022-05-03T13:07:06.240Z","comments":true,"path":"2018/03/30/LeetCode-backtrack类总结/","link":"","permalink":"http://example.com/2018/03/30/LeetCode-backtrack%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的backtracking类算法的总结，包含了各题的solution和常用解法。 相关源码：code 回溯法直观的理解：受限的分治算法 78. SubsetsDescription: Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] solution： 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); vector&lt;int&gt; tmp; backtrack(res, tmp, nums, 0); return res; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;nums, int start)&#123; res.push_back(temp); for(int i=start;i&lt;nums.size();i++)&#123; temp.push_back(nums[i]); backtrack(res, temp,nums,i+1); temp.pop_back(); &#125; &#125;&#125;; 90. Subsets IIDescription: Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is: 12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] solution: 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); vector&lt;int&gt; tmp; subsets(res,tmp, nums, 0); return res; &#125; void subsets(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;nums, int start)&#123; res.push_back(temp); for(int i=start;i&lt;nums.size();i++)&#123; if(i&gt;start &amp;&amp; nums[i]==nums[i-1]) continue; temp.push_back(nums[i]); subsets(res,temp,nums,i+1); temp.pop_back(); &#125; &#125;&#125;; 46. PermutationsDescription: Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] solution: 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; backtrack(res, tmp, nums); return res; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; temp, vector&lt;int&gt; &amp;nums)&#123; if(temp.size()==nums.size()) res.push_back(temp); else&#123; for(int i=0; i&lt;nums.size();i++)&#123; if(contain(temp, nums[i])) continue; temp.push_back(nums[i]); backtrack(res,temp,nums); temp.pop_back(); &#125; &#125; &#125; bool contain(vector&lt;int&gt; &amp;nums, int target)&#123; for(int i=0; i&lt;nums.size();i++)&#123; if(nums[i]==target) return true; &#125; return false; &#125;&#125;; 47. Permutations IIDescription: Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] solution: 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;int&gt; tmp; vector&lt;bool&gt; used(nums.size(), false); vector&lt;vector&lt;int&gt;&gt; res; backtrack(res, tmp, nums, used); return res; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; used)&#123; if(temp.size()==nums.size()) res.push_back(temp); else&#123; for(int i=0; i&lt;nums.size();i++)&#123; if(used[i]|| i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1]) continue; used[i]=true; temp.push_back(nums[i]); backtrack(res,temp,nums, used); used[i]=false; temp.pop_back(); &#125; &#125; &#125;&#125;; 39. Combination SumDescription: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 12345[ [7], [2, 2, 3]] solution: 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(),candidates.end()); vector&lt;int&gt; tmp; backtrack(res, tmp, candidates,target, 0); return res; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;candidates, int remain, int start)&#123; if(remain&lt;0) return; else if(remain==0) res.push_back(temp); else&#123; for(int i=start; i&lt;candidates.size(); i++)&#123; temp.push_back(candidates[i]); backtrack(res, temp, candidates, remain-candidates[i], i); temp.pop_back(); &#125; &#125; &#125;&#125;; 40. Combination Sum IIDescription: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] solution: 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(),candidates.end()); vector&lt;int&gt; tmp; backtrack(res, tmp, candidates, target, 0); return res; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; nums, int remain, int start)&#123; if(remain&lt;0) return; else if(remain==0) res.push_back(temp); else&#123; for(int i=start; i&lt;nums.size(); i++)&#123; if(i&gt;start &amp;&amp; nums[i]==nums[i-1]) continue; temp.push_back(nums[i]); backtrack(res, temp, nums, remain-nums[i], i+1); temp.pop_back(); &#125; &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"LeetCode-dp类总结","slug":"LeetCode-dp类总结","date":"2017-12-29T06:34:07.000Z","updated":"2022-05-03T13:07:25.297Z","comments":true,"path":"2017/12/29/LeetCode-dp类总结/","link":"","permalink":"http://example.com/2017/12/29/LeetCode-dp%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的dp类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 198. House RobberDescription: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 解题思路：此题是动态规划中的经典问题，此题有个限制相邻两个房间不能同时被盗，那么最优子结构就是cur=max(pre+nums[i], cur)，代码如下： 123456789101112int rob(vector&lt;int&gt; &amp;nums)&#123; int n=nums.size(); int pre=cur=0; for(int i=0; i&lt;n; i++) &#123; int temp = max(pre+nums[i], cur); pre = cur; cur = temp; &#125; return cur;&#125; 740. Delete and EarnDescription: Given an array nums of integers, you can perform operations on the array. In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1. You start with 0 points. Return the maximum number of points you can earn by applying such operations. Example 1: 123456Input: nums = [3, 4, 2]Output: 6Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.Then, delete 2 to earn 2 points. 6 total points are earned. Example 2: 1234567Input: nums = [2, 2, 3, 3, 3, 4]Output: 9Explanation: Delete 3 to earn 3 points, deleting both 2&#x27;s and the 4.Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.9 total points are earned. Note: The length of nums is at most 20000. Each element nums[i] is an integer in the range [1, 10000]. 解题思路：此题本质上是house robber问题，参考上题，代码如下： 123456789101112131415class Solution &#123;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; hash(10001,0); for(int n :nums) hash[n]+=n; int pre=0, cur=0; for(int i=0; i&lt;10001; i++)&#123; int temp=cur; cur=max(pre+hash[i],cur); pre=temp; &#125; return cur; &#125;&#125;; 64. Minimum Path SumDescription:Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: 1234[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum. 解题思路：在矩阵上求解从左上角到右下角最短路径，最优子结构关注当前元素的上方元素和左方元素，代码如下： 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; state(m,vector&lt;int&gt;(n, grid[0][0])); for(int i=1; i&lt;m; i++) state[i][0] = state[i-1][0]+grid[i][0]; for(int j=1; j&lt;n; j++) state[0][j] = state[0][j-1]+grid[0][j]; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; state[i][j] = min(state[i-1][j], state[i][j-1]) + grid[i][j]; &#125; &#125; return state[m-1][n-1]; &#125;&#125;; 712. Minimum ASCII Delete Sum for Two StringsDescription: Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: 123456Input: s1 = &quot;sea&quot;, s2 = &quot;eat&quot;Output: 231Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this. Example 2: 1234567Input: s1 = &quot;delete&quot;, s2 = &quot;leet&quot;Output: 403Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,adds 100[d]+101[e]+101[e] to the sum. Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403.If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher. Note: 0 &lt; s1.length, s2.length &lt;= 1000. All elements of each string will have an ASCII value in [97, 122]. 解题思路：本题算是dp中一类经典题“字符串匹配”，利用矩阵解题，代码如下： 1234567891011121314151617class Solution &#123;public: int minimumDeleteSum(string s1, string s2) &#123; int m=s1.size(), n=s2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int j=1; j&lt;=n; j++) dp[0][j]=dp[0][j-1]+s2[j-1]; for(int i=1; i&lt;=m; i++)&#123; dp[i][0] = dp[i-1][0]+s1[i-1]; for(int j=1; j&lt;=n; j++)&#123; if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]); &#125; &#125; return dp[m][n]; &#125;&#125;; 647. Palindromic SubstringsDescription: Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: 1234Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: 1234Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. Note: The input string length won’t exceed 1000. 代码如下： 1234567891011class Solution &#123;public: int countSubstrings(string s) &#123; int res = 0, n = s.length(); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; i-j &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j] == s[i+j]; j++)res++; for(int j = 0; i-1-j &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-1-j] == s[i+j]; j++)res++; &#125; return res; &#125;&#125;; 467. Unique Substrings in Wraparound StringDescription: Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”. Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s. Note: p consists of only lowercase English letters and the size of p might be over 10000. Example 1: 12345Input: &quot;a&quot;Output: 1Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string \u0010s. Example 2: 1234Input: &quot;cac&quot;Output: 2Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s. Example 3: 123Input: &quot;zab&quot;Output: 6Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s. 代码如下： 1234567891011121314151617181920class Solution &#123;public: int findSubstringInWraproundString(string p) &#123; vector&lt;int&gt; count(26); int maxLenCur=0; for(int i=0; i&lt;p.size(); i++)&#123; if(i&gt;0 &amp;&amp; (p[i]-p[i-1]==1 || p[i-1]-p[i]==25))&#123; maxLenCur++; &#125;else&#123; maxLenCur=1; &#125; int index=p[i]-&#x27;a&#x27;; count[index]=max(count[index],maxLenCur); &#125; int sum=0; for(int n : count) sum+=n; return sum; &#125;&#125;; 95. Unique Binary Search Trees IIDescription: Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example,Given n = 3, your program should return all 5 unique BST’s shown below. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 代码如下： 12345678910111213141516171819202122232425class Solution&#123;public: vector&lt;TreeNode*&gt; generateTrees(int n)&#123; if(n==0) return vector&lt;TreeNode*&gt; &#123;NULL&#125;; return generator(1, n); &#125; vector&lt;TreeNode*&gt; generator(int start, int end)&#123; if(start&gt;end) return vector&lt;TreeNode*&gt; &#123;NULL&#125;; vector&lt;TreeNode*&gt; res; for(int i=start; i&lt;=end; i++)&#123; vector&lt;TreeNode*&gt; l = generator(start, i-1); vector&lt;TreeNOde*&gt; r = generator(i+1, end); for(int j=0; j&lt;l.size();j++)&#123; for(int k=0; k&lt;r.size();k++)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = l[j]; root-&gt;right = r[k]; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125; 96. Unique Binary Search TreesDescription: Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 代码如下： 12345678910111213class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; res(n+1); res[0]=res[1]=1; for(int i=2; i&lt;=n; i++)&#123; for(int j=1; j&lt;=i; j++)&#123; res[i]+=res[j-1]*res[i-j]; &#125; &#125; return res[n]; &#125;&#125;; 120. TriangleDescription: Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 1234567[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 代码如下： 12345678910111213class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); vector&lt;int&gt; minArr(triangle.back()); for(int layer=n-2; layer&gt;=0; layer--)&#123; for(int i=0; i&lt;=layer;i++)&#123; minArr[i]=min(minArr[i],minArr[i+1]) + triangle[layer][i]; &#125; &#125; return minArr[0]; &#125;&#125;; 650. 2 Keys KeyboardDescription: Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n ‘A’. Example 1: 12345678Input: 3Output: 3Explanation:Intitally, we have one character &#x27;A&#x27;.In step 1, we use Copy All operation.In step 2, we use Paste operation to get &#x27;AA&#x27;.In step 3, we use Paste operation to get &#x27;AAA&#x27;. Note: The n will be in the range [1, 1000]. 代码如下： 123456789class Solution &#123;public: int minSteps(int n) &#123; if(n==1) return 0; for(int i=2; i&lt;n; i++) if(n%i==0) return i+minSteps(n/i); return n; &#125;&#125;; 474. Ones and ZerosDescription: In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note: The given numbers of 0s and 1s will both not exceed 100 The size of given string array won’t exceed 600. Example 1: 12345Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” Example 2: 1234Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1Output: 2Explanation: You could form &quot;10&quot;, but then you&#x27;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;. 解题思路：此题明显是一道dp题，本题适合二维矩阵，代码如下： 1234567891011121314151617181920class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(m+1, vector&lt;int&gt;(n+1, 0)); for(auto &amp;s : strs)&#123; int cZeros=0, cOnes=0; for(auto c : s)&#123; if(c==&#x27;0&#x27;) cZeros++; else if(c==&#x27;1&#x27;) cOnes++; &#125; for(int i=m; i&gt;=cZeros; i--)&#123; for(int j=n; j&gt;=cOnes; j--)&#123; res[i][j]=max(res[i][j], res[i-cZeros][j-cOnes]+1); &#125; &#125; &#125; return res[m][n]; &#125;&#125;; 486. Predict the WinnerDescription: Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. Example 1: 1234567Input: [1, 5, 2]Output: FalseExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False. Example 2: 12345Input: [1, 5, 233, 7]Output: TrueExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win. Note: 1 &lt;= length of the array &lt;= 20. Any scores in the given array are non-negative integers and will not exceed 10,000,000. If the scores of both players are equal, then player 1 is still the winner. 代码如下： 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); for(int i=0; i&lt;n; i++) dp[i][i]=nums[i]; for(int len=1; len&lt;n; len++)&#123; for(int i=0; i&lt;n-len;i++)&#123; int j = i+len; dp[i][j]=max(nums[i]-dp[i+1][j], nums[j]-dp[i][j-1]); &#125; &#125; return dp[0][n-1]&gt;=0; &#125; bool PredictTheWinner2(vector&lt;int&gt;&amp; nums) &#123; //if(nums==NULL) return true; int n = nums.size(); if((n&amp;1)==0) return true; vector&lt;int&gt; dp(n); for(int i=n-1; i&gt;=0; i--)&#123; for(int j=i; j&lt;n;j++)&#123; if(i==j) dp[i]=nums[i]; else dp[j]=max(nums[i]-dp[j],nums[j]-dp[j-1]); &#125; &#125; return dp[n-1]&gt;=0; &#125;&#125;; 416. Partition Equal Subset SumDescription: Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: 123456Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: 12345Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 解题思路：本质是dp题，只是套了一层，代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int sum = 0; for(int num : nums) sum+=num; if((sum&amp;1)==1) return false; sum /= 2; vector&lt;vector&lt;bool&gt;&gt; dp(n+1, vector&lt;bool&gt;(sum+1, false)); dp[0][0]=true; for(int i=1; i&lt;n+1; i++) dp[i][0]=true; for(int j=1; j&lt;sum+1; j++) dp[0][j]=false; for(int i=1; i&lt;n+1; i++)&#123; for(int j=1; j&lt;sum+1; j++)&#123; dp[i][j]=dp[i-1][j]; if(j&gt;=nums[i-1]) dp[i][j]=dp[i][j] || dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[n][sum]; &#125; bool canPartition2(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int sum = 0; for(int num : nums) sum+=num; if((sum&amp;1)==1) return false; sum /= 2; vector&lt;bool&gt; dp(sum+1, false); dp[0]=true; for(int num : nums)&#123; for(int i=sum; i&gt;=num; i--)&#123; dp[i]=dp[i]||dp[i-num]; &#125; &#125; return dp[sum]; &#125;&#125;; 494. Target SumDescription: You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 123456789101112Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 代码如下：此题套了上一题的dp，代码如下： 12345678910111213141516class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int sum=0; for(int num : nums) sum+=num; return sum&lt;S||(S+sum)%2&gt;0?0:subsetSum(nums, (S+sum)&gt;&gt;1); &#125; int subsetSum(vector&lt;int&gt; &amp;nums, int target)&#123; vector&lt;int&gt; dp(target+1, 0); dp[0]=1; for(int num : nums)&#123; for(int i=target; i&gt;=num; i--) dp[i]+=dp[i-num]; &#125; return dp[target]; &#125;&#125;; 139. Word BreakDescription: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. For example, givens = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;]. Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 解题思路：一般我都需要把子字符串都枚举出来，自然而然会想到dp，代码如下： 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if(wordDict.size()==0) return false; unordered_set&lt;string&gt; dict; for(string str : wordDict) dict.insert(str); vector&lt;bool&gt; dp(s.size()+1, false); dp[0]=true; for(int i=1; i&lt;=s.size(); i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j,i-j); if(dict.find(word)!=dict.end())&#123; dp[i]=true; break; &#125; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; 714. Best Time to Buy and Sell Stock with Transaction TreeDescription: Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 12345Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 代码如下： 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; long t_ik0=0, t_ik1=INT_MIN; for(int price : prices)&#123; long t_ik0_old = t_ik0; t_ik0 = max(t_ik0, t_ik1+price-fee); t_ik1 = max(t_ik1, t_ik0_old-price); &#125; return t_ik0; &#125;&#125;; 152. Maximum Product SubarrayDescription: Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 代码如下： 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return nums[0]; int pMax=0, nMax=0, m=0; for(int i=0; i&lt;n; i++)&#123; if(nums[i]&lt;0) swap(pMax, nMax); pMax=max(pMax*nums[i], nums[i]); nMax=min(nMax*nums[i], nums[i]); if(pMax&gt;m) m = pMax; &#125; return m; &#125;&#125;; 516. Longest Palindromic SubsequenceDescription: Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example 1:Input: 12&quot;bbbab&quot; Output: 124 One possible longest palindromic subsequence is “bbbb”. Example 2:Input: 12&quot;cbbd&quot; Output: 122 One possible longest palindromic subsequence is “bb”. 解题思路：字符串=&gt;网格，代码如下： 12345678910111213141516class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int len = s.length(); if(len==0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len,0)); for(int i=len-1; i&gt;=0; i--)&#123; dp[i][i]=1; for(int j=i+1; j&lt;len; j++)&#123; if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2; else dp[i][j]=max(dp[i+1][j],dp[i][j-1]); &#125; &#125; return dp[0][len-1]; &#125;&#125;; 221. Maximal SquareDescription: Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example, given the following matrix: 123451 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. Credits:Special thanks to @Freezen for adding this problem and creating all test cases. 代码如下： 123456789101112131415161718192021222324252627class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if(!m) return 0; int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0)); int maxsize=0; for(int i=0; i&lt;m; i++) &#123; dp[i][0]=matrix[i][0]-&#x27;0&#x27;; maxsize=max(maxsize,dp[i][0]); &#125; for(int j=0; j&lt;n; j++) &#123; dp[0][j]=matrix[0][j]-&#x27;0&#x27;; maxsize=max(maxsize,dp[0][j]); &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1;j&lt;n;j++)&#123; if(matrix[i][j]==&#x27;1&#x27;)&#123; dp[i][j]=min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]))+1; maxsize=max(maxsize,dp[i][j]); &#125; &#125; &#125; return maxsize*maxsize; &#125;&#125;; 63. Unique Paths IIDescription: Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. 123456[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m=obstacleGrid.size(), n=obstacleGrid[0].size(); if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0)); dp[0][0]=1; for(int i=1; i&lt;m; i++)&#123; if(obstacleGrid[i][0]==1||dp[i-1][0]==0) dp[i][0]=0; else dp[i][0]=1; &#125; for(int j=1; j&lt;n; j++)&#123; if(obstacleGrid[0][j]==1||dp[0][j-1]==0) dp[0][j]=0; else dp[0][j]=1; &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(obstacleGrid[i][j]==1) dp[i][j]=0; else dp[i][j]=dp[i][j-1]+dp[i-1][j]; &#125; &#125; return dp[m-1][n-1]; &#125; int uniquePathsWithObstacles2(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m=obstacleGrid.size(), n=obstacleGrid[0].size(); if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) return 0; vector&lt;int&gt; dp(n,0); dp[0]=1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(obstacleGrid[i][j]==1) dp[j]=0; else if(j&gt;0) dp[j]+=dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 264. Ugly Number IIDescription: Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. 经典题，代码如下： 12345678910111213141516class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n&lt;=0) return 0; int t2=0, t3=0, t5=0; vector&lt;int&gt; dp(n); dp[0]=1; for(int i=1; i&lt;n; i++)&#123; dp[i]=min(dp[t2]*2, min(dp[t3]*3, dp[t5]*5)); if(dp[t2]*2==dp[i]) t2++; if(dp[t3]*3==dp[i]) t3++; if(dp[t5]*5==dp[i]) t5++; &#125; return dp[n-1]; &#125;&#125;; 115. Distinct SubsequencesDescription: Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not). Example 1: 1234567891011121314Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ Example 2: 1234567891011121314151617Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.(The caret symbol ^ means the chosen letters)babgbag^^ ^babgbag^^ ^babgbag^ ^^babgbag ^ ^^babgbag ^^^ 代码如下： 12345678910111213141516class Solution &#123;public: int numDistinct(string s, string t) &#123; int m=t.length(); int n=s.length(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1)); for(int i=0; i&lt;=n; i++) dp[0][i]=1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(t[i]==s[j]) dp[i+1][j+1]=dp[i][j]+dp[i+1][j]; else dp[i+1][j+1]=dp[i+1][j]; &#125; &#125; return dp[m][n]; &#125;&#125;; 140. Word Break IIDescription: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 123456789Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] Example 2: 1234567891011Input:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3: 12345Input:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output:[] 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict; unordered_map&lt;int, vector&lt;string&gt;&gt; memo; vector&lt;string&gt; output; for(auto word : wordDict) &#123; dict.insert(word); &#125; wordBreakRecur(s, 0, dict, memo); for(auto str : memo[0]) output.push_back(str); return output; &#125; void wordBreakRecur(string&amp; s, int pos, unordered_set&lt;string&gt;&amp; dict, unordered_map&lt;int, vector&lt;string&gt;&gt;&amp; memo) &#123; string word = &quot;&quot;; int offset = 0; while(pos+offset &lt; s.size()) &#123; word += s[pos+offset]; if(dict.find(word) != dict.end()) &#123; if(pos+offset+1 == s.size()) memo[pos].push_back(word); else &#123; if(memo.find(pos+offset+1) == memo.end()) wordBreakRecur(s, pos+offset+1, dict, memo); for(auto str : memo[pos+offset+1]) &#123; memo[pos].push_back(word + &quot; &quot; + str); &#125; &#125; &#125; offset++; &#125; &#125; &#125;; 174. Dungeon GameDescription: The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3 -5 -10 1 10 30 -5 (P) Note: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 代码如下： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int m = dungeon.size(); int n = dungeon[0].size(); vector&lt;vector&lt;int&gt;&gt; hp(m+1, vector&lt;int&gt;(n+1, INT_MAX)); hp[m][n-1]=1; hp[m-1][n]=1; for(int i=m-1;i&gt;=0; i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; int need = min(hp[i+1][j],hp[i][j+1])-dungeon[i][j]; hp[i][j]=need&lt;=0?1:need; &#125; &#125; return hp[0][0]; &#125;&#125;; 188. Best Time to Buy and Sell Stock IVDescription: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: 1234Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: 1234Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 解题思路,代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k &gt;= prices.size()&gt;&gt;1)&#123; int t_ik0=0, t_ik1=INT_MIN; for(int price : prices)&#123; int t_ik0_old=t_ik0; t_ik0=max(t_ik0,t_ik1+price); t_ik1=max(t_ik1,t_ik0_old-price); &#125; return t_ik0; &#125; vector&lt;int&gt; t_ik0(k+1,0); vector&lt;int&gt; t_ik1(k+1,INT_MIN); for(int price: prices)&#123; for(int j=k;j&gt;0;j--)&#123; t_ik0[j]=max(t_ik0[j],t_ik1[j]+price); t_ik1[j]=max(t_ik1[j],t_ik0[j-1]-price); &#125; &#125; return t_ik0[k]; &#125;&#125;; 279. Perfect SquaresDescription: Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: 123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: 123Input: n = 13Output: 2Explanation: 13 = 4 + 9. 代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int numSquares(int n) &#123; if(n&lt;=0) return 0; vector&lt;int&gt; dp(n+1, INT_MAX); dp[0]=0; for(int i=1; i&lt;n+1; i++)&#123; for(int j=1; j*j&lt;=i; j++)&#123; dp[i]=min(dp[i], dp[i-j*j]+1); &#125; &#125; return dp[n]; &#125; &#125;; 32. Longest Valid ParenthesesDescription: Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example 1: 1234Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int longestValidParentheses(string s) &#123; int len = s.length(), res = 0; stack&lt;int&gt; st; for(int i=0; i&lt;len; i++)&#123; if(s[i]==&#x27;(&#x27;) st.push(i); else&#123; if(!st.empty() &amp;&amp; s[st.top()]==&#x27;(&#x27;) st.pop(); else st.push(i); &#125; &#125; if(st.empty()) return len; int a=len, b=0; while(!st.empty())&#123; b=st.top(); st.pop(); res = max(res, a-b-1); a=b; &#125; res = max(res,a); return res; &#125; int longestValidParentheses2(string s) &#123; int len = s.length(), res=0; vector&lt;int&gt; dp(len, 0); for(int i=1;i&lt;len;i++)&#123; if(s[i]==&#x27;)&#x27; &amp;&amp; i-dp[i-1]-1&gt;=0 &amp;&amp; s[i-dp[i-1]-1]==&#x27;(&#x27;)&#123; dp[i]=dp[i-1] + 2 + ((i-dp[i-1]-2&gt;=0)?dp[i-dp[i-1]-2]:0); res = max(dp[i],res); &#125; &#125; return res; &#125;&#125;; 62. Unique PathsDescription: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 12345678Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n, 0)); dp[0][0]=1; for(int i=1; i&lt;m; i++) dp[i][0]=1; for(int j=1; j&lt;n; j++) dp[0][j]=1; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[i][j]=dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; int uniquePaths2(int m, int n) &#123; vector&lt;int&gt; dp(n,0); dp[0]=1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; dp[j]+=dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 72. Edit DistanceDescription: Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 1234567Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#x27;h&#x27; with &#x27;r&#x27;)rorse -&gt; rose (remove &#x27;r&#x27;)rose -&gt; ros (remove &#x27;e&#x27;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#x27;t&#x27;)inention -&gt; enention (replace &#x27;i&#x27; with &#x27;e&#x27;)enention -&gt; exention (replace &#x27;n&#x27; with &#x27;x&#x27;)exention -&gt; exection (replace &#x27;n&#x27; with &#x27;c&#x27;)exection -&gt; execution (insert &#x27;u&#x27;) 代码如下： 12345678910111213141516171819class Solution &#123; public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); for (int i = 1; i &lt;= m; i++) dp[i][0] = i; for (int j = 1; j &lt;= n; j++) dp[0][j] = j; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)); &#125; &#125; return dp[m][n]; &#125;&#125;; 97. Interleaving StringDescription: Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: 123Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true Example 2: 12Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false 代码如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.length(); int n = s2.length(); if(m+n!=s3.length()) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1)); for(int i=0; i&lt;m+1; i++)&#123; for(int j=0;j&lt;n+1;j++)&#123; if(i==0&amp;&amp;j==0) dp[i][j]=true; else if(i==0) dp[i][j]=dp[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]; else if(j==0) dp[i][j]=dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]; else dp[i][j]=(dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]); &#125; &#125; return dp[m][n]; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"LeetCode-binary search类总结(会持续更新的...)","slug":"LeetCode-binary-search类总结","date":"2017-11-20T10:07:47.000Z","updated":"2022-05-03T13:07:13.522Z","comments":true,"path":"2017/11/20/LeetCode-binary-search类总结/","link":"","permalink":"http://example.com/2017/11/20/LeetCode-binary-search%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的binary search类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 123关于二分查找的一些trick：1. mid=lo+(hi-lo)/2,防止大数溢出；2. 注意区分两种搜索空间：index search | range search; 278. First Bad VersionDescription: You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. 解题思路：本题数组为有序 ，并且题目要求查找 ，自然而然会想到二分查找，代码如下： 123456789101112131415161718bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int front = 1; int tail = n; while(true)&#123; int mid = (tail-front)/2 + front; bool res = isBadVersion(mid); if(res)&#123; if(!isBadVersion(mid-1)) return mid; tail = mid-1; &#125;else&#123; front = mid+1; &#125; &#125; &#125;&#125;; 222. Count Complete Tree NodesDescription: Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 解题思路：基本思路就是树的遍历，利用完全二叉树的性质优化程序，代码如下： 123456789101112class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int l=0, r=0; TreeNode *lp=root, *rp=root; while(lp)&#123;l++; lp=lp-&gt;left;&#125; while(rp)&#123;r++; rp=rp-&gt;right;&#125; if(l==r) return pow(2,l)-1; return countNodes(root-&gt;left)+countNodes(root-&gt;right)+1; &#125;&#125;; 29. Divide Two IntegersDescription: Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 解题思路：利用减法，加之移位 操作优化 ，代码如下： 12345678910111213141516171819202122class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || (dividend==INT_MIN &amp;&amp; divisor==-1))&#123; return INT_MAX; &#125; int res=0; int sign = (dividend&lt;0)^(divisor&lt;0)?-1:1; long long divid=labs(dividend); long long divis=labs(divisor); while(divid&gt;=divis)&#123; long long temp=divis, multi=1; while(divid&gt;=(temp&lt;&lt;1))&#123; multi&lt;&lt;=1; temp&lt;&lt;=1; &#125; divid-=temp; res +=multi; &#125; return sign==1?res:0-res; &#125;&#125;; 33. Search in Rotated Sorted ArrayDescription:Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 解题思路：经典题型 ，先找到最小值的位置，然后“平移”数组，代码如下： 1234567891011121314151617181920212223class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==0) return -1; int l=0; int r=nums.size()-1; while(l&lt;r)&#123; int mid=(r+l)/2; if(nums[mid]&gt;nums[r]) l=mid+1; else r=mid; &#125; int rot=l; l=0,r=nums.size()-1; while(l&lt;=r)&#123; int mid=(l+r)/2; int realmid=(mid+rot)%nums.size(); if(nums[realmid]==target) return realmid; if(nums[realmid]&lt;target) l=mid+1; else r=mid-1; &#125; return -1; &#125;&#125;; 436. Find Right IntervalDescription: Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note: You may assume the interval’s end point is always bigger than its start point. You may assume none of these intervals have the same start point. Example 1: 123456Input: [ [1,2] ]Output: [-1]Explanation: There is only one interval in the collection, so it outputs -1. Example 2: 12345678Input: [ [3,4], [2,3], [1,2] ]Output: [-1, 0, 1]Explanation: There is no satisfied &quot;right&quot; interval for [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point. Example 3: 123456Input: [ [1,4], [2,3], [3,4] ]Output: [-1, 2, -1]Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point. 解题思路：我们需要对区间排序，并且需要记录原有索引，所以使用map 数据结构；然后使用二分查找找到相应的区间，代码如下： 1234567891011121314151617181920212223struct Interval &#123; int start; int end; Interval() : start(0), end(0) &#123;&#125; Interval(int s, int e) : start(s), end(e) &#123;&#125; &#125;;class Solution &#123;public: vector&lt;int&gt; findRightInterval(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;int&gt; res; map&lt;int, int&gt; hash; for(int i=0;i&lt;intervals.size();i++)&#123; hash[intervals[i].start]=i; &#125; for(auto in : intervals)&#123; auto itr = hash.lower_bound(in.end); if(itr==hash.end()) res.push_back(-1); else res.push_back(itr-&gt;second); &#125; return res; &#125;&#125;; 34. Search for a RangeDescription: Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 解题思路：此题属于index search,数组中会出现多个相同的目标值，我们需要确定起始和终止的位置。这样的话，其实我们需要做两次BS，即从两个反方向进行，代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2,-1); if(nums.size()==0) return res; int l=0; int r=nums.size()-1; while(l&lt;r)&#123; int mid = (l+r)/2; if(nums[mid]&lt;target) l=mid+1; else r=mid; &#125; if(nums[l]!=target) return res; else res[0]=l; r=nums.size()-1; while(l&lt;r)&#123; int mid=(l+r)/2+1; if(nums[mid]&gt;target) r=mid-1; else l=mid; &#125; res[1]=r; return res; &#125;&#125;; 454. 4Sum IIDescription: Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l]is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. Example: 12345678910111213Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 代码如下： 12345678910111213141516171819class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int,int&gt; abHash; for(auto a : A)&#123; for(auto b : B)&#123; ++abHash[a+b]; &#125; &#125; int count=0; for(auto c : C)&#123; for(auto d : D)&#123; auto itr = abHash.find(0-c-d); if(itr!=abHash.end()) count+= itr-&gt;second; &#125; &#125; return count; &#125;&#125;; 74. Search a 2D MatrixDescription:Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 123456[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 解题思路：将二维数组按照一维数组进行处理，属于index search, 代码如下： 123456789101112131415class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size()==0||matrix[0].size()==0) return false; int row = matrix.size(); int col = matrix[0].size(); int l=0, r=row*col-1; while(l&lt;r)&#123; int mid=(l+r)/2; if(matrix[mid/col][mid%col]&lt;target) l=mid+1; else r=mid; &#125; return matrix[l/col][l%col]==target; &#125;&#125;; 81. Search in Rotated Sorted Array IIDescription: Follow up for “Search in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 解题思路：旋转数组问题关键是找到最小值位置，代码如下： 12345678910111213141516171819202122class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==0) return false; int lo =0, hi = nums.size()-1; int mid = 0; while(lo&lt;hi)&#123; mid=(lo+hi)/2; if(nums[mid]==target) return true; if(nums[mid]&gt;nums[hi])&#123; if(nums[mid]&gt;target &amp;&amp; nums[lo] &lt;= target) hi = mid; else lo = mid + 1; &#125;else if(nums[mid] &lt; nums[hi])&#123; if(nums[mid]&lt;target &amp;&amp; nums[hi] &gt;= target) lo = mid + 1; else hi = mid; &#125;else&#123; hi--; &#125; &#125; return nums[lo] == target ? true : false; &#125;&#125;; 300. Longest Increasing SubsequenceDescription:Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. 解题思路：动态规划，代码如下： 123456789101112131415161718class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len==0) return 0; vector&lt;int&gt; dp(len, 1); int res=1; for(int i=1; i&lt;len; i++)&#123; for(int j=0; j&lt;i; j++)&#123; if(nums[j]&lt;nums[i])&#123; dp[i]=max(dp[i],dp[j]+1); &#125; &#125; res=max(res, dp[i]); &#125; return res; &#125;&#125;; 718. Maximum Length of Repeated SubarrayDescription: Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: 1234567Input:A: [1,2,3,2,1]B: [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3, 2, 1]. Note: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 解题思路：动态规划，代码如下： 123456789101112131415class Solution &#123;public: int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int m=A.size(), n=B.size(); if(!m || !n) return 0; int res = 0; vector&lt;int&gt; dp(n+1); for(int i=m-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;n; j++)&#123; res = max(res, dp[j]=A[i]==B[j]?1+dp[j+1]:0); &#125; &#125; return res; &#125;&#125;; 153. Find Minimum in Rotated Sorted ArrayDescription: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 解题思路：旋转数组，代码如下： 12345678910111213class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int lo=0, hi=nums.size()-1; while(lo&lt;hi)&#123; int mid= (lo+hi)/2; if(nums[mid]&gt;nums[hi]) lo=mid+1; else hi=mid; &#125; return nums[lo]; &#125;&#125;; 230. Kth Smallest Element in a BSTDescription: Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. **Note: **You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Credits:Special thanks to @ts for adding this problem and creating all test cases. 解题思路：本质就是计数，代码如下： 123456789101112131415161718192021222324struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; int count = treeCount(root-&gt;left); if(k&lt;=count)&#123; return kthSmallest(root-&gt;left, k); &#125;else if(k&gt;count+1)&#123; return kthSmallest(root-&gt;right,k-1-count); &#125; return root-&gt;val; &#125; int treeCount(TreeNode* n)&#123; if(!n) return 0; return 1+treeCount(n-&gt;left)+treeCount(n-&gt;right); &#125;&#125;; 240. Search a 2D Matrix IIDescription: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. For example, Consider the following matrix: 12345678[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. 解题思路：经典题 ，代码如下： 123456789101112131415class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size()==0||matrix[0].size()==0) return false; int rows = matrix.size(); int cols = matrix[0].size()-1; int row = 0; while(cols&gt;=0 &amp;&amp; row &lt; rows)&#123; if(matrix[row][cols]==target) return true; else if(matrix[row][cols]&lt;target) row++; else cols--; &#125; return false; &#125;&#125;; 378. Kth Smallest Element in a Sorted MatrixDescription: Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 123456789matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. **Note: **You may assume k is always valid, 1 ≤ k ≤ n2. 解题思路：本题很经典，此题属于range search，代码如下： 12345678910111213141516171819class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int rows = matrix.size(); int cols = matrix[0].size(); int lo=matrix[0][0], hi=matrix[rows-1][cols-1]+1; while(lo&lt;hi)&#123; int mid=lo+(hi-lo)/2; int count=0, j=cols-1; for(int i=0; i&lt;rows; i++)&#123; while(j&gt;=0 &amp;&amp; matrix[i][j]&gt;mid) j--; count+=(j+1); &#125; if(count&lt;k) lo=mid+1; else hi=mid; &#125; return lo; &#125;&#125;; 658. Find K Closest ElementsDescription:Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1: 123Input: [1,2,3,4,5], k=4, x=3Output: [1,2,3,4] Example 2: 123Input: [1,2,3,4,5], k=4, x=-1Output: [1,2,3,4] Note: The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 104 Absolute value of elements in the array and x will not exceed 104 UPDATE (2017/9/19):The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes. 解题思路：先找到x（大于x的第一元素）在数组中的位置，然后在此位置周围找到k个元素，代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; int len=arr.size(); int index = low_bound(arr, len, x); int i=index-1, j=index; while(k--)&#123; i&lt;0||(j&lt;len &amp;&amp; abs(arr[i]-x)&gt;abs(arr[j]-x))?j++:i--; &#125; return vector&lt;int&gt;(arr.begin()+i+1,arr.begin()+j); &#125; int low_bound(vector&lt;int&gt; &amp;nums, int len, int target)&#123; if(!len) return 0; if(nums[0]&gt;=target) return 0; else if(nums[len-1]&lt;target) return len-1; int lo=0, hi=len-1; while(lo&lt;hi)&#123; int mid=lo+(hi-lo)/2; if(nums[mid]==target) return mid; if(nums[mid]&lt;target) lo=mid+1; else hi=mid; &#125; return lo; &#125;&#125;; 209. Minmum Size Subarray SumDescription: Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. click to show more practice. Credits:Special thanks to @Freezen for adding this problem and creating all test cases. 解题思路：双指针法，代码如下： 1234567891011121314151617class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len==0) return 0; int res=INT_MAX; int i=0,j=0,sum=0; while(j&lt;len)&#123; sum+=nums[j++]; while(sum&gt;=s)&#123; res = min(res,j-i); sum-=nums[i++]; &#125; &#125; return res==INT_MAX?0:res; &#125;&#125;; 287. Find the Duplicate NumberDescription: Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. 解题思路：代码如下： 1234567891011121314151617class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int slow = nums[0]; int fast = nums[nums[0]]; while(slow!=fast)&#123; slow=nums[slow]; fast=nums[nums[fast]]; &#125; fast=0; while(slow!=fast)&#123; slow=nums[slow]; fast=nums[fast]; &#125; return slow; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"DenseNet论文总结","slug":"DenseNet论文总结","date":"2017-11-17T03:32:19.000Z","updated":"2022-05-03T13:06:26.982Z","comments":true,"path":"2017/11/17/DenseNet论文总结/","link":"","permalink":"http://example.com/2017/11/17/DenseNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"本篇文章是CVPR2017的oral ，提出了DenseNet(Dense Convolutional Network)。此网络结构借鉴了Inception和ResNet的思想，效果非常好。最近几年网络结构一般沿着两个方向发展：要么更深（ResNet解决了网络更深梯度消失的问题）；要么更宽（GoogleNet的Inception）。本文则是从feature入手，将feature的极致利用达到更好的效果和更少的参数 。 DenseNet有以下优点： 1. 减轻梯度消失 2. 加强feature传递 3. 更有效地利用feature 4. 减少了参数 在深度学习网络中，随着网络深度的增加，梯度消失的问题愈发明显。针对此问题，目前提出了很多解决方案，比如：Highway Networks、ResNet、stochastic depth等。这些方法都有一个明显的特征：create short paths from early layers to later layers 。作者也是借鉴了这个思路，在保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层两两相连 。如下图所示： 在传统卷积神经网络中，假设有L层，那么就会有L个连接。而在DensNet中，则会有L(L+1)/2个连接。DenseNet的一个优点是网络更窄，参数更少，很大一部分原因得益于这种dense block的设计，后面有提到在dense block中每个卷积层的输出feature map的数量都很小（小于100），而不是像其他网络一样动不动就几百上千的宽度。同时这种连接方式使得特征和梯度的传递更加有效，网络也就更加容易训练。原文的一句话：Each layer has direct access to the gradients from the loss function and the original input signal, leading to an implicit deep supervision.直接解释了为什么这个网络的效果会很好。前面提到过梯度消失问题在网络深度越深的时候越容易出现，原因就是输入信息和梯度信息在很多层之间传递导致的，而现在这种dense connection相当于每一层都直接连接input和loss，因此就可以减轻梯度消失现象，这样更深网络不是问题。 另外作者还观察到这种dense connection有正则化的效果 ，因此对于过拟合有一定的抑制作用。 Figure1给出了dense block的组成结构，下面给出DenseNet的整体结构，如下图所示： Table1给出DenseNet在ImageNet上的详细设计，如下图所示： 这个表中的k=32，k=48中的k是growth rate，表示每个dense block中每层输出的feature map个数。为了避免网络变得很宽，作者都是采用较小的k，比如32这样，作者的实验也表明小的k可以有更好的效果。根据dense block的设计，后面几层可以得到前面所有层的输入，因此concat后的输入channel还是比较大的。另外这里每个dense block的3*3卷积前面都包含了一个1*1的卷积操作，就是所谓的bottleneck layer，目的是减少输入的feature map数量，既能降维减少计算量，又能融合各个通道的特征。 ResNet vs DenseNet这两个网络有本质的区别，从它们的公式就可以看出： 第一个公式是ResNet的。这里的l表示层，xl表示l层的输出，Hl表示一个非线性变换。所以对于ResNet而言，l层的输出是l-1层的输出加上对l-1层输出的非线性变换。 第二个公式是DenseNet的。[x0,x1,…,xl-1]表示将0到l-1层的输出feature map做concatenation。concatenation是做通道的合并，就像Inception那样。而前面ResNet是做值的相加，通道数是不变的。Hl包括BN，ReLU和3*3的卷积 。 参考: 论文：《densely connected convolutinal networks》","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DenseNet","slug":"DenseNet","permalink":"http://example.com/tags/DenseNet/"},{"name":"ResNet","slug":"ResNet","permalink":"http://example.com/tags/ResNet/"}]},{"title":"LSTM和GRU比较","slug":"LSTM和GRU比较","date":"2017-11-10T08:23:27.000Z","updated":"2022-05-03T13:07:35.323Z","comments":true,"path":"2017/11/10/LSTM和GRU比较/","link":"","permalink":"http://example.com/2017/11/10/LSTM%E5%92%8CGRU%E6%AF%94%E8%BE%83/","excerpt":"","text":"本文针对论文Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling 的总结，我会通过两个方面介绍论文：一是传统RNN和门控RNN区别与联系；二是两种门控RNN LSTM和GRU的区别与联系。 注： 本文不涉及RNN、LSTM和GRU基本概念介绍。若想了解，可以看我之前写的博客 。 1. 传统RNN vs 门控RNN 传统RNN的问题 ：长期依赖会造成梯度消失（多数情况下） 或梯度爆炸（少数情况下） 。 解决以上问题的方案： 以新的方法改善或者代替传统的SGD方法，如Bengio提出的clipped gradient; 设计更为精妙的activation function或recurrent unit，如LSTM和GRU。原因：LSTM和GRU都能通过各种Gate将重要特征保留，保证其在long-term 传播的时候也不会被丢失；还有一个作用就是有利于BP的时候不容易梯度消失。 传统RNN和门控RNN的不同点： 传统RNN会每一步都重写”记忆“，而门控RNN可以在某些步骤保持原有”记忆“； 门控RNN收敛速度更快，泛化能力更好。 2. LSTM vs GRU 相同点； 都属于”加模型“ 不同点： LSTM可控”记忆“的曝光度，而GRU完全暴露”记忆“，是不可控的； LSTM的新”记忆“是与forget gate独立的，而GRU的新”记忆“受update gate控制","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"LSTM","slug":"LSTM","permalink":"http://example.com/tags/LSTM/"},{"name":"GRU","slug":"GRU","permalink":"http://example.com/tags/GRU/"}]},{"title":"LeetCode-tree类总结（会持续更新...）","slug":"LeetCode-tree类总结","date":"2017-10-20T07:48:12.000Z","updated":"2022-05-03T13:07:33.746Z","comments":true,"path":"2017/10/20/LeetCode-tree类总结/","link":"","permalink":"http://example.com/2017/10/20/LeetCode-tree%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的tree类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 此类题的常用思路： 12345678910111213141. 树的遍历2. 递归3. 树的搜索4. 集合数据结构5. BST的中序遍历/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ 107. Binary Tree Level Order Traversal IIDescription: Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 123456 3 / \\9 20 / \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 解题思路：本题要求按层打印并且自底向上，故需要使用队列和栈 ，代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; stack&lt;vector&lt;int&gt;&gt; tower; if(root) q.push(root); while(!q.empty())&#123; vector&lt;int&gt; temp; size = q.size(); for(int i=0; i&lt;size; i++)&#123; TreeNode* node = q.front(); q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); temp.push_back(root-&gt;val); &#125; tower.push(temp); &#125; while(!tower.empty())&#123; res.push_back(tower.top()); tower.pop(); &#125; return res; &#125;&#125;; 404. Sum of Left LeavesDescription: Find the sum of all left leaves in a given binary tree. Example: 1234567 3 / \\ 9 20 / \\ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 解题思路：使用递归，代码如下： 12345678class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; if(root-&gt;left &amp;&amp; root-&gt;left-&gt;left==NULL &amp;&amp; root-&gt;left-&gt;right == NULL) return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right); return sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right); &#125;&#125;; 669. Trim a Binary Search TreeDescription: Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1: 12345678910111213Input: 1 / \\ 0 2 L = 1 R = 2Output: 1 \\ 2 Example 2: 123456789101112131415161718Input: 3 / \\ 0 4 \\ 2 / 1 L = 1 R = 3Output: 3 / 2 / 1 解题思路：本题是BST，所以要用好BST特性。本质上本题考察的是BST的遍历，代码如下： 123456789101112131415class Solution&#123;public: TreeNode* trimBST(TreeNode* root, int L, int R)&#123; if(!root) return NULL; if(root-&gt;val &lt; L)&#123; root = trimBST(root-&gt;right, L, R); &#125;else if(root-&gt;val &gt; R)&#123; root = trimBST(root-&gt;left, L, R); &#125;else&#123; root-&gt;left = trimBST(root-&gt;left, L, R); root-&gt;left = trimBST(root-&gt;right, L, R); &#125; return root; &#125;&#125;; 543. Diameter of Binary TreeDescription: Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longestpath between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 123456 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 解题思路：属于求树高的变体，思路是使用递归方式遍历，代码如下： 12345678910111213class Solution &#123;public: int diameterOfBinaryTree(TreeNode* root) &#123; if(!root) return 0; int res = depth(root-&gt;left) + depth(root-&gt;right); return max(res, max(diameterOfBinaryTree(root-&gt;left), diameterOfBinaryTree(root-&gt;right))); &#125; int depth(TreeNode* root)&#123; if(!root) return 0; return 1+max(depth(root-&gt;left), depth(root-&gt;right)); &#125;&#125;; 437. Path Sum IIIDescription: You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解题思路：本题属于“串行递归”：因为根节点、左子节点和右节点都有可能满足题意，所以对它们要同等对待。代码如下： 123456789101112class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if(!root) return 0; return pathSumFrom(root, sum) + pathSum(root-&gt;left,sum) + pathSum(root-&gt;right,sum); &#125; int pathSumFrom(TreeNode* root, int sum)&#123; if(!root) return 0; return (root-&gt;val==sum ? 1 : 0) + pathSumFrom(root-&gt;left, sum - root-&gt;val) + pathSumFrom(root-&gt;right,sum-root-&gt;val); &#125;&#125;; 110. Balance Binary TreeDescription: Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解题思路：使用搜索 的方式解决此题，代码如下： 1234567891011121314151617class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(!root) return true; return dfsHeight(root) != -1; &#125; int dfsHeight(TreeNode* root)&#123; if(!root) return 0; int l = dfsHeight(root-&gt;left); if(l==-1) return -1; int r = dfsHeight(root-&gt;right); if(r==-1) return -1; if(abs(l-r)&gt;1) return -1; return 1+max(dfsHeight(root-&gt;left), dfsHeight(root-&gt;right)); &#125;&#125;; 111. Minimum Depth of Binary TreeDescription: Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 解题思路：本题是求深度的变形，重点区分含有双子节点的父节点和含有单子节点的父节点，代码如下： 1234567class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; return root-&gt;left == NULL || root-&gt;right == NULL ? 1+max(minDepth(root-&gt;left), minDepth(root-&gt;right)) : 1+min(minDepth(root-&gt;left), minDepth(root-&gt;right)); &#125;&#125;; 112. Path SumDescription: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and 1sum = 22 , 12345678 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解题思路：递归，代码如下： 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val); &#125;&#125;; 501. Find Mode in Binary Search TreeDescription: Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], 123451 \\ 2 /2 return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 代码如下： 123456789101112131415161718192021222324class Solution &#123;private: vector&lt;int&gt; res;public: vector&lt;int&gt; findMode(TreeNode* root) &#123; int max, pre, cnt; getMax(root, max=0, pre, cnt=0); getMode(root, max, pre, cnt=0); return res; &#125; void getMax(TreeNode* root, int &amp;max, int &amp;pre, int &amp;cnt)&#123; if(!root) return; getMax(root-&gt;left, max, pre, cnt); getMax(root-&gt;right, max=cnt&gt;max?cnt:max, pre=root-&gt;val, ++(cnt*=(pre==root-&gt;val))); &#125; void getMode(TreeNode* root, int max, int &amp;pre, int &amp;cnt)&#123; if(!root) return; getMode(root-&gt;left, max, pre, cnt); if(++(cnt*=(root-&gt;val==pre)) == max) res.push_back(root-&gt;val); getMode(root-&gt;right, max, pre=root-&gt;val, cnt); &#125;&#125;; 538. Convert BST to Greater TreeDescription: Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: 123456789Input: The root of a Binary Search Tree like this: 5 / \\ 2 13Output: The root of a Greater Tree like this: 18 / \\ 20 13 解题思路：本题考察BST的中序遍历，代码如下： 12345678910111213141516class Solution &#123;private: int sum=0;public: TreeNode* convertBST(TreeNode* root) &#123; travel(root); return root; &#125; void travel(TreeNode* root)&#123; if(root == NULL) return; travel(root-&gt;right); sum += root-&gt;val; root-&gt;val = sum; travel(root-&gt;left); &#125;&#125;; 617. Merge Two Binary TreesDescription: Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: 123456789101112131415Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output: Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. 解题思路：根据题意来，代码如下： 1234567891011121314151617class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(t1!=NULL &amp;&amp; t2!=NULL)&#123; t1-&gt;val += t2-&gt;val; &#125;else if(t1==NULL)&#123; return t2; &#125;else if(t2==NULL)&#123; return t1; &#125;else&#123; return NULL; &#125; t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right); return t1; &#125;&#125;; 637. Average of Levels in Binary TreeDescription: Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1: 12345678910Input: 3 / \\ 9 20 / \\ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note: The range of node’s value is in the range of 32-bit signed integer. 解题思路：对树进行分层操作，自然而然会想到使用集合数据结构：队列 ，代码如下： 123456789101112131415161718192021class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; vector&lt;double&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty())&#123; int s = q.size(); int temp = 0; for(int i=0; i&lt;s; i++)&#123; TreeNode* node = q.front(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); temp += node-&gt;val; q.pop(); &#125; res.push_back(temp/(double)s); &#125; return res; &#125;&#125;; 108. Convert Sorted Array to Binary Search TreeDescription: Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 解题思路：根据BST特点解题，代码如下： 1234567891011121314class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return NULL; if(nums.size()==1) return new TreeNode(nums[0]); int mid = nums.size()/2; TreeNode* root = new TreeNode(nums[mid]); vector&lt;int&gt; l(nums.begin(), nums.begin()+mid); vector&lt;int&gt; r(nums.begin()+mid+1,nums.end()); root-&gt;left = sortedArrayToBST(l); root-&gt;right = sortedArrayToBST(r); return root; &#125;&#125;; 235. Lowest Common Ancestor of a Binary Search TreeDescription: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 12345678 _______6______ / \\ ___2__ ___8__/ \\ / \\0 _4 7 9 / \\ 3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 解题思路：结合BST特点，代码如下： 12345678class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &lt; min(p-&gt;val, q-&gt;val)) return lowestCommonAncestor(root-&gt;right, p, q); if(root-&gt;val &gt; max(p-&gt;val, q-&gt;val)) return lowestCommonAncestor(root-&gt;left, p, q); return root; &#125;&#125;; 653. Two Sum IV - Input is a BSTDescription: Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 1234567891011Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Example 2: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 28Output: False 解题思路：结合BST特点，将BST转化为升序数组，代码如下： 12345678910111213141516171819202122232425262728class Solution &#123;private: vector&lt;int&gt; res;public: bool findTarget(TreeNode* root, int k) &#123; travel(root); int i=0; int j=res.size()-1; while(i&lt;j)&#123; int sum = res[i]+res[j]; if(sum &gt; k)&#123; j--; &#125;else if(sum &lt; k)&#123; i++; &#125;else&#123; return true; &#125; &#125; return false; &#125; void travel(TreeNode* root)&#123; if(root == NULL) return; travel(root-&gt;left); res.push_back(root-&gt;val); travel(root-&gt;right); &#125;&#125;; 101. Symmetric TreeDescription: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 123456 1 / \\ 2 2 / \\ / \\3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 123456 1 / \\2 2 \\ \\ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. 解题思路：代码如下： 123456789101112class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return root==NULL || isSymmetricHelp(root-&gt;left, root-&gt;right); &#125; bool isSymmetricHelp(TreeNode* l, TreeNode* r)&#123; if(l==NULL || r==NULL) return l==r; if(l-&gt;val != r-&gt;val) return false; return isSymmetricHelp(l-&gt;left, r-&gt;right) &amp;&amp; isSymmetricHelp(l-&gt;right, r-&gt;left); &#125;&#125;; 563. Binary Tree TiltDescription: Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Example: 1234567891011Input: 1 / \\ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 Note: The sum of node values in any subtree won’t exceed the range of 32-bit integer. All the tilt values won’t exceed the range of 32-bit integer. 解题思路：代码如下： 12345678910111213141516class Solution &#123;public: int result = 0; int findTilt(TreeNode* root) &#123; postOrder(root); return result; &#125; int postOrder(TreeNode* root)&#123; if(!root) return 0; int l = postOrder(root-&gt;left); int r = postOrder(root-&gt;right); result += abs(l-r); return l+r+root-&gt;val; &#125;&#125;; 572. Subtree of Another TreeDescription: Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. Example 1:Given tree s: 123456 3 / \\ 4 5 / \\1 2 1234 4 / \\1 2 true Example 2:Given tree s: 12345678 3 / \\ 4 5 / \\1 2 / 0 1234 4 / \\1 2 false 解题思路：判断高度，判断是否相同，代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;TreeNode*&gt; nodes; bool isSubtree(TreeNode* s, TreeNode* t) &#123; if(!t &amp;&amp; !s)&#123; return true; &#125; if(!t || !s)&#123; return false; &#125; getDepth(s, getDepth(t, -1)); for(TreeNode* n : nodes)&#123; if(identical(n, t))&#123; return true; &#125; &#125; return false; &#125; int getDepth(TreeNode* r, int d)&#123; if(!r) return 0; int depth = max(getDepth(r-&gt;left, d), getDepth(r-&gt;right, d)) + 1; if(depth == d) nodes.push_back(r); return depth; &#125; bool identical(TreeNode* s, TreeNode* t)&#123; if(!s &amp;&amp; !t) return true; if(!s || !t || s-&gt;val!=t-&gt;val) return false; return identical(s-&gt;left, t-&gt;left) &amp;&amp; identical(s-&gt;right, t-&gt;right); &#125;&#125;; 671. Second Minimum Node In a Binary TreeDescripiton: Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: 12345678910Input: 2 / \\ 2 5 / \\ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. Example 2: 1234567Input: 2 / \\ 2 2Output: -1Explanation: The smallest value is 2, but there isn&#x27;t any second smallest value. 代码如下： 123456789101112131415161718192021222324252627class Solution &#123;public: int findSecondMinimumValue(TreeNode* root) &#123; if(root-&gt;left)&#123; if(root-&gt;left-&gt;val &lt; root-&gt;right-&gt;val)&#123; int l = findSecondMinimumValue(root-&gt;left); if(l==-1) return root-&gt;right-&gt;val; return min(l, root-&gt;right-&gt;val); &#125;else if(root-&gt;left-&gt;val &gt; root-&gt;right-&gt;val)&#123; int r = findSecondMinimumValue(root-&gt;right); if(r==-1) return root-&gt;left-&gt;val; return min(r, root-&gt;left-&gt;val); &#125;else&#123; int l = findSecondMinimumValue(root-&gt;left); int r = findSecondMinimumValue(root-&gt;right); if(l==-1) return r; if(r==-1) return l; return min(l, r); &#125; &#125;else&#123; return -1; &#125; return -1; &#125;&#125;; 687. Longest Univalue PathDescription: Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 123456 5 / \\ 4 5 / \\ \\1 1 5 Output: 122 Example 2: Input: 123456 1 / \\ 4 5 / \\ \\4 4 5 Output: 122 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 解题思路：本题需要使用搜索 ，代码如下： 12345678910111213141516171819class Solution &#123;public: int longestUnivaluePath(TreeNode* root) &#123; int lup = 0; if(root) dfs(root, lup); return lup; &#125;private: int dfs(TreeNode* node, int&amp; lup) &#123; int l = node-&gt;left ? dfs(node-&gt;left, lup) : 0; int r = node-&gt;right ? dfs(node-&gt;right, lup) : 0; int resl = node-&gt;left &amp;&amp; node-&gt;left-&gt;val == node-&gt;val ? l + 1 : 0; int resr = node-&gt;right &amp;&amp; node-&gt;right-&gt;val == node-&gt;val ? r + 1 : 0; lup = max(lup, resl + resr); return max(resl, resr); &#125; &#125;; 102. Binary Tree Level Order TraversalDescription: Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 123456 3 / \\9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 代码如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int n=q.size(); vector&lt;int&gt; tmp; for(int i=0;i&lt;n;i++)&#123; TreeNode* node=q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; 103. Binary Tree Zigzag Level Order TraversalDescription: Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 123456 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; stack&lt;TreeNode*&gt; s1; stack&lt;TreeNode*&gt; s2; int l=1; s1.push(root); while(!s1.empty()||!s2.empty())&#123; vector&lt;int&gt; tmp; if(l%2==1)&#123; while(!s1.empty())&#123; TreeNode* node=s1.top(); s1.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) s2.push(node-&gt;left); if(node-&gt;right) s2.push(node-&gt;right); &#125; &#125; else&#123; while(!s2.empty())&#123; TreeNode* node=s2.top(); s2.pop(); tmp.push_back(node-&gt;val); if(node-&gt;right) s1.push(node-&gt;right); if(node-&gt;left) s1.push(node-&gt;left); &#125; &#125; l++; res.push_back(tmp); &#125; return res; &#125;&#125;; 113. Path Sum IIDescription: Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 12345678 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] 代码如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; getPath(res,tmp,root,sum); return res; &#125; void getPath(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, TreeNode* root, int remain)&#123; if(root==NULL)&#123; return; &#125; tmp.push_back(root-&gt;val); if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; root-&gt;val==remain) res.push_back(tmp); getPath(res,tmp,root-&gt;left,remain-root-&gt;val); getPath(res,tmp,root-&gt;right,remain-root-&gt;val); tmp.pop_back(); &#125;&#125;; 114. Flatten Binary Tree to Linked ListDescription: Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 123456 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 代码如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;private: TreeNode* pre=NULL;public: void flatten(TreeNode* root) &#123; if(root==NULL) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right=pre; root-&gt;left=NULL; pre=root; &#125;&#125;; 116. Populating Next Right Pointers in Each NodeDescription: Given a binary tree 123456struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Example: Given the following perfect binary tree, 123456 1 / \\ 2 3 / \\ / \\4 5 6 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 代码如下： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/** * Definition for binary tree with next pointer.*/struct TreeLinkNode &#123; int val; TreeLinkNode *left, *right, *next; TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* pre=root; TreeLinkNode* cur=NULL; while(pre-&gt;left)&#123; cur=pre; while(cur)&#123; cur-&gt;left-&gt;next=cur-&gt;right; if(cur-&gt;next) cur-&gt;right-&gt;next=cur-&gt;next-&gt;left; cur=cur-&gt;next; &#125; pre=pre-&gt;left; &#125; &#125;&#125;; 117. Populating Next Right Pointers in Each Node IIDescription: Given a binary tree 123456struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Example: Given the following binary tree, 123456 1 / \\ 2 3 / \\ \\4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ \\4-&gt; 5 -&gt; 7 -&gt; NULL 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;/**Definition for binary tree with next pointer.*/ struct TreeLinkNode &#123; int val; TreeLinkNode *left, *right, *next; TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* head = NULL; //head of the next level TreeLinkNode* prev = NULL; //the leading node on the next level TreeLinkNode* cur = root; //current node of current level while (cur != NULL) &#123; while (cur != NULL) &#123; //iterate on the current level //left child if (cur-&gt;left != NULL) &#123; if (prev != NULL) &#123; prev-&gt;next = cur-&gt;left; &#125; else &#123; head = cur-&gt;left; &#125; prev = cur-&gt;left; &#125; //right child if (cur-&gt;right != NULL) &#123; if (prev != NULL) &#123; prev-&gt;next = cur-&gt;right; &#125; else &#123; head = cur-&gt;right; &#125; prev = cur-&gt;right; &#125; //move to next node cur = cur-&gt;next; &#125; //move to next level cur = head; head = NULL; prev = NULL; &#125; &#125;&#125;; 124. Binary Tree Maximum Path SumDescription: Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 12345678Input: [1,2,3] 1 / \\ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7Output: 42 代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;algorithm&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;private: int maxVal;public: int maxPathSum(TreeNode* root) &#123; maxVal=INT_MIN; maxPathSumDown(root); return maxVal; &#125; int maxPathSumDown(TreeNode* node)&#123; if(node==NULL) return 0; int left=max(0,maxPathSumDown(node-&gt;left)); int right=max(0,maxPathSumDown(node-&gt;right)); maxVal=max(maxVal,left+right+node-&gt;val); return max(left,right)+node-&gt;val; &#125;&#125;; 129. Sum Root to Leaf NumbersGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 / \\ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 / \\ 9 0 / \\5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026. 代码如下： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;private: int res=0;public: int sumNumbers(TreeNode* root) &#123; return sumNumbersHelp(root,0); &#125; int sumNumbersHelp(TreeNode* node, int n)&#123; if(!node) return 0; if(node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) return n*10+node-&gt;val; return sumNumbersHelp(node-&gt;left,n*10+node-&gt;val)+sumNumbersHelp(node-&gt;right,n*10+node-&gt;val); &#125;&#125;; 144. Binary Tree Preorder TraversalDescription: Given a binary tree, return the preorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] 代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; preHelp(root,res); return res; &#125; void preHelp(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(root==NULL) return; res.push_back(root-&gt;val); preHelp(root-&gt;left,res); preHelp(root-&gt;right,res); &#125;&#125;; 145. Binary Tree Postorder TraversalDescription: Given a binary tree, return the postorder traversal of its nodes’ values. Example: 123456789Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; postHelp(root,res); return res; &#125; void postHelp(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; postHelp(root-&gt;left,res); postHelp(root-&gt;right,res); res.push_back(root-&gt;val); &#125;&#125;; 173. Binary Search Tree IteratorDescription: Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. **Note: **next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. Credits:Special thanks to @ts for adding this problem and creating all test cases. 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;/** * Definition for binary tree*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class BSTIterator &#123;private: stack&lt;TreeNode*&gt; st;public: BSTIterator(TreeNode *root) &#123; pushAll(root); &#125; void pushAll(TreeNode* node)&#123; for(;node!=NULL;st.push(node),node=node-&gt;left); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !st.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode* tmp=st.top(); st.pop(); pushAll(tmp-&gt;right); return tmp-&gt;val; &#125;&#125;; 199. Binary Tree Right Side ViewDescription: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 代码如下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int n=q.size(); for(int i=0;i&lt;n;i++)&#123; TreeNode* tmp=q.front(); if(i==n-1) res.push_back(tmp-&gt;val); q.pop(); if(tmp-&gt;left) q.push(tmp-&gt;left); if(tmp-&gt;right) q.push(tmp-&gt;right); &#125; &#125; return res; &#125;&#125;; 236. Lowest Common Ancestor of a Binary TreeDescription: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] 12345678 _______3______ / \\ ___5__ ___1__/ \\ / \\6 _2 0 8 / \\ 7 4 Example 1: 1234Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of of nodes 5 and 1 is 3. Example 2: 1234Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. 代码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL || root==p || root==q) return root; TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q); return !left?right:!right?left:root; &#125;&#125;; 94. Binary Tree Inorder TraversalDescription: Given a binary tree, return the inorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 代码如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; sta; if(root==NULL) return res; TreeNode* curr=root; while(!sta.empty()||curr)&#123; if(curr)&#123; sta.push(curr); curr=curr-&gt;left; &#125;else&#123; TreeNode* node=sta.top(); sta.pop(); res.push_back(node-&gt;val); curr=node-&gt;right; &#125; &#125; return res; &#125;&#125;; 98. Validate Binary Search TreeDescription: Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456Input: 2 / \\ 1 3Output: true Example 2: 12345678 5 / \\ 1 4 / \\ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&#x27;s value is 5 but its right child&#x27;s value is 4. 代码如下： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* pre=NULL; return validate(root, pre); &#125; bool validate(TreeNode* root, TreeNode* &amp;pre)&#123; if(root==NULL) return true; if(!validate(root-&gt;left, pre)) return false; if(pre!=NULL &amp;&amp; pre-&gt;val&gt;=root-&gt;val) return false; pre=root; return validate(root-&gt;right,pre); &#125;&#125;; 99. Recover Binary Search TreeDescription: Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 12345678910111213141516Input: [1,3,null,null,2] 1 / 3 \\ 2Output: [3,1,null,null,2] 3 / 1 \\ 2 Example 2: 12345678910111213141516Input: [3,1,4,null,null,2] 3 / \\1 4 / 2Output: [2,1,4,null,null,3] 2 / \\1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;limits.h&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123; TreeNode* first=NULL; TreeNode* second=NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; help(root); swap(first-&gt;val, second-&gt;val); &#125; void help(TreeNode* root)&#123; if(root==NULL) return; help(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev=root; help(root-&gt;right); &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"对比AlexNet、VGG、GoogleNet和ResNet","slug":"对比AlexNet、VGG、GoogleNet和ResNet","date":"2017-10-14T12:08:23.000Z","updated":"2022-05-03T13:07:49.257Z","comments":true,"path":"2017/10/14/对比AlexNet、VGG、GoogleNet和ResNet/","link":"","permalink":"http://example.com/2017/10/14/%E5%AF%B9%E6%AF%94AlexNet%E3%80%81VGG%E3%80%81GoogleNet%E5%92%8CResNet/","excerpt":"","text":"最近几天阅读了AlexNet、VGG、GoogleNet和ResNet的论文，并且对AlexNet 和VGG 进行了总结。本文主要内容就是对比这四类网络结构。通过下表，我们看出这四种网络的各自的特点： 模型名 AlexNet VGG GoogleNet ResNet 出现时间 2012 2014 2014 2015 层数 8 19 22 152 Top-5错误 16.4% 7.3% 6.7% 3.57% Data Augmentation + + + + Inception - - + - 卷积层数 5 16 21 151 卷积核大小 11,5,3 3 7,1,3,5 7,1,3,5 全连接层数 3 3 1 1 Dropout + + + - Local Response Normalization + - + - Batch Normalization - - - + 参考 论文：AlexNet 论文：VGG 论文：GoogleNet 论文：ResNet","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AlexNet","slug":"AlexNet","permalink":"http://example.com/tags/AlexNet/"},{"name":"ResNet","slug":"ResNet","permalink":"http://example.com/tags/ResNet/"},{"name":"VGG","slug":"VGG","permalink":"http://example.com/tags/VGG/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://example.com/tags/GoogleNet/"}]},{"title":"AlexNet论文总结","slug":"AlexNet论文总结","date":"2017-10-13T02:40:14.000Z","updated":"2022-05-03T13:05:58.206Z","comments":true,"path":"2017/10/13/AlexNet论文总结/","link":"","permalink":"http://example.com/2017/10/13/AlexNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"最近我对CNN网络结构比较感兴趣，所以阅读了AlexNet、VGGNet、ResNet等论文。本文介绍AlexNet，在ILSVRC-2012大赛中，它夺得了第一名的佳绩。本文通过宏观和微观两个角度介绍AlexNet结构。 1. 宏观我们通过下面两个图对AlexNet有一个宏观的认识： AlexNet由5层卷积，3层Max pooling，3层全连接层组成，激活函数为ReLU. 用ReLU代替了传统的tanh或者logistic,好处有：收敛速度快。 2. 微观 硬件平台 两台GTX-530 3GB GPU，训练时间5-6天 数据预处理 每个像素减去平均活跃度（像素均值） 输入 图像规定大小：256*256 卷积规格 11 * 11 with stride 4, 5 * 5, 3 * 3 其中第二、第四和第五层卷积只连接同一GPU上前一层网络 第三层卷积是跨GPU连接前一层网络 Max pooling规格 overlapping pooling: 3 * 3 with stride 2 训练 优化器：SGD+momentum（0.9） batch size：128 weight decay：0.0005 权重初始化：随机选取自N(0, 0.01) 偏置初始化：第2、4、5层卷积和全连接层设置为1，其他层为0 减少过拟合 数据增强： 水平反转：对图像先进行水平反转，然后随机裁剪为224*224的图像 改变训练图像中RGB通道的强度。具体来说，遍及整个ImageNet训练集的RGB像素值集合中执行PCA。 Dropout 3 其他Local Response Normalization: 就是利用临近的数据做归一化，提高泛化问题。 参考 论文原文：ImageNet Classification with Deep Convolutional Neural Networks","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AlexNet","slug":"AlexNet","permalink":"http://example.com/tags/AlexNet/"}]},{"title":"VGGNet论文笔记","slug":"VGGNet论文笔记","date":"2017-10-11T10:47:47.000Z","updated":"2022-05-03T13:07:39.859Z","comments":true,"path":"2017/10/11/VGGNet论文笔记/","link":"","permalink":"http://example.com/2017/10/11/VGGNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1 INTRODUCTIONVGGNet是由牛津大学和Google DeepMind团队提出的，他们在ILSVRC-2014定位任务夺得第一名，分类任务获得第二名（GoogleNet是分类任务的第一名）。VGGNet具有很好的泛化能力，在其他数据集上也有较好的表现。 卷积网络现在在大规模图像和视频识别中取得了巨大的成功，成为了计算机视觉领域的常用工具。AlexNet是具有重要意义的网络结构，有很多人企图改进ALexNet，比如：ZFNet。ZFNet在第一卷积层使用更小的卷积(receptive window size)和更小的步长(stride)，而VGGNet强调了卷积神经网络设计中另一个重要方面—深度。并且VGGNet在所有层使用3*3的卷积核。 2 CONVNET CONFIGURATIONS为了公平测试深度带来的性能提升，VGGNet所有层的配置都遵循了同样的原则。 2.1 ARCHITECHTURE 唯一的预处理 ：训练集中的每个像素上减去RGB的均值 ； 训练时，输入是固定大小的224 * 224 RGB图像； 使用了非常小的感受野(receptive field)：3 * 3，甚至有的地方使用1 * 1的卷积,这种1 * 1的卷积可以被看做是对输入通道(input channel)的线性变换，卷积步长是1个像素； 池化层 采用max-pooling,共有5层，max-pooling的窗口是2 * 2，步长是2； 一系列卷积层之后跟着全连接层(fully-connected layers)。前两个全连接层均有4096个通道。第三个全连接层有1000个通道，用来分类。所有网络的全连接层配置相同。 最后一层是soft-max层 注： 所有隐层使用激活函数是ReLu .VGGNet不使用局部响应标准化(LRN)，这种标准化并不能在ILSVRC数据集上提升性能，却导致更多的内存消耗和计算时间。 2.2 CONFIGURATIONSTable1给出了所有的网络配置 2.3 DISCUSSION相比于AlexNet和ZFNet，VGGNet在网络中使用很小的卷积。AlexNet和ZFNet在第一个卷积层的卷积分别是11 * 11 with stride 4和7 * 7 with stride 2。 VGGNet使用三个3 * 3卷积而不是一个7 * 7的卷积的优势有两点：一，包含三个ReLu层而不是一个，使决策函数更有判别性；二，减少了参数。比如输入输出都是C个通道，使用3 * 3的3个卷积层需要3（3 * 3 * C * C）=27 * C * C,使用7 * 7的1个卷积层需要7 * 7 * C * C=49C * C。这可看为是对7 * 7卷积施加一种正则化，使它分解为3个3 * 3的卷积。 1*1卷积层主要是为了增加决策函数的非线性，而不影响卷积层的感受野。虽然1 * 1的卷积操作是线性的，但是ReLu增加了非线性。 GoogleNet采用了更深更复杂的网络结构（22层），多种卷积核（1 * 1，3 * 3， 5 * 5），并且在第一层中特征比VGGNet更少。 3 CLASSIFICATION FRAMEWORK3.1 TRAINING 优化函数：SGD+momentum（0.9） batch size：256 正则：采用L2正则化，weight decay是5e-4；dropout在前两个全连接层后，p=0.5。 参数初始化：随机初始化，权重w从N(0，0.01)中采样，偏差bias初始化为0。 为了获得224*224的输入图像，要在每个sgd迭代中对每张重新缩放(rescale)的图像随机裁剪。为了增强数据集，裁剪的图像还要随机水平翻转和RGB色彩偏移。 尽管相比于AlexNet网络更深，参数更多，但是我们推测VGGNet在更少的周期内就能收敛，原因有二：一，更大的深度和更小的卷积带来隐式的正则化；二，一些层的预训练。 3.2 TESTING测试阶段步骤： 对输入图像各向同性地重缩放到一个预定义的最小图像边的尺寸Q； 网络密集地应用在重缩放后的测试图像上。也就是说全连接层转化为卷积层（第一个全连接层转化为7 * 7的卷积层，后两个全连接层转化为1 * 1的卷积层） ，然后将转化后的全连接层应用在整张图像上。结果就是一个类别分数图(class score map)，其通道数等于类别数量，依赖于图像尺寸，具有不同的空间分辨率； 为了获得固定尺寸的类别分数向量(class score vector)，对class score map进行空间平均化处理(sum-pooled)。 3.3 IMPLEMENTATION DETAILS基于C++ Caffe, 在4个Titan GPU上训练了2-3周。 4 CLASSIFICATION EXPERIMENTS4.1 SINGLE SCALE EVALUATION 通过分析Table3结果，得出如下结论： 我们发现使用local response normalization(A-LRN)并不能改善A网络性能。 分类误差随着深度增加而降低。 在训练时采用图像尺度抖动(scale jittering)可以改善图像分类效果。 4.2 MULTI-SCALE EVALUATION 通过分析Table4结果，得出如下结论： 相对于单一尺度评估，多尺度评估提高了分类精度。 在训练时采用图像尺度抖动(scale jittering)可以改善图像分类效果。 4.3 MULTI-CROP EVALUATION 多裁剪(multi-crop)评估比起密集(dense)评估，效果更好。而且两者具有互补作用，结合两种方式，效果更好。 4.4 CONVNET FUSION 通过分析Table6结果，得出如下结论： 如果结合多个卷积网络的sofamax输出，分类效果会更好。 在ILSVRC-2014中，我们结合7个网络，实现测试误差7.3%。之后，结合最好的两个模型(D&amp;E)并使用密集评估(dense evaluation)，测试误差降低到7.0%，而使用密集评估和多裁剪评估相结合，测试误差为6.8%。最好的单一模型验证误差为7.1%。 4.5 COMPARISON WITH THE STATE OF THE ART 与ILSVRC-2012和ILSVRC-2013最好结果相比，VGGNet优势很大。与GoogLeNet对比，虽然7个网络集成效果不如GoogLeNet，但是单一网络测试误差好一些，而且只用2个网络集成效果与GoogLeNet的7网络集成差不多。 5 CONCLUSION我们将卷积网络深度设置为19，相比于其他网络，VGGNet效果更好，并且在其他不同的任务或数据集上有很好的泛化能力。 参考 论文原文：VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION http://blog.csdn.net/muyiyushan/article/details/62895202","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"VGGNet","slug":"VGGNet","permalink":"http://example.com/tags/VGGNet/"}]},{"title":"虚函数的作用","slug":"虚函数的作用","date":"2017-10-10T10:37:50.000Z","updated":"2022-05-03T13:07:57.748Z","comments":true,"path":"2017/10/10/虚函数的作用/","link":"","permalink":"http://example.com/2017/10/10/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"1. 虚函数 虚函数 的目的是为了允许用基类的指针调用子类的虚函数，是必须实现 的函数。虚函数是C++实现动态单分派子类型多态 的方式： 动态：在运行时决定的 单分派：基于一个类型去选择调用哪个函数 子类型多态：以子类-父类关系实现多态 下面通过一个例子来具体说明： 12345678910111213141516171819202122class A &#123; public: virtual void foo() &#123; cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl; &#125; &#125;; class B:public A &#123; public: void foo() &#123; cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl; &#125; &#125;; int main(void) &#123; A *a = new B(); a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的! return 0; &#125; 虚函数只能借助于指针或者引用来达到多态的目的，核心理念就是通过基类访问派生类定义的函数。 2. 纯虚函数 纯虚函数 是在基类中定义，但不能实现 ，只能由其派生类自己定义实现此函数。形式如下： virtual ReturnType Function()=0 引入纯虚函数的好处： 纯虚函数定义了一个接口 ，起到了规范作用 包含纯虚函数的类是抽象类，抽象类是不能被实例化的。如果派生类没有实现纯虚函数，那么此派生类也是抽象类；如果派生类给出了基类中的纯虚函数的实现，那么此派生类就不是抽象类。 注： 析构函数是虚函数； 友元函数不是虚函数，但它可以通过调用虚函数来解决友元的虚拟问题。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"虚函数","slug":"虚函数","permalink":"http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"LeetCode-math类总结(会持续更新...)","slug":"LeetCode-math类总结","date":"2017-10-07T11:21:31.000Z","updated":"2022-05-03T13:07:29.502Z","comments":true,"path":"2017/10/07/LeetCode-math类总结/","link":"","permalink":"http://example.com/2017/10/07/LeetCode-math%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的math类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 204. Count PrimesDescription: Count the number of prime numbers less than a non-negative number, n. Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. 解题思路：本题利用了素数的概念和打表法 ，代码如下： 123456789101112131415161718class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; check(n); //bool []check = new bool[n]; int count = 0; for(int i=2; i&lt;n; i++)&#123; if(check[i]==false)&#123; count++; for(int j=2;i*j&lt;n;j++)&#123; check[j*i]=true; &#125; &#125; &#125; return count; &#125;&#125;; 263. Ugly NumberDescription:Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. 解题思路：直接除以2，3，5，代码如下： 123456789101112131415161718class Solution &#123;public: bool isUgly(int num) &#123; while(num &gt; 1)&#123; if(num%2 == 0)&#123; num /= 2; &#125;else if(num%3 == 0)&#123; num /= 3; &#125;else if(num%5 == 0)&#123; num /= 5; &#125;else&#123; break; &#125; &#125; return num==1; &#125;&#125;; 400. Nth DigitDescription:Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Note:n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1: 123456Input:3Output:3 Example 2: 12345678Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 代码如下： 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findNthDigit(int n) &#123; long base = 9; long digits = 1; while(n-base*digits &gt; 0)&#123; n -= base*digits; base *=10; digits++; &#125; int index = n%digits; if(index == 0)&#123; index=digits; &#125; int num = 1; for(int i=1; i&lt;digits; i++)&#123; num *= 10; &#125; num += (index==digits) ? n/digits - 1 : n/digits; for(int i=index; i&lt;digits; i++)&#123; num /= 10; &#125; return num%10; &#125;&#125;; 633. Sum of Square NumbersDescription:Given a non-negative integer c, your task is to decide whether there’re two integers a and b such that a2 + b2 = c. Example 1: 1234Input: 5Output: TrueExplanation: 1 * 1 + 2 * 2 = 5 Example 2: 12Input: 3Output: False 解题思路：使用双指针逼近，代码如下： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;class Solution&#123;public: bool judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int l = 0; int r = (int)sqrt(c); while(l&lt;=r)&#123; temp = l*l + r*r; if(temp &lt; c)&#123; l++; &#125;else if(temp &gt; c)&#123; r--; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125;; 367. Valid Perfect SquareDescription: Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: 123Input: 16Returns: True Example 2: 123Input: 14Returns: False Credits:Special thanks to @elmirap for adding this problem and creating all test cases. 代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: bool isPerfectSquare(int num) &#123; for(int i=1; num&gt;0; i+=2)&#123; num -= i; &#125; return num==0; &#125; bool isPerfectSquare2(int num)&#123; int left = 1; int right = num; while(left&lt;=right)&#123; int mid = left + (right - left)/2; int temp = mid*mid; if(temp &lt; num)&#123; left=mid+1; &#125;else if(temp &gt; num)&#123; right = mid-1; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125;; 172. Factorial Trailing ZeroesDescription: Given an integer n, return the number of trailing zeroes in n!. **Note: **Your solution should be in logarithmic time complexity. Credits:Special thanks to @ts for adding this problem and creating all test cases. 123456789101112class Solution &#123;public: int trailingZeroes(int n) &#123; long result = 0; long x = 5; while(x&lt;=n)&#123; result += n/x; x *=5; &#125; return result; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"LeetCode-string类总结（会持续更新...）","slug":"LeetCode-string类总结","date":"2017-09-29T09:03:09.000Z","updated":"2022-05-03T13:07:31.211Z","comments":true,"path":"2017/09/29/LeetCode-string类总结/","link":"","permalink":"http://example.com/2017/09/29/LeetCode-string%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的string类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 125. Valid PalindromeDescription: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 解题思路：本题判读回文，看到回文我们通常会直接想到使用栈 ，代码如下： 12345678910111213141516171819202122232425class Solution &#123;public: bool isPalindrome(string s) &#123; stack&lt;char&gt; bag; string str = &quot;&quot;; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]&gt;=&#x27;A&#x27; &amp;&amp; s[i]&lt;=&#x27;Z&#x27;)&#123; str += char(s[i]+32); bag.push(s[i]+32); &#125;else if((s[i]&gt;=&#x27;a&#x27;&amp;&amp;s[i]&lt;=&#x27;z&#x27;)||(s[i]&gt;=&#x27;0&#x27;&amp;&amp;s[i]&lt;=&#x27;9&#x27;))&#123; str += s[i]; bag.push(s[i]); &#125; &#125; int len = bag.size(); //if(len==1 &amp;&amp; s.size()&gt;1) return false; int count = 0; for(int i=0;i&lt;len;i++)&#123; if(str[i] != bag.top()) break; count++; bag.pop(); &#125; return count==len; &#125;&#125;; 168. Excel Sheet Column TitleDescription: Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 解题思路：本题考察进制，需要注意的一点是：此题中不是从0才是，而是从1开始。代码如下： 123456789101112131415161718class Solution &#123;public: string convertToTitle(int n) &#123; string s=&quot;&quot;; if(n&lt;27)&#123; s+=char(64+n); return s; &#125; int x = n%26; n /= 26; if(x == 0)&#123; n--; x=26; &#125; s = convertToTitle(n) + char(64+x); return s; &#125;&#125;; 459. Repeated Substring PatternDescription: Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1: 123456Input: &quot;abab&quot;Output: TrueExplanation: It&#x27;s the substring &quot;ab&quot; twice. Example 2: 1234Input: &quot;aba&quot;Output: False Example 3: 12345Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&#x27;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 解题思路：本题判断字符串是否是由重复子串组成的，这题有个trick：将原始串扩增一倍，去掉首尾各一个字符，判断此串是否含有原始串，代码如下： 123456789class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; if(s.size() &lt; 2) return false; string temp = s+s; temp = temp.substr(1,temp.size()-2); return temp.find(s)!=-1; &#125;&#125;; 606. Construct String from Binary TreeDescription: You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: 12345678910111213Input: Binary tree: [1,2,3,4] 1 / \\ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;. Example 2: 1234567891011Input: Binary tree: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&#x27;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 解题思路：本题涉及到了树，我们首先确定树的遍历方式，本题适合前序遍历，代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: string tree2str(TreeNode* t) &#123; if(t == NULL) return &quot;&quot;; string result = &quot;&quot;; result += to_string(t-&gt;val); string left = tree2str(t-&gt;left); string right = tree2str(t-&gt;right); if(left==&quot;&quot; &amp;&amp; right==&quot;&quot;) return result; if(left==&quot;&quot;) return result+&quot;()&quot;+&quot;(&quot;+right+&quot;)&quot;; if(right==&quot;&quot;) return result+&quot;(&quot;+right+&quot;)&quot;; return result+&quot;(&quot;+left+&quot;)&quot;+&quot;(&quot;+right+&quot;)&quot;; &#125;&#125;; 557. Reverse Words in a String IIIDescription:Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: 123Input: &quot;Let&#x27;s take LeetCode contest&quot;Output: &quot;s&#x27;teL ekat edoCteeL tsetnoc&quot; Note: In the string, each word is separated by single space and there will not be any extra space in the string. 解题思路：本题要求反转字符串，很自然的会想到用栈 ，但是本题提示不能使用额外的空间，那只能STL中的方法reverse(), 代码如下： 123456789101112131415class Solution &#123;public: string reverseWords(string s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] != &#x27; &#x27;) &#123; // when i is a non-space int j = i; for (; j &lt; s.length() &amp;&amp; s[j] != &#x27; &#x27;; j++) &#123; &#125; // move j to the next space reverse(s.begin() + i, s.begin() + j); i = j - 1; &#125; &#125; return s; &#125;&#125;; 520. Detect CapitalDescription: Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”. Example 1: 123Input: &quot;USA&quot;Output: True Example 2: 123Input: &quot;FlaG&quot;Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. 代码如下： 123456789101112131415class Solution &#123;public: bool detectCapitalUse(string word) &#123; int count = 0; for(int i=0; i&lt;word.size(); i++)&#123; if(word[i]&lt;97) count++; &#125; if(count==word.size() || count==0)&#123; return true; &#125;else if(count==1)&#123; return word[0] &lt; 97; &#125; return false; &#125;&#125;; 392. Is SubsequenceDescription: Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and sis a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not). Example 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot; Return true. Example 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot; Return false. Follow up:If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. 解题思路：代码如下： 123456789101112131415class Solution &#123;public: bool isSubsequence(string s, string t) &#123; if(s.size()==0) return true; int indexT=0, indexS=0; while(indexT&lt;t.size())&#123; if(t[indexT]==s[indexS])&#123; indexS++; if(indexS==s.size()) return true; &#125; indexT++; &#125; return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]},{"title":"XGBoost算法原理","slug":"XGBoost算法原理","date":"2017-09-29T01:43:26.000Z","updated":"2022-05-03T13:07:47.324Z","comments":true,"path":"2017/09/29/XGBoost算法原理/","link":"","permalink":"http://example.com/2017/09/29/XGBoost%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/","excerpt":"","text":"XGBoost是数据挖掘类竞赛中经常使用的一大利器，它帮助选手在Kaggle、阿里天池大数据比赛等比赛取得了很好的成绩。XGBoost被很多人使用，但很少人知道其原理，前几天看了一下陈天奇大神的论文有了更多的理解。XGBoost是基于GBDT(Gradient Boosting Decision Tree) 改进而来的，本文将对XGBoost算法原理进行介绍，主要通过以下几个部分进行介绍：boosted trees、目标函数正则化、节点切分算法。 注： 本文假设读者理解回归树算法、泰勒公式、梯度下降法和牛顿法 1. Boosted treesBoosted trees是一种集成方法，Boosting算法是一种加法模型(additive training)，定义如下： 这里K是树的棵数，f(x)是函数空间中的一个函数： q(x)表示将样本x分到了某个叶子节点上，w是叶子节点的分数（leaf score） 下面通过一个具体的例子来说明：预测一个人是否喜欢电脑游戏，下图表明小男孩更喜欢打游戏。 2. 目标函数正则化XGBoost使用的目标函数如下： 我们可以看出XGBoost在GBDT的误差函数基础上加入了L1和L2正则项，其中Loss函数可以是平方损失或逻辑损失，T代表叶子节点数，w代表叶子节点的分数。加入正则项的好处是防止过拟合，这个好处是由两方面体现的：一是预剪枝，因为正则项中有限定叶子节点数；二是正则项里leaf scroe的L2模平方的系数，对leaf scroe做了平滑。 接下来我们对目标函数进行目标函数的求解： 该目标函数表示：第i样本的第t次迭代误差函数，后面的推导基于上式。这种学习方式已经从函数空间转到了函数空间： 下面对目标函数进行泰勒公式二级展开、化简： 如果确定了树的结构，为了使目标函数最小，可以令其导数为0，解得每个叶节点的最优预测分数为： 代入目标函数，解得最小损失为： 3. 节点切分算法我们已经确定了损失函数，以及最优解，接下来我们需要缺点树的结构，即如何选出最优分裂节点。我们可以参照决策树算法：ID3选择信息增益为切分准则，C4.5选择信息增益率为切分准则。XGBoost基本思想是和决策树一致的：贪心法枚举所有节点，计算各个节点分裂前后的信息增益，选出信息增益最大的。下面是XGBoost信息增益的定义： XGBoost提供了两种切分算法：精确贪心算法和近似算法 精确贪心算法： 在所有特征上暴力枚举所有可能的切分点，算法如下： 近似算法： 其基本思想：首先根据特征的统计分布（分位数）选出候选切分点；然后对于连续属性特征，根据候选切分点进行离散化；最后会从这些候选切分点中选出最优的。近似算法提出了两种版本：global variant和local variant. global variant在树初始化时就确定了候选切分点；local variant是在每次节点分裂后重新选出候选点。论文中的实验表明：在同等精度下，相对于global variant, local variant需要的候选切分点更少。近似算法如下： 近似算法举例：三分位数 注： 近似算法中使用到了分位数，关于分位数的选取，论文提出了一种算法Weighted Quantile Sketch 。XGBoost不是按照样本个数进行分位，而是以二阶导数为权重。 Q: 为什么使用hi加权？ A: 比较直观的解释是因为目标函数可以化简为如下形式： 4. 其他 在实际工作中，大多数输入是稀疏的。造成稀疏的原因有很多种，比如：缺失值、one-hot编码等。因此，论文提出为树中的节点设置一个默认方向来应对稀疏输入。论文实验表明稀疏感知算法 要比传统方法快50倍，算法如下： 下面通过例子具体说明： 注： 红色路径代表默认方向 Shrinkage: 可以理解为学习率，算法每次迭代后会乘这个系数； 列采样： 降低过拟合，论文实验表明列采样比行采样效果好。 参考文献 XGBoost: A Scalable Tree Boosting System Introduction to Boosted Trees Wepon的GBDT算法原理与系统设计简介PPT GBDT详解，火光摇曳","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"XGBoost","slug":"XGBoost","permalink":"http://example.com/tags/XGBoost/"},{"name":"GBDT","slug":"GBDT","permalink":"http://example.com/tags/GBDT/"}]},{"title":"KL散度、JS散度、Wasserstein距离","slug":"KL散度JS散度Wasserstein距离","date":"2017-09-27T02:26:28.000Z","updated":"2022-05-03T13:06:54.944Z","comments":true,"path":"2017/09/27/KL散度JS散度Wasserstein距离/","link":"","permalink":"http://example.com/2017/09/27/KL%E6%95%A3%E5%BA%A6JS%E6%95%A3%E5%BA%A6Wasserstein%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"1. KL散度 KL散度又称为相对熵，信息散度，信息增益。KL散度是是两个概率分布P和Q 差别的非对称性的度量。 KL散度是用来 度量使用基于Q的编码来编码来自P的样本平均所需的额外的位元数。 典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。 定义如下： 因为对数函数是凸函数，所以KL散度的值为非负数。 有时会将KL散度称为KL距离，但它并不满足距离的性质： KL散度不是对称的； KL散度不满足三角不等式。 2. JS散度(Jensen-Shannon) JS散度度量了两个概率分布的相似度，基于KL散度的变体，解决了KL散度非对称的问题。一般地，JS散度是对称的，其取值是0到1之间。定义如下： KL散度和JS散度度量的时候有一个问题： 如果两个分配P,Q离得很远，完全没有重叠的时候，那么KL散度值是没有意义的，而JS散度值是一个常数。这在学习算法中是比较致命的，这就意味这这一点的梯度为0。梯度消失了。 3. Wasserstein距离 Wasserstein距离度量两个概率分布之间的距离，定义如下： Π(P1,P2)是P1和P2分布组合起来的所有可能的联合分布的集合。对于每一个可能的联合分布γ，可以从中采样(x,y)∼γ得到一个样本x和y，并计算出这对样本的距离||x−y||，所以可以计算该联合分布γ下，样本对距离的期望值E(x,y)∼γ[||x−y||]。在所有可能的联合分布中能够对这个期望值取到的下界infγ∼Π(P1,P2)E(x,y)∼γ[||x−y||]就是Wasserstein距离。 直观上可以把E(x,y)∼γ[||x−y||]理解为在γ这个路径规划下把土堆P1挪到土堆P2所需要的消耗。而Wasserstein距离就是在最优路径规划下的最小消耗。所以Wesserstein距离又叫Earth-Mover距离。 Wessertein距离相比KL散度和JS散度的优势在于：即使两个分布的支撑集没有重叠或者重叠非常少，仍然能反映两个分布的远近。而JS散度在此情况下是常量，KL散度可能无意义。 References: 维基百科KL散度 维基百科JS散度 维基百科Wasserstein距离","categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"信息论","slug":"信息论","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"}]},{"title":"自编码器","slug":"自编码器","date":"2017-09-19T02:21:59.000Z","updated":"2022-05-03T13:08:01.787Z","comments":true,"path":"2017/09/19/自编码器/","link":"","permalink":"http://example.com/2017/09/19/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/","excerpt":"","text":"自编码器（auto-encoder）是神经网络的一种，经过训练后能尝试将输入复制到输出。自编码器内部有一个隐藏层h,可以产生编码表示输入。该网络可以看作由两个部分组成：一个由函数h=f(x)表示的编码器和一个生成重构的解码器r=g(h)。我们会将自编码器设计成输入到输出近似相等，通常需要向自编码器强加一些一些约束，使它只能近似地复制。这些约束强制模型考虑输入数据的哪些部分需要被优先复制，因此它往往能学习到数据的有用特性。传统自编码器被用于降维或特征学习。 1. 欠完备自编码器我们通常不关心解码器的输出，一般希望通过训练自编码器对输入进行复制而使h获得有用特性。从自编码器获得有用特征的一种方法是限制h的维度比x小，这种编码维度小于输入维度的自编码器称为欠完备自编码器。学习欠完备的表示将强制自编码器捕捉训练数据中最显著的特征。 拥有非线性编码器函数f 和非线性解码器函数g 的自编码器能够学习出更强大的PCA 非线性推广。不幸的是，如果编码器和解码器被赋予过大的容量，自编码器会执行复制任务而捕捉不到任何有关数据分布的有用信息。 2. 正则自编码器理想情况下，根据要建模的数据分布的复杂性，选择合适的编码维数和编码器、解码器容量，就可以成功训练任意架构的自编码器。正则自编码器提供这样的能力。正则自编码器使用的损失函数可以鼓励模型学习其他特性（除了将输入复制到输出），而不必限制使用浅层的编码器和解码器以及小的编码维数来限制模型的容量。这些特性包括稀疏表示、表示的小导数、以及对噪声或输入缺失的鲁棒性。即使模型容量大到足以学习一个无意义的恒等函数，非线性且过完备的正则自编码器仍然能够从数据中学到一些关于数据分布的有用信息。 稀疏自编码器 稀疏自编码器简单地在训练时结合编码层的稀疏惩罚项和重构误差： 其中g(h)是解码器输出，通常h是编码器的输出，即h=f(x)。 稀疏自编码器一般用来学习特征，以便用于像分类这样的任务。稀疏正则化的自编码器必须反映训练数据集的独特统计特征，而不是简单地充当恒等函数。以这种方式训练，执行附带稀疏惩罚的复制任务可以得到能学习有用特征的模型。 我们可以认为整个稀疏自编码器框架是对带有潜变量的生成模型的近似最大似然训练，而不将稀疏惩罚视为复制任务的正则化。 去噪自编码器 去噪自编码器（denoising autoencoder, DAE）最小化 其中x~是被某种噪声损坏的x的副本。因此去噪自编码器必须撤销这些损坏，而不是简单地复制输入。 3. 表示能力、层的大小和深度自编码器通常只有单层的编码器和解码器，但这不是必然的。实际上深度编码器和解码器能提供更多优势。 万能近似定理保证至少有一层隐藏层且隐藏单元足够多的前馈神经网络能以任意精度近似任意函数（在很大范围里），这是非平凡深度（至少有一层隐藏层）的一个主要优点。这意味着具有单隐藏层的自编码器在数据域内能表示任意近似数据的恒等函数。但是，从输入到编码的映射是浅层的。这意味这我们不能任意添加约束，比如约束编码稀疏。深度自编码器（编码器至少包含一层额外隐藏层）在给定足够多的隐藏单元的情况下，能以任意精度近似任何从输入到编码的映射。 深度可以指数地降低表示某些函数的计算成本。深度也能指数地减少学习一些函数所需的训练数据量。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AE","slug":"AE","permalink":"http://example.com/tags/AE/"}]},{"title":"循环和递归网络学习笔记","slug":"循环和递归网络学习笔记","date":"2017-09-16T06:46:41.000Z","updated":"2022-05-03T13:07:59.555Z","comments":true,"path":"2017/09/16/循环和递归网络学习笔记/","link":"","permalink":"http://example.com/2017/09/16/%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"循环神经网络（recurrent neural network）是一类用于处理序列数据的神经网络；就像卷积网络是专门处理网格化数据的神经网络。循环神经网络共享参数方式与卷积网络是不同的，它的输出项是前一项的函数，即输出的每一项对先前的输出应用相同的更新规则而产生。 1. 展开计算图本质上任何涉及循环的函数都可以被认为是一个循环神经网络，比如下面的表达式： 典型的RNN会增加额外的架构特性，如读取状态信息h进行预测的输出层，下图是其展开的结构： 展开过程带来了两个主要优点： 无论序列的长度，学成的模型始终具有相同的输入大小，因为它指定的是从一种状态到另一种状态的转移，而不是在可变长度的历史状态上操作； 我们可以在每个时间步使用相同参数的相同转移函数f。 2. 循环神经网络基于上面所说的图展开和参数共享的思想，我们可以设计各种循环神经网络。循环神经网络中一些重要的设计模式包括以下几种： 每个时间步都有输出，并且隐藏单元之间有循环连接的循环网络，如图 A 所示。 图A 每个时间步都产生一个输出，只有当前时刻的输出到下个时刻的隐藏单元之间有循环连接的循环网络，如图 B 所示。 图B 隐藏单元之间存在循环连接，但读取整个序列后产生单个输出的循环网络，如图 C 所示。 图C 现在我们研究图A 中 RNN 的前向传播公式，假设隐藏单元的激活函数为双曲正切激活函数，并且输出是离散的，如用于预测词或字符的RNN，表示离散变量的常规方式是把输出o 作为每个离散变量可能值的非标准化对数概率。然后可以应用 softmax函数后续处理，获得标准化后概率的输出向量 。更新方程如下： 这个循环网络将一个输入序列映射到相同长度的输出序列，与x序列配对的y的总损失就是所有时间步的损失之和。 3. 双向RNN目前为止我们考虑的所有循环神经网络有一个“因果”结构，意味着在时刻t的状态只能从过去的序列以及当前的输入捕获信息。然而，在许多应用中，我们要输出的预测可能依赖于整个输入序列。双向循环神经网络为满足这种需要而被发明的。顾名思义，双向 RNN 结合时间上从序列起点开始移动的 RNN 和另一个时间上从序列末尾开始移动的 RNN。典型的双向 RNN 如下图所示： 4. 基于编码-解码的序列到序列结构本节主要讨论如何训练RNN，使其将输入序列映射到不一定等长的输出序列。 编码-解码或序列到序列架构的想法非常简单： 编码器(encoder)或读取器(reader)或输入(input) RNN 处理输入序列，输出上下文 C（通常是最终隐藏状态的简单函数）。 解码器(decoder)或写入器(writer)或输出(output) RNN 则以固定长度的向量为条件，产生输出序列 Y=(y(1),⋯,y(ny))Y=(y(1),⋯,y(ny))。 这种架构的创新之处在于长度 nx和 ny可以彼此不同，而之前的架构约束 nx=ny=τ。编码-解码或序列到序列架构如下图所示： 编码-解码或序列到序列的 RNN 架构由读取输入序列的编码器 RNN 以及生成输出序列（或计算给定输出序列的概率）的解码器 RNN 组成。编码器 RNN 的最终隐藏状态用于计算一般为固定大小的上下文变量 C，C 表示输入序列的语义概要并且作为解码器 RNN 的输入。 此架构的一个明显不足是，编码器 RNN输出的上下文 C 的维度太小而难以适当地概括一个长序列。有人提出让 C成为可变长度的序列，而不是一个固定大小的向量，他们还引入了将序列 C 的元素和输出序列的元素相关联的**注意力机制(attention mechanism)**，这在《深度学习之自然语言处理》中会详细介绍。 5. 深度循环网络大多数 RNN 中的计算可以分解成三块参数及其相关的变换： 从输入到隐藏状态 从前一隐藏状态到下一隐藏状态 从隐藏状态到输出 实验证据表明在这些操作中引入深度会有利，与我们需要足够的深度以执行所需映射的想法一致。Graves 第一个展示了将 RNNRNN 的状态分为多层的显著好处，如下图所示： 循环神经网络可以通过许多方式变得更深：(a) 隐藏循环状态可以被分解为具有层次的组。(b) 可以向输入到隐藏，隐藏到隐藏以及隐藏到输出的部分引入更深的计算 (如 MLP)。这可以延长链接不同时间步的最短路径。(c) 可以引入跳跃连接来缓解路径延长的效应。 我们可以认为，在 (a) 所示层次结构中较低的层起到了将原始输入转化为对更高层的隐藏状态更合适表示的作用。上图 (b) 更进一步提出在上述三个块中各使用一个单独的 MLP（可能是深度的），考虑表示容量，我们建议在这三个步中都分配足够的容量，但增加深度可能会因为优化困难而损害学习效果。在一般情况下，更容易优化较浅的架构，加入 (b) 的额外深度导致从时间步 t 的变量到时间步 t+1 的最短路径变得更长。例如，如果具有单个隐藏层的 MLP 被用于状态到状态的转换，那么与之前的图相比，我们就会加倍任何两个不同时间步变量之间最短路径的长度。然而 Pascanu 认为，在隐藏到隐藏的路径中引入跳跃连接可以缓和这个问题，如 (c) 所示。 6. 递归神经网络递归神经网络代表循环网络的另一个扩展， 它被构造为深的树状结构而不是 RNN 的链状结构，因此是不同类型的计算图。递归网络的典型计算图如下图所示： 递归网络将循环网络的链状计算图推广到树状计算图。可变大小的序列 x(1),x(2),⋯,x(t) 可以通过固定的参数集合（权重矩阵 U,V,W）映射到固定大小的表示（输出 o）。 递归网络的一个明显优势是，对于具有相同长度 τ 的序列，深度（通过非线性操作的组合数量来衡量）可以急剧地从 τ 减小为 O(logτ)，这可能有助于解决长期依赖。一个悬而未决的问题是如何以最佳的方式构造树。一种选择是使用不依赖于数据的树结构，如平衡二叉树。理想的情况下，人们希望学习器自行发现和推断适合于任意给定输入的树结构。 7. 长期依赖的挑战在前馈网络或循环网络中，当计算图变得极深时，神经网络优化算法会面临的一个难题就是长期依赖问题——经过许多阶段传播后的梯度倾向于消失（大部分情况）或爆炸（很少，但对优化过程影响很大），即：变深的结构使模型丧失了学习到先前信息的能力，让优化变得极其困难。因为循环网络要在很长时间序列的各个时刻重复应用相同操作来构建非常深的计算图，并且模型参数共享，这使问题更加凸显。 有人可能会希望通过简单地停留在梯度不消失或爆炸的参数空间来避免这个问题。不幸的是，为了储存记忆并对小扰动具有鲁棒性，RNN 必须进入参数空间中的梯度消失区域。具体来说，每当模型能够表示长期依赖时，长期相互作用的梯度幅值就会变得指数小（相比短期相互作用的梯度幅值）。这并不意味着这是不可能学习的，由于长期依赖关系的信号很容易被短期相关性产生的最小波动隐藏，因而学习长期依赖可能需要很长的时间。实验表明，当我们增加了需要捕获的依赖关系的跨度， 基于梯度的优化变得越来越困难，SGD 在长度仅为 10 或 20 的序列上成功训练传统 RNN 的概率迅速变为 0。 8. 渗漏单元和其他多时间尺度的策略处理长期依赖的一种方法是设计工作在多个时间尺度的模型，使模型的某些部分在细粒度时间尺度上操作并能处理小细节，而其他部分在粗时间尺度上操作并能把遥远过去的信息更有效地传递过来。 时间维度的跳跃连接 增加从遥远过去的变量到目前变量的直接连接是得到粗时间尺度的一种方法。在普通的循环网络中，循环从时刻 t 的单元连接到时刻 t+1 单元。 正如之前所说，梯度可能关于时间步数呈指数消失或爆炸。有人引入了 d 延时的循环连接以减轻这个问题。现在导数指数减小的速度与 τ/d 相关而不是 τ。既然同时存在延迟和单步连接，梯度仍可能成 t 指数爆炸。这允许学习算法捕获更长的依赖性，但不是所有的长期依赖都能在这种方式下良好地表示。 渗漏单元和一系列不同时间尺度 获得 导数乘积接近1 的另一方式是设置线性自连接单元，并且这些连接的权重接近1。 我们对某些 vv 值应用更新 μ(t)←αμ(t−1)+(1−α)v(t) 累积一个滑动平均值 μ(t)， 其中 α 是一个从 μ(t−1) 到 μ(t) 线性自连接的例子。当 α 接近 11 时，滑动平均值能记住过去很长一段时间的信息，而当 α 接近 00，关于过去的信息被迅速丢弃。线性自连接的隐藏单元可以模拟滑动平均的行为，这种隐藏单元称为**渗漏单元(leaky unit)**。 d 时间步的跳跃连接可以确保单元总能被先前的 d 个时间步值影响。使用权重接近 1 的线性自连接是确保该单元可以访问过去值的不同方式。线性自连接通过调节实值 α 更平滑灵活地调整这种效果，而不是调整整数值的跳跃长度。 我们可以通过两种基本策略设置渗漏单元使用的时间常数。一种策略是手动将其固定为常数，例如在初始化时从某些分布采样它们的值。另一种策略是使时间常数成为自由变量，并学习出来。在不同时间尺度使用这样的渗漏单元似乎能帮助学习长期依赖。 删除连接 处理长期依赖另一种方法是在多个时间尺度组织 RNN 状态的想法，信息在较慢的时间尺度上更容易长距离流动。 这个想法与之前讨论的时间维度上的跳跃连接不同，因为它涉及主动删除长度为一的连接并用更长的连接替换它们。以这种方式修改的单元被迫在长时间尺度上运作。收到这种新连接的单元，可以学习在长时间尺度上运作，但也可以选择专注于自己其他的短期连接。 强制一组循环单元在不同时间尺度上运作有不同的方式。一种选择是使循环单元变成渗漏单元，但不同的单元组关联不同的固定时间尺度。另一种选择是使显式且离散的更新发生在不同的时间，不同的单元组有不同的频率。 9. 长短期记忆和其他门控RNN目前实际应用中最有效的序列模型称为门控RNN（gated RNN），包括基于长短期记忆（long short-term memory）和基于门控循环单元（gated recurrent unit）的网络。 像渗漏单元一样，门控 RNN 想法也是基于生成通过时间的路径，其中导数既不消失也不发生爆炸。渗漏单元通过手动选择常量的连接权重或参数化的连接权重来达到这一目的。门控 RNN 将其推广为在每个时间步都可能改变的连接权重。 渗漏单元允许网络在较长持续时间内积累信息（诸如用于特定特征或类的线索）。然而，一旦该信息被使用，让神经网络遗忘旧的状态可能是有用的。例如，如果一个序列是由子序列组成，我们希望渗漏单元能在各子序列内积累线索，我们需要将状态设置为 0 以忘记旧状态的的机制。我们希望神经网络学会决定何时清除状态，而不是手动决定，这就是门控 RNN 要做的事。 LSTM 引入自循环的巧妙构思，以产生梯度长时间持续流动的路径是初始**长短期记忆(long short-term memory, LSTM)**模型的核心贡献。其中一个关键扩展是使自循环的权重视上下文而定，而不是固定的。门控此自循环（由另一个隐藏单元控制）的权重，累积的时间尺度可以动态地改变。在这种情况下，即使是具有固定参数的 LSTM，累积的时间尺度也可以因输入序列而改变，因为时间常数是模型本身的输出。 LSTM块如图所示： 上图为 LSTM 循环网络“细胞”的框图。细胞彼此循环连接，代替一般循环网络中普通的隐藏单元。这里使用常规的人工神经元计算输入特征。如果 sigmoid 输入门允许，它的值可以累加到状态。状态单元具有线性自循环，其权重由遗忘门控制。细胞的输出可以被输出门关闭。所有门控单元都具有 sigmoid 非线性，而输入单元可具有任意的压缩非线性。状态单元也可以用作门控单元的额外输入。黑色方块表示单个时间步的延迟。 LSTM 循环网络除了外部的 RNN 循环外， 还具有内部的“LSTM 细胞”循环（自环），因此 LSTM 不是简单地向输入和循环单元的仿射变换之后施加一个逐元素的非线性。与普通的循环网络类似，每个单元有相同的输入和输出，但也有更多的参数和控制信息流动的门控单元系统。 LSTM 网络比简单的循环架构更易于学习长期依赖，目前各种 LSTM 的变体和替代也已经被研究和使用。 其他门控RNN LSTM 架构中哪些部分是真正必须的？还可以设计哪些其他成功架构允许网络动态地控制时间尺度和不同单元的遗忘行为？ 最近关于门控 RNN 的工作给出了这些问题的某些答案，其单元也被称为门控循环单元或 GRU。与 LSTM 的主要区别是，单个门控单元同时控制遗忘因子和更新状态单元的决定。 复位和更新门能独立地“忽略”状态向量的一部分。更新门像条件渗漏累积器一样可以线性门控任意维度，从而选择将它复制（在 sigmoid 的一个极端）或完全由新的“目标状态”值（朝向渗漏累积器的收敛方向）替换并完全忽略它（在另一个极端）。 复位门控制当前状态中哪些部分用于计算下一个目标状态，在过去状态和未来状态之间引入了附加的非线性效应。 围绕这一主题可以设计更多的变种。例如复位门（或遗忘门）的输出可以在多个隐藏单元间共享。或者，全局门的乘积（覆盖一整组的单元，例如整一层）和一个局部门（每单元）可用于结合全局控制和局部控制。然而，一些调查发现这些 LSTM 和 GRU 架构的变种，在广泛的任务中难以明显地同时击败这两个原始架构。 本文内容摘取自 《Deep Learning》，部分内容有修改。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://example.com/tags/RNN/"}]},{"title":"Tips of Deep Learning课程笔记","slug":"Tips-of-Deep-learning","date":"2017-09-15T12:59:10.000Z","updated":"2022-05-03T13:07:37.106Z","comments":true,"path":"2017/09/15/Tips-of-Deep-learning/","link":"","permalink":"http://example.com/2017/09/15/Tips-of-Deep-learning/","excerpt":"","text":"本文是关于李宏毅老师的机器学习课程笔记，有些部分稍有改动。本文主要介绍Deep Learning(DL)调参技巧，下图表示了DL的一般流程，在这个过程中，我们会着重关注overfitting的问题。 当我们发现模型overfitting时，不要总以为是参数太多导致overfitting，我们应该首先去看模型在training data上效果如何。 同时，我们在修正overfitting时，要注意不同的方法针对不同的问题。有的方法是针对训练误差，而有的方法是针对测试误差的，比如：Dropout 下面就是一些经常用到策略： 我们发现当深度越深，会造成浅层梯度更新慢，深层梯度更新快，深层会快速收敛。这样的话，学习到参数是不好的，因为浅层的参数是随机初始化的，并且无法更新到浅层参数。 另外当我们使用的激活函数是sigmoid的时，会造成梯度更新越来越小，梯度消失。因此，我们平时经常使用ReLU。ReLU在使用过程在小范围内是线性的，不会是梯度太小。 不同的激活函数，有不同的效果；因此，提出了可学习激活函数—Maxout。 在测试集上调整overfitting时，我们一般通过三种方法进行调整early stopping、regularization、Dropout，现在主要介绍一下Dropout： Dropout其实是一种集成方法，因为每次mini-batch进行一次dropout操作，产生不同的网络。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"tips","slug":"tips","permalink":"http://example.com/tags/tips/"}]},{"title":"卷积网络","slug":"卷积网络","date":"2017-09-14T11:40:37.000Z","updated":"2022-05-03T13:07:51.262Z","comments":true,"path":"2017/09/14/卷积网络/","link":"","permalink":"http://example.com/2017/09/14/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/","excerpt":"","text":"卷积网络是一种专门用来处理具有类似网格结构的数据的神经网络。在卷积网络的术语中，卷积的第一个参数通常叫做输入，第二个参数叫做核函数，输出有时被称为特征映射。在机器学习的应用中，输入通常是多维数组的数据，而核通常是由学习算法优化得到的多维数组的参数。一般地，单独使用卷积运算在机器学习中比较少见，卷积通常和其他函数一起使用。下面演示一个在2维tensor上的卷积： 为什么我们可以用卷积网络处理图像： 我们不必去观察整张图来发现pattern，只需要关注一小部分就可以了； 相同的pattern可能出现在图像的不同区域； 使用子采样不改变对象 1. 特点卷积运算通过三个策略来改进机器学习系统：稀疏交互、参数共享、等变表示。 稀疏交互 稀疏交互就是稀疏连接，神经网络属于局部连接，不再是全连接。这样做可以带来两方面的好处：一是参数更少；二是计算量下降，存储空间降低。下图可以直观说明： 参数共享 参数共享是指在一个模型的多个函数中使用相同的参数，保证了我们只需要学习一个参数集合，而不是对于每一个位置都需要学习一个单独的参数集合。 等变表示 对于卷积，参数共享的特殊形式使得神经网络层具有对平移等变的性质。如果一个函数满足输入改变，输出也以同样的方式改变这一性质。 2. 池化卷积网络有一个典型层包含三级：在第一级中，并行地计算多个卷积产生一组线性变换；在第二级中，每个线性变换会经过一个非线性激活函数；在第三级中，使用池化函数调整输出。池化函数使用某一位置的相邻输出的总体统计特征来代替该位置的输出。 对于平移不变性是指当我们对输入进行少量平移时，经过池化函数后的大多数输出并不会发生改变。因为池化综合了全部邻居的反馈，这使得池化单元少于探测单元成为可能，这种方法提高了网络的计算效率，减小了存储需求。 本文内容摘取自《Deep Learning》，部分内容有所修改","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://example.com/tags/CNN/"}]},{"title":"深度模型中的优化","slug":"深度模型中的优化","date":"2017-09-08T02:33:09.000Z","updated":"2022-05-03T13:07:54.608Z","comments":true,"path":"2017/09/08/深度模型中的优化/","link":"","permalink":"http://example.com/2017/09/08/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"大多数深度学习算法都涉及到优化，优化是指改变x来最大化或最小化某个函数f(x)。 1. 学习和纯优化有什么不同用于深度模型训练的优化算法与传统的优化有几方面是不同的：机器学习通常是间接作用的，比如间接地优化P，一般通过降低损失函数来提高P； 经验风险最小化 我们将最小化平均训练误差的过程称为经验风险最小化(Empirical Risk Minimization)，这种情况下，机器学习仍然和传统的直接优化很相似。我们不是直接最优化风险，而是最优化经验风险，希望也能够同时显著降低风险。然而，经验风险最小化容易导致过拟合，在深度学习中我们很少使用它。 代理损失函数和提前终止 有时，真正的损失函数（比如分类误差）并不能被高效地优化。这种情况下，我们通常会优化代理损失函数。代理损失函数作为原目标的代理，还具备一些优点。在某些情况下，代理损失函数比原函数学到的更多。一般的优化和训练算法的优化有一个重要的不同：训练算法一般不会停止在局部极小点。这么做是为了防止过拟合，一般会使用提前终止机制。与纯优化相比，提前终止时代理损失函数仍有很大的导数，而纯优化终止时导数比较小。 批量算法和小批量算法 机器学习算法和一般优化算法不同的一点是：机器学习算法的目标函数通常可以分解为训练样本上的求和。机器学习中的优化算法在计算参数的每一次更新时通常仅使用整个代价函数中一部分项来估计代价函数的期望值。使用整个训练集的优化算法被称为批量或确定性梯度算法，因为它们会在一个大批量中同时处理所有样本。每次只使用单个样本的优化算法有时被称为随机或者在线算法。术语“在线”通常是指从连续产生样本的数据流中抽取样本的情况，而不是从一个固定大小的训练集中遍历多次采样的情况。小批量的大小通常用以下几个因素决定： 更大的批量会计算精度更高的梯度估计，但是回报却是小于线性。 极小批量通常难以充分利用多核架构，这促使我们使用一些绝对最小批量。 如果批量处理中的所有样本可以并行地处理，那么内存消耗和批量大小会成正比。 在某些硬件上使用特定大小的数组时，运行时间会更少。尤其是在使用GPU时，通常使用2的幂数作为批量大小可以获得更少的运行时间。 可能由于小批量在学习过程中加入了噪声，它们会有一些正则化效果。泛化误差通常在批量大小为1时最好。 小批量是随机抽取的，这一点很重要。一般地，我们会将样本顺序随机打乱，然后一组组小批量样本连续读取。 2. 神经网络优化中的挑战传统的机器学习会小心设计目标函数和约束，以确保优化问题是凸的，从而避免一般优化问题的复杂度。在训练神经网络时，我们肯定会碰到非凸的情况。即便是凸优化，也可能会碰到其他问题。 病态 病态问题一般是指在神经网络训练过程中，随机梯度下降会被“卡”在某些情况，此时即使很小的更新步长也会增加损失函数。牛顿法在解决带有病态条件的Hessian矩阵的凸优化问题时，是一个非常优秀的工具。 局部极小值 由于模型可辨识性问题，神经网络中会存在多个等效的局部极小值。一方面神经网络中会存在多个局部极小值，另一方面每个局部极小值的求解代价是不同的。有可能一个等效的局部极小值，它的代价更大。我们无法去辨识哪个代价更大。 PS：模型可辨识性：一个模型只能由唯一确定的参数所确定，不存在其他参数来等效确定。 高原、鞍点和其他平坦区域 对于很多高维非凸函数而言，相比局部极小值，鞍点存在的可能性更大。在低维空间中，局部极小值很普遍。在更高维空间中，局部极小值点很罕见，而鞍点却很常见。对于牛顿法而言，鞍点显然是一个问题。梯度下降旨在朝“下坡”移动，而非明确寻找临界点。而牛顿法的目标是寻求梯度为0的点。如果没有适当修改，牛顿法就会跳进一个鞍点。 悬崖和梯度爆炸 多层神经网络通常存在像悬崖一样的斜率较大区域，这是因为几个较大的权重相乘导致的。遇到这种悬崖结构时，梯度更新会很大程度地改变参数值，可能会使大量已完成的优化工作成为无用功。因此，我们通常选择完全跳过这类悬崖结构，常用的方法是启发式梯度截断来避免其严重的后果。其基本思想是：因为梯度并没有说明最佳不畅，只是说明无限小区域内的最佳方向，所以当传统的梯度下降算法提议更新很大一步时，启发式梯度截断就会干涉来减小步长。从而使其不太可能走出梯度近似为最陡下降方向的悬崖区。悬崖结构在循环神经网络的损失函数中很常见，因为它涉及到很多个因子的相乘。 长期依赖 当计算图变得极深时，神经网络优化算法会面临的另一个难题就是长期依赖问题：由于变深的结构使模型丧失了学习到先前信息的能力，让优化变得极其困难。同时会造成梯度消失与梯度爆炸问题。梯度消失使得我们难以知道参数朝哪个方向移动来改进损失函数；而梯度爆炸会使得学习不稳定。在循环网络中，一般使用相同权重矩阵来避免这个问题。 3. 基本算法 随机梯度下降 基本思想：将数据中抽取m个小批量样本，通过计算它们梯度均值，我们可以得到梯度的无偏估计。SGD算法中的一个关键参数学习率。在实践中，推荐使用随着时间的推移逐渐降低学习率的策略。对于大数据集，SGD只需非常少量样本计算梯度从而实现初始快速更新，远远超过了其缓慢的渐近收敛。 动量 虽然随机梯度下降仍然是非常受欢迎的优化方法，但其学习过程有时会很慢。动量方法旨在加速学习，特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。动量算法积累了之前梯度指数级衰减的移动平均，并且继续沿该方向移动。 从形式上看，动量算法引入了变量v充当速度角色，它即代表参数的移动方向，又代表速率。速度被设为负梯度的指数衰减平均。梯度下降算法基于每个梯度简单地更新一步，而使用动量算法的牛顿方案则使用该力改变粒子的速度。我们可以将粒子视作在冰面上滑行的冰球。每当它沿着表面最陡的部分下降时，它会累积继续在该方向上滑行的速度，直到其开始向上滑动为止。 形象地，我们可以将损失函数看出山的高度，然后我们将一个小球从这个山上滚下来。小球的速度会越来越快，使得小球可以越过山腰上的沟壑，有机会快速到达谷底。并且为了防止小球速度过快，我们会设置一个超参，该参数相当于物理中的阻尼系数。 Nesterov动量 Nesterov动量和标准动量之间的区别体现在梯度计算上，Nesterov动量中，梯度计算发生在施加当前速度之后。因此，Nesterov动量可以解释为往标准方法中添加了一个校正因子。 如上图所示，我们可以对比一下Nesterov动量法和标准动量法区别。动量法首先计算当前的梯度值（小蓝色向量），然后在更新的积累向量（大蓝色向量）方向前进一大步。但 NAG 法则首先（试探性地）在之前积累的梯度方向（棕色向量）前进一大步，再根据当前地情况修正，以得到最终的前进方向（绿色向量）。这种基于预测的更新方法，使我们避免过快地前进，并提高了算法地响应能力（responsiveness），大大改进了 RNN 在一些任务上的表现。 4. 参数初始化策略深度模型的训练算法通常是迭代的，所以需要指定一些开始迭代的初始点，这些初始点会影响算法是否收敛。并且当算法收敛时，初始点还可以影响其收敛的速度，以及是否收敛到一个代价高或低的点。现在的初始化策略是简单的、启发式的。我们对于初始点如何影响泛化的理解相当原始的，几乎没有提供如何选择初始点的任何指导。 到目前为止，唯一确知的特性是初始参数需要在不同单元间“破坏对称性”：如果两个隐藏层单元有着相同的激活函数以及相同的输入，那么它们必须使用不同的初始参数。通常情况下，我们可以为每个单元的偏置设置启发式挑选的常数，仅随机初始化权重。我们经常 对权重的选取随机取自高斯或均匀分布中的值。 关于初始化网络，正则化和优化有着不同的观点。优化观点建议权重 尽可能成功地传播信息，而正则化希望其小一点。优化算法倾向于最终参数应接近初始参数。 设置偏置的方法必须和设置权重的方法协调。设置偏置为0在大多数初始化方案中是可行的，但也存在一些设置为非0 的情况： 如果偏置是作为输出单元，那么初始化偏置以获取正确的输出边缘统计通常是有利的。我们假设初始权重足够小，该单元的输出仅由偏置决定。这说明设置偏置为应用于训练集上输出边缘统计的激活函数的逆。 有时，我们会选择偏置来避免初始化引起太大饱和。 5. 自适应学习率算法学习率会对模型的性能有显著的影响，Delta-bar-delta算法是一个早期的在训练时适应模型参数各自学习率的启发式方法。其基本思想：如果损失对于某个给定模型参数的偏导保持相同的符号，那么学习率应该增加。如果对于该参数的偏导变化了符号，那么学习率应减小。这种方法只能应用于全批量优化中，最近提出一些增量（或基于小批量）的算法来自适应模型参数的学习率。 AdaGrad 此算法独立地适应模型所有参数的学习率，缩放每个参数反比于其所有梯度历史平方值总和的平方根。具有损失最大的偏导的参数相应地有一个快速下降的学习率，而具有小偏导的参数在学习率上有相对较小的下降。然而在实践中，发现从训练开始时积累梯度平方会导致有效学习率过早和过量的减小。 RMSProp 此算法修改AdaGrad以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。RMSProp使用指数衰减平均以丢失遥远过去的历史，使其能够在找到凸碗状结构后快速收敛。 Adam Adam利用了AdaGrad和RMSProp在稀疏数据上的优点，对初始化的偏差修正也让Adam表现的更好。很多deep learning的优化问题都用Adam。 6. 二阶近似方法 牛顿法 牛顿法是基于二阶泰勒级数展开在某地$\\theta_0$附件来近似$J(\\theta)$的优化方法，其忽略了高阶导数。对于局部的二次函数，用Hession矩阵的逆来重新调整梯度，牛顿法会直接跳到极小值。如果目标函数是凸的但非二次的（有高阶项），该更新将是迭代的。牛顿法要保证Hession矩阵是正定才能使其是有效的，并且牛顿法还受限于其显著的计算负担。这就导致只有参数很少的网络才能在实际中用牛顿法训练。 共轭梯度 共轭梯度是一种通过迭代下降的共轭方向以有效避免Hession矩阵求逆计算的方法，其中在于梯度相关的方向上使用了线搜索。该方法在二次碗型目标中是一个相当低效的来回往复，锯齿形模式。这是因为每个由梯度给定的线搜索方向，都保证正交于上一个线搜索方向。 在共轭梯度法中，我们寻求一个和先前线搜索方向共轭的搜索方向，即它不会撤销该方向上的进展。 BFGS Broyden-Fletcher-Goldfarb-Shanno(BFGS)算法具有牛顿法的一些优点，但没有牛顿法的计算负担。在这方面，BFGS和CG很像。然而，BFGS使用了一个更直接的方法近似牛顿更新，使用矩阵M近似逆，迭代地低秩更新精度以更好的近似Hession的逆。 与共轭梯度法相似，BFGS算法迭代一系列线搜索，其方向含二阶信息。与共轭梯度不同的是，该方法的成功并不严重依赖于线搜索寻找该方向上和真正极小值很近的一点，这样的话，BFGS花费较少的时间改进每个线搜索。另一方面，BFGS算法必须存储Hession逆矩阵M，使得BFGS不适用于大多数具有百万级参数的现代深度学习模型。 存储受限的BFGS（L-BFGS） 通过避免存储完整的Hession逆近似M，BFGS算法的存储代价可以显著降低。 ​ 1本文内容摘取自《Deep Learning》，部分内容有所修改 ​","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://example.com/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"深度学习中的正则化","slug":"深度学习中的正则化","date":"2017-09-05T07:20:49.000Z","updated":"2022-05-03T13:07:56.078Z","comments":true,"path":"2017/09/05/深度学习中的正则化/","link":"","permalink":"http://example.com/2017/09/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/","excerpt":"","text":"在机器学习中，会有许多策略来减小测试误差，但这些策略可能会引起训练误差的增大，这些策略被统称为正则化策略。在深度学习的背景下，大多数正则化策略都是对估计进行正则化。估计的正则化通常是以偏差的增加换取方差的减少，一个有效的正则化就是能显著减少方差而不过度增加偏差。现在我们回顾一下几种策略 1. 参数范数惩罚许多正则化方法通过对目标函数$J$添加一个参数范数惩罚项$\\Omega (\\theta)$，限制模型的学习能力。正则化后的目标函数变为$\\overline{J}$:$$\\overline{J}(\\theta; X, y) = J(\\theta; X, y) + \\alpha\\Omega(\\theta)$$$\\alpha​$是惩罚项系数，$\\alpha​$系数越大，对应正则化惩罚越大。 在本节中，我们关注各种范数惩罚对模型的影响。在讨论之前，我们需要特别说明一下，在神经网络中，参数包括每一层仿射变换的权重和偏置，我们通常只对权重做惩罚而不对偏置做正则惩罚。 $L_{2}$参数正则化 这个正则化策略通过向目标函数添加一个正则项$\\Omega(\\theta)=\\frac{1}{2}||\\omega||_{2}^2$,使权重更加接近原点，我们通过研究正则化后目标函数的梯度，观察权重衰减的正则化表现。这里我们假定没有偏置参数，因此$\\theta$就是$\\omega$,则我们目标函数为：$$\\overline{J}(\\omega; X, y) = \\frac{\\alpha}{2}\\omega^T\\omega + J(\\omega; X, y)$$相应的梯度为：$$\\nabla_\\omega\\overline{J}(\\omega; X, y) = \\alpha\\omega + \\nabla_\\omega J(\\omega; X, y)$$使用单步梯度下降更新权重，执行以下更新：$$\\omega\\leftarrow(1-\\epsilon\\alpha)\\omega-\\epsilon\\nabla_\\omega J(\\omega; X, y)$$我们可以看到，加入权重衰减后会引起学习规则的修改，即在每步执行梯度更新之前先收缩权重向量。H是$\\omega​$处于最优时对应的Hessian矩阵，正则化的“微观”表现就是，沿着H特征值较大的方向正则化的影响较小。即：只有在显著减小目标函数方向上的参数会保留得相对完好。在无助于目标函数减小的方向（对应Hessian 矩阵较小的特征值）上改变参数不会显著增加梯度。这种不重要方向对应的分量会在训练过程中因正则化而衰减掉。 $L_{1}$参数正则化 对模型参数$\\omega$的$L_{1}$正则化被定义为：$$\\Omega(\\theta)=||\\omega||_1=\\sum_i{|\\omega_i|}$$这时的正则化目标函数$\\overline{J}(\\omega; X, y)​$为：$$\\overline{J}(\\omega; X, y) = \\alpha||\\omega||_1+J(\\omega; X, y)$$对应的梯度为：$$\\nabla_\\omega\\overline{J}(\\omega; X,y)=\\alpha sign(\\omega)+\\nabla_\\omega J(\\omega;X,y)$$其中$sign(\\omega)​$只是简单地取$\\omega​$各个元素的正负号。 相比$L_{2}$正则化，$L_{1}$正则化会产生更稀疏的解，$L_{1}$正则化有可能通过足够大的$\\alpha$实现稀疏。$L_{1}$正则化被广泛应用与特征选择。 2. 作为约束的范数惩罚在原始目标函数上添加一系列惩罚项，每个惩罚项是一个被称为KKT乘子的系数以及一个表示约束是否满足的函数之间的乘积。 3. 数据集增强数据集增强对一个具体的分类问题来说是特别有效的方法：对象识别。图像是高维的并包括各种巨大的变化因素，其中有许多可以轻易地模拟。即使模型已使用卷积和池化技术对部分平移保持不变，沿训练图像每个方向平移几个像素的操作通常可以大大改善泛化。许多其他操作如旋转图像或缩放图像也已被证明非常有效。 在神经网络的输入层注入噪声(Sietsma and Dow, 1991) 也可以被看作是数据增强的一种方式。对于许多分类甚至一些回归任务而言，即使小的随机噪声被加到输入，任务仍应该是能够被解决的。然而，神经网络被证明对噪声不是非常健壮(Tang and Eliasmith, 2010)。改善神经网络健壮性的方法之一是简单地将随机噪声添加到输入再进行训练。 4. 噪声鲁棒性对于某些模型而言，向输入添加方差极小的噪声等价于对权重施加范数惩罚(Bishop, 1995a,b)。在一般情况下，注入噪声远比简单地收缩参数强大，特别是噪声被添加到隐藏单元时会更加强大。 另一种正则化模型的噪声使用方式是将其加到权重，这项技术主要用于RNN，这种形式的正则化鼓励参数进入权重小扰动对输出相对影响较小的参数空间区域。换句话说，它推动模型进入对权重小的变化相对不敏感的区域，找到的点不只是极小点，还是由平坦区域所包围的极小点。 1本文内容摘取自《Deep Learning》，部分内容有所修改","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"正则化","slug":"正则化","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"}]},{"title":"Keras学习笔记III-网络层","slug":"Keras学习笔记III-网络层","date":"2017-09-02T06:32:56.000Z","updated":"2022-05-03T13:06:52.887Z","comments":true,"path":"2017/09/02/Keras学习笔记III-网络层/","link":"","permalink":"http://example.com/2017/09/02/Keras%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0III-%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"1. 常用层常用层对应于core模块 Dense层 常用的全连接层 12345678910111213keras.layers.core.Dense(units, activation=None, use_bias=True, kernel_initializer=&#x27;glorot_uniform&#x27;, bias_initializer=&#x27;zeros&#x27;, kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)# 参数：# units：大于0的整数，代表该层的输出维度。# activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）# use_bias: 布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象 Activation层 激活层对一个层的输出施加激活函数 1234keras.layers.core.Activation(activation)# 参数# activation：将要使用的激活函数 Dropout层 Dropout将在训练过程中每次更新参数时随机断开一定百分比的输入神经元，Dropout层用于防止过拟合 123456keras.layers.core.Dropout(rate, noise_shape=None, seed=None)# 参数# rate：0~1的浮点数，控制需要断开的神经元的比例# noise_shape:整数张量，为将要应用在输入上的二值Dropout mask的shape，例如你的输入为（batch_size, timesteps,features),并且你希望在各个时间步上的Dropout mask都相同，则可传入noise_shape=(batch_size,1,features)。# seed：整数，使用的随机数种子 Flatten层 Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过度。Flatten不影响batch的大小。 1keras.layers.core.Flatten() 2. 卷积层Convolutional Conv2D层 二维卷积层，即对图像的空域卷积。该层对二维输入进行滑动窗卷积，当使用该层作为第一层时，应提供input_shape参数。例如input_shape = (128,128,3)代表128*128的彩色RGB图像（data_format=&#39;channels_last&#39;） 12345678910111213141516171819keras.layers.convolutional.Conv2D(filters, kernel_size, strides=(1, 1), padding=&#x27;valid&#x27;, data_format=None, dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer=&#x27;glorot_uniform&#x27;, bias_initializer=&#x27;zeros&#x27;, kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)# 参数# filters：卷积核的数目（即输出的维度）# kernel_size：单个整数或由两个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。# strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rata均不兼容# padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。# activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）# dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rata均与任何不为1的strides均不兼容。# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。# use_bias:布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象 Cropping2D层 对2D输入（图像）进行裁剪，将在空域维度，即宽和高的方向上裁剪 123456keras.layers.convolutional.Cropping2D(cropping=((0, 0), (0, 0)), data_format=None)# 参数# cropping：长为2的整数tuple，分别为宽和高方向上头部与尾部需要裁剪掉的元素数# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 UpSampling2D层 将数据的行和列分别重复size[0]和size[1]次 123456keras.layers.convolutional.UpSampling2D(size=(2,2), data_format=None)# 参数# size：整数tuple，分别为行和列上采样因子# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 ZeroPadding2D层 对2D输入（如图片）的边界填充0，以控制卷积以后特征图的大小 123456keras.layers.convolutional.ZeroPadding2D(padding=(1,1), data_format=None)# 参数# padding：整数tuple，表示在要填充的轴的起始和结束处填充0的数目，这里要填充的轴是轴3和轴4（即在&#x27;th&#x27;模式下图像的行和列，在‘channels_last’模式下要填充的则是轴2，3）# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 3. 池化层Pooling MaxPooling2D层 为空域信号施加最大值池化 12345678keras.layers.pooling.MaxPooling2D(pool_size=(2, 2), strides=None, padding=&#x27;valid&#x27;, data_format=None)# 参数# pool_size：整数或长为2的整数tuple，代表在两个方向（竖直，水平）上的下采样因子，如取（2，2）将使图片在两个维度上均变为原长的一半。为整数意为各个维度值相同且为该数字。# strides：整数或长为2的整数tuple，或者None，步长值。# border_mode：‘valid’或者‘same’# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 AveragePooling2D层 12345678keras.layers.pooling.AveragePooling2D(pool_size=(2,2), strides=None, padding=&#x27;valid&#x27;, data_format=None)# 参数# pool_size：整数或长为2的整数tuple，代表在两个方向（竖直，水平）上的下采样因子，如取（2，2）将使图片在两个维度上均变为原长的一半。为整数意为各个维度值相同且为该数字。# strides：整数或长为2的整数tuple，或者None，步长值。# border_mode：‘valid’或者‘same’# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 GlobalMaxPooling2D层 为空域信号施加全局最大值池化 12345keras.layers.pooling.GlobalMaxPooling2D(dim_ordering=&#x27;default&#x27;)#参数# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 GlobalAveragePooling2D层 为空域信号施加全局平均值池化 12345keras.layers.pooling.GlobalAveragePooling2D(dim_ordering=&#x27;default&#x27;)# 参数# data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是~/.keras/keras.json中设置的值，若从未设置过，则为“channels_last”。 ​ 4. 循环层Recurrent SimpleRNN层 全连接RNN网络，RNN的输出会被回馈到输入 12345678910111213141516171819keras.layers.recurrent.SimpleRNN(units, activation=&#x27;tanh&#x27;, use_bias=True, kernel_initializer=&#x27;glorot_uniform&#x27;, recurrent_initializer=&#x27;orthogonal&#x27;, bias_initializer=&#x27;zeros&#x27;, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0)# 参数# units：输出维度# activation：激活函数，为预定义的激活函数名（参考激活函数）# use_bias: 布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# recurrent_initializer：循环核的初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# recurrent_regularizer：施加在循环核上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# recurrent_constraints：施加在循环核上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象# dropout：0~1之间的浮点数，控制输入线性变换的神经元断开比例# recurrent_dropout：0~1之间的浮点数，控制循环状态的线性变换的神经元断开比例 GRU层 12345678910111213141516171819keras.layers.recurrent.GRU(units, activation=&#x27;tanh&#x27;, recurrent_activation=&#x27;hard_sigmoid&#x27;, use_bias=True, kernel_initializer=&#x27;glorot_uniform&#x27;, recurrent_initializer=&#x27;orthogonal&#x27;, bias_initializer=&#x27;zeros&#x27;, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0)# 参数# units：输出维度# activation：激活函数，为预定义的激活函数名（参考激活函数）# use_bias: 布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# recurrent_initializer：循环核的初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# recurrent_regularizer：施加在循环核上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# recurrent_constraints：施加在循环核上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象# dropout：0~1之间的浮点数，控制输入线性变换的神经元断开比例# recurrent_dropout：0~1之间的浮点数，控制循环状态的线性变换的神经元断开比例 LSTM层 1234567891011121314151617181920keras.layers.recurrent.LSTM(units, activation=&#x27;tanh&#x27;, recurrent_activation=&#x27;hard_sigmoid&#x27;, use_bias=True, kernel_initializer=&#x27;glorot_uniform&#x27;, recurrent_initializer=&#x27;orthogonal&#x27;, bias_initializer=&#x27;zeros&#x27;, unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0)# 参数# units：输出维度# activation：激活函数，为预定义的激活函数名（参考激活函数）# recurrent_activation: 为循环步施加的激活函数（参考激活函数）# use_bias: 布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# recurrent_initializer：循环核的初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# recurrent_regularizer：施加在循环核上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# recurrent_constraints：施加在循环核上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象# dropout：0~1之间的浮点数，控制输入线性变换的神经元断开比例# recurrent_dropout：0~1之间的浮点数，控制循环状态的线性变换的神经元断开比例 5. 规范层BatchNormalization BatchNormalization层 该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1. BN层的作用： 加速收敛 控制过拟合，可以少用或不用Dropout和正则 降低网络对初始化权重不敏感 允许使用较大的学习率 1234567891011121314151617keras.layers.normalization.BatchNormalization(axis=-1, momentum=0.99, epsilon=0.001, center=True, scale=True, beta_initializer=&#x27;zeros&#x27;, gamma_initializer=&#x27;ones&#x27;, moving_mean_initializer=&#x27;zeros&#x27;, moving_variance_initializer=&#x27;ones&#x27;, beta_regularizer=None, gamma_regularizer=None, beta_constraint=None, gamma_constraint=None)# 参数# axis: 整数，指定要规范化的轴，通常为特征轴。例如在进行data_format=&quot;channels_first的2D卷积后，一般会设axis=1。# momentum: 动态均值的动量# epsilon：大于0的小浮点数，用于防止除0错误# center: 若设为True，将会将beta作为偏置加上去，否则忽略参数beta# scale: 若设为True，则会乘以gamma，否则不使用gamma。当下一层是线性的时，可以设False，因为scaling的操作将被下一层执行。# beta_initializer：beta权重的初始方法# gamma_initializer: gamma的初始化方法# moving_mean_initializer: 动态均值的初始化方法# moving_variance_initializer: 动态方差的初始化方法# beta_regularizer: 可选的beta正则# gamma_regularizer: 可选的gamma正则# beta_constraint: 可选的beta约束# gamma_constraint: 可选的gamma约束 ​","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Keras","slug":"Keras","permalink":"http://example.com/tags/Keras/"}]},{"title":"Keras学习笔记II-函数式模型","slug":"Keras学习笔记II-函数式模型","date":"2017-08-31T10:48:30.000Z","updated":"2022-05-03T13:06:49.502Z","comments":true,"path":"2017/08/31/Keras学习笔记II-函数式模型/","link":"","permalink":"http://example.com/2017/08/31/Keras%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Keras函数式模型接口是用户定义多输出模型、非循环有向模型或具有共享层的模型等复杂模型的途径。这种模型的使用方式和函数式编程很像，下面看一个全连接网络的例子： 1234567891011121314from keras.layers import Input, Densefrom keras.models import Modelinputs = Input(shape=(784, ))x = Dense(64, activation=&#x27;relu&#x27;)(inputs)x = Dense(64, activation=&#x27;relu&#x27;)(x)predictions = Dense(10, activation=&#x27;softmax&#x27;)(x)model = Model(inputs=inputs, outputs=preditions)model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;categorical_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;])model.fit(data, labels) 所有的模型都是可调用的，像层一样 12x = Input(shape=(784, ))y = model(x) 例子 判断两条微博是否出自同一用户,会使用到共享层 123456789101112131415161718import kerasfrom keras.layers import Input, LSTM, Densefrom keras.models import Modeltweet_a = Input(shape=(140,256))tweet_b = Input(shape=(140, 256))shared_lstm = LSTM(64)encoded_a = shared_lstm(tweet_a)encoded_b = shared_lstm(tweet_b)merged_vector = keras.layers.concatenate([encoded_a, encoded_b], axis=1)prediction = Dense(1, activation=&#x27;sigmoid&#x27;)(merged_vector)model = Model(inputs=[tweet_a, tweet_b], outputs=prediction)model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;binary_crossentropy&#x27;, mertics=[&#x27;accuracy&#x27;])model.fit([data_a, data_b], labels, epochs=10) ​","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Keras","slug":"Keras","permalink":"http://example.com/tags/Keras/"}]},{"title":"Keras学习笔记I-Sequential","slug":"Keras学习笔记I-Sequential","date":"2017-08-26T12:05:16.000Z","updated":"2022-05-03T13:06:46.020Z","comments":true,"path":"2017/08/26/Keras学习笔记I-Sequential/","link":"","permalink":"http://example.com/2017/08/26/Keras%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0I-Sequential/","excerpt":"","text":"1. Keras简介Keras是集成的神经网络的框架，它的后端是基于Tensorflow、Theano和CNTK的。 Keras的架构 使用Keras的一般流程 2. 基本概念 符号计算 可以理解为计算图，计算图主要有两个元素组成：节点和边。节点通常来代表变量（scalar、vector、tensor等）；边代表的是操作，即一些函数。 张量（tensor） 直接看作向量即可。 模型 Keras有两种模型：Sequential和函数式模型（Model），Sequential是函数式模型的特殊形式。 Sequential：将多个网络层线性叠加，存入栈中的。单输入单输出，一条路通到底，层与层之间只是相邻关系，没有跨层连接。这么做的好处是：编译快，操作简单 函数式模型（Model）：多输入多输出，层与层之间任意连接，但编译慢。 batch 以batch大小的数据集为梯度计算的基本单位。 3. Sequential模型 构造网络层 利用layer的list来构造该模型： 123456from keras.models import Sequentialfrom keras.layers import Dense, Activationmodel = Sequential([Dense(32, units=784), Activation(&#x27;relu&#x27;), Dense(10), Activation(&#x27;softmax&#x27;),])# Sequential的第一层需要接受一个关于输入数据shape的参数，后面的各层则可以自动的推导出中间数据的shape。 利用.add()方法加入layer： 1234567model = Sequential()model.add(Dense(32, input_shape(784,)))model.add(Activation(&#x27;relu&#x27;))# input_shape是一个tuple类型的数据，传递给第一层# 有些2D层，支持通过指定其输入维度input_dim来隐含的指定输入数据shape；# 一些3D层，支持通过参数input_dim和input_length来指定输入shape；# 如果你需要为输入指定一个固定大小的batch_size（常用于stateful RNN网络），可以传递batch_size参数到一个层中，例如你想指定输入张量的batch大小是32，数据shape是（6，8），则你需要传递batch_size=32和input_shape=(6,8) 编译 我们需要通过compile来对学习过程进行配置，compile接收三个参数： 优化器optimizer 损失函数loss 指标列表metrics 123456789101112131415161718# 对于多分类问题model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;categorical_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;])# 对于二分类问题model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;binary_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;])# 对于回归问题model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;mse&#x27;)# 用户自定义metricsimport keras.backend as Kdef mean_pred(y_true, y_pred): return K.mean(y_pred)model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;binary_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;, mean_pred]) 训练 一般使用fit函数 12345678910111213141516# For a single-input model with 2 classes (binary classification):model = Sequential()model.add(Dense(32, activation=&#x27;relu&#x27;, input_dim=100))model.add(Dense(1, activation=&#x27;sigmoid&#x27;))model.compile(optimizer=&#x27;rmsprop&#x27;, loss=&#x27;binary_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;])# Generate dummy dataimport numpy as npdata = np.random.random((1000, 100))labels = np.random.randint(2, size=(1000, 1))# Train the model, iterating on the data in batches of 32 samplesmodel.fit(data, labels, epochs=10, batch_size=32) 例子 卷积神经网络 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import numpy as npimport kerasfrom keras.models import Sequentialfrom keras.layers import Dense, Dropout, Flattenfrom keras.layers import Conv2D, MaxPooling2Dfrom keras.optimizers import SGD# Generate dummy datax_train = np.random.random((100, 100, 100, 3))y_train = keras.utils.to_categorical(np.random.randint(10, size=(100, 1)), num_classes=10)x_test = np.random.random((20, 100, 100, 3))y_test = keras.utils.to_categorical(np.random.randint(10, size=(20, 1)), num_classes=10)model = Sequential()# input: 100x100 images with 3 channels -&gt; (100, 100, 3) tensors.# this applies 32 convolution filters of size 3x3 each.model.add(Conv2D(32, (3, 3), activation=&#x27;relu&#x27;, input_shape=(100, 100, 3)))# 参数# filters：卷积核的数目（即输出的维度）# kernel_size：单个整数或由两个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。# strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rata均不兼容# padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同，因为卷积核移动时在边缘会出现大小不够的情况。# activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）# use_bias:布尔值，是否使用偏置项# kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers# kernel_regularizer：施加在权重上的正则项，为Regularizer对象# bias_regularizer：施加在偏置向量上的正则项，为Regularizer对象# activity_regularizer：施加在输出上的正则项，为Regularizer对象# kernel_constraints：施加在权重上的约束项，为Constraints对象# bias_constraints：施加在偏置上的约束项，为Constraints对象model.add(Conv2D(32, (3, 3), activation=&#x27;relu&#x27;))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.25))model.add(Conv2D(64, (3, 3), activation=&#x27;relu&#x27;))model.add(Conv2D(64, (3, 3), activation=&#x27;relu&#x27;))model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.25))# Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。model.add(Flatten())model.add(Dense(256, activation=&#x27;relu&#x27;))model.add(Dropout(0.5))model.add(Dense(10, activation=&#x27;softmax&#x27;))sgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)# 参数：# lr：大于0的浮点数，学习率# momentum：大于0的浮点数，动量参数# decay：大于0的浮点数，每次更新后的学习率衰减值# nesterov：布尔值，确定是否使用Nesterov动量model.compile(loss=&#x27;categorical_crossentropy&#x27;, optimizer=sgd)model.fit(x_train, y_train, batch_size=32, epochs=10)score = model.evaluate(x_test, y_test, batch_size=32) ​","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Keras","slug":"Keras","permalink":"http://example.com/tags/Keras/"},{"name":"Sequential","slug":"Sequential","permalink":"http://example.com/tags/Sequential/"}]},{"title":"LeetCode-array类总结（会持续更新...）","slug":"LeetCode-array类总结","date":"2017-08-25T03:07:27.000Z","updated":"2022-05-03T13:06:57.455Z","comments":true,"path":"2017/08/25/LeetCode-array类总结/","link":"","permalink":"http://example.com/2017/08/25/LeetCode-array%E7%B1%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要是对leetcode中的array类算法的总结，包含了各题的solution和常用的解决方法。 相关源码：code 此类题的常用思路： 123456if 数组是否有序： try 双指针法 try 反向计算else： try 集合数据结构 try 打表法 119. Pascal’s Triangle IIDescription： Given an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. 我的解题思路是：有点动态规划的感觉，运用杨辉三角的特性：当前值 = 上层正对的值 + 上层正对前一个值。代码如下： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; result(rowIndex+1, 1); vector&lt;int&gt; temp(rowIndex+1, 1); for(int i = 0; i&lt;rowIndex; i++)&#123; for(int j = 1; j &lt;= i; j++)&#123; result[j] = temp[j] + temp[j-1]; &#125; for(int m=0; m&lt;=rowIndex; m++)&#123; temp[m] = result[m]; &#125; &#125; return result; &#125; &#125;; 下面有一个更好的解题思路：大致思路和我上面的差不多，只不过是反向计算的。这样做有个好处：减少空间分配。反向操作是array类解决方案中经常使用到的trick。代码如下： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; vi(rowIndex + 1); vi[0] = 1; for (int i = 0; i &lt;= rowIndex ; ++i) &#123; for (int j = i; j &gt; 0; --j) &#123; vi[j] = vi[j] + vi[j-1]; &#125; &#125; return vi; &#125;&#125;; 167. Two Sum II - Input array is sortedDescription: Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 解题思路:使用集合数据结构unordered_map&lt;int, int&gt;，一种map结构，find操作时间复杂度为O(1). 我们将数组中的元素逐个存入map，在存入的过程中检测是否有满足的元素；如果没有，就直接存入map.代码如下： 12345678910111213141516class Solution&#123; vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target)&#123; vector&lt;int&gt; result; unordered_map&lt;int, int&gt; hash; for(int i=0; i &lt; numbers.size(); i++)&#123; int temp = target - numbers[i]; if(hash.find(temp) != hash.end())&#123; result.push_back(hash.find(temp)+1); result.push_back(i+1); break; &#125; hash[numbers[i]] = i; &#125; return result; &#125;&#125;; 解题思路二：使用两个指针，一个从左出发，一个从有出发。因为本题使用的数组是有序的，所以这么做是有效的。用这两个指针去适配target。代码如下： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; result; int l = 0; int r = numbers.size()-1; while(l &lt; r)&#123; int sum = numbers[l]+numbers[r]; if(sum == target)&#123; result.push_back(l+1); result.push_back(r+1); break; &#125;else if(sum &gt; target)&#123; r--; &#125;else if(sum &lt; target)&#123; l++; &#125; &#125; return result; &#125;&#125;; 1. Two SumDescription: Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解题思路：和上一题一样，但本题的数组有可能是无序的，因此，我们使用集合数据结构unordered_map。代码如下： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; unordered_map&lt;int, int&gt; hash; for(int i = 0; i&lt;nums.size(); i++)&#123; int lag = target - nums[i]; if(hash.find(lag) != hash.end())&#123; result.push_back(hash[lag]); result.push_back(i); break; &#125; hash[nums[i]] = i; &#125; return result; &#125;&#125;; 219. Contains Duplicate IIDescription: Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 解题思路：本题要求数组相等的两个元素下标不超过k. 如果根据题意直接解，那么时间复杂度为O(n^2). 由于数组是无序的，我们倾向于使用集合数据结构。代码如下： 123456789101112131415161718192021class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.size() &lt; 2 || k &lt; 1)&#123; return false; &#125; unordered_map&lt;int, int&gt; hash; bool flag = false; for(int i=0; i&lt;nums.size(); i++)&#123; if(hash.find(nums[i]) != hash.end())&#123; if(i - hash[nums[i]] &lt;= k)&#123; flag = true; break; &#125; &#125; hash[nums[i]] = i; &#125; return flag; &#125;&#125;; 414. Third Maximum NumberDescription: Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: 12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 123456Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路：我们看到测试用例中有重复的元素，并且无序。我们考虑使用集合数据结构，加之要求输出的结果是有序的。我们最终使用有序的集合数据结构set.代码如下： 1234567891011121314class Solution &#123;public: int thirdMax(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; bag; for(int i=0; i&lt;nums.size(); i++)&#123; bag.insert(nums[i]); if(bag.size() &gt; 3)&#123; bag.erase(bag.begin()); &#125; &#125; return bag.size() == 3 ? *bag.begin() :*bag.rbegin(); &#125;&#125;; 448. Find All Numbers Disappeared in an ArrayDescription: Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 解题思路：根据题意直接解的话，时间复杂度会为O(n^2)。我们就用空间换时间，代码如下： 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; result; vector&lt;int&gt; extra(nums.size(), 0); for(int i = 0 ; i&lt;nums.size(); i++)&#123; extra[nums[i]-1]++; &#125; for(int i = 0; i&lt;nums.size(); i++)&#123; if(extra[i]==0)&#123; result.push_back(i+1); &#125; &#125; return result; &#125;&#125;; 561. Array Partition IDiscription: Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 12345Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 解题思路：总结规律，发现已排序数组的奇数项的和就是答案，这个可以通过反证法进行证明。代码如下： 123456789101112class Solution &#123;public: int arrayPairSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int sum = 0; for(int i =0; i&lt;nums.size();i+=2)&#123; sum += nums[i]; &#125; return sum; &#125;&#125;; 解题思路二：上面这种解法时间复杂度是O(nlogn)，下面有种O(n)的解法。根据题目提示，给出了数据范围，并且数据无序，我们可以使用集合数据结构，只不过这次使用自己构造的数据结构打表法。代码如下： 1234567891011121314151617181920212223class Solution &#123;public: int arrayPairSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; hashtable(20001,0); for(size_t i=0;i&lt;nums.size();i++) &#123; hashtable[nums[i]+10000]++; &#125; int ret=0; int flag=0; for(size_t i=0;i&lt;20001;)&#123; if((hashtable[i]&gt;0)&amp;&amp;(flag==0))&#123; ret=ret+i-10000; flag=1; hashtable[i]--; &#125;else if((hashtable[i]&gt;0)&amp;&amp;(flag==1))&#123; hashtable[i]--; flag=0; &#125;else i++; &#125; return ret; &#125;&#125;; 581. Shortest Unsorted Continuous SubarrayDescription: Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: 1234Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 解题思路：本题数组部分有序，我们使用双指针，这有个小trick：左右两个指针同时前进，不像之前根据某个状态，单独调节单个指针。代码如下： 123456789101112131415161718class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); int beg = -1; int end = -2; int max = nums[0]; int min = nums[length-1]; for(int i=1; i&lt;length; i++)&#123; max = max&lt;nums[i]?nums[i]:max; min = min&gt;nums[length-i-1]?nums[length-i-1]:min; if(max&gt;nums[i]) end=i; if(min&lt;nums[length-i-1]) beg=length-i-1; &#125; return end-beg+1; &#125;&#125;; 66. Plus OneDescription: Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 解题思路：总结规律，代码如下： 12345678910111213141516class Solution&#123; vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits)&#123; int n = digits.size(); for(int i = n-1; i&gt;=0; i--)&#123; if(digits[i] == 9)&#123; digits[i] = 0; &#125;else&#123; digits[i]++; return; &#125; &#125; digits[0] = 1; digits.push_back(0); return digits; &#125; &#125;; 88. Merge Sorted ArrayDescription: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解题思路：本题是两个有序的数组，我们要利用这一点，并且有个trick：反向计算。代码如下： 123456789101112131415161718class Solution&#123; public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n)&#123; int i = m-1; int j = n-1; int k = m+n-1; while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i] &gt; nums2[j])&#123; nums1[k--] = nums1[i--]; &#125;else&#123; nums1[k--] = nums2[j--]; &#125; &#125; while(j&gt;=0)&#123; nums1[k--] = nums2[j--]; &#125; &#125;&#125; 118. Pascal’s TriangleDescription: Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路：本题考察杨辉三角的性质，我们直接利用性质进行解题。代码如下： 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result(numRows); for(int i=0; i &lt; numRows; i++)&#123; result[i].resize(i+1); for(int j=0; j&lt;=i; j++)&#123; if(j==i || j==0)&#123; result[i][j] = 1; &#125;else&#123; result[i][j] = result[i-1][j] + result[i-1][j-1]; &#125; &#125; &#125; return result; &#125;&#125;; 121. Best Time to Buy and Sell StockDescription: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: 12345Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: 1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 解题思路：观察本题规律，局部有序，关键点是判断极小值点。代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size() &lt; 2)&#123; return 0; &#125; int result = 0; int min = 0; for(int i=0; i&lt; prices.size()-1; i++)&#123; if(prices[i+1] &gt; prices[i])&#123; if(prices[i+1]-prices[min] &gt; result)&#123; result = prices[i+1]-prices[min]; &#125; &#125;else&#123; if(prices[i+1] &lt; prices[min])&#123; min = i+1; &#125; &#125; &#125; return result; &#125;&#125;; 112. Best Time to Buy and Sell Stock IIDescription: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 12345Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: 123456Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 代码如下： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size() &lt; 2) return 0; int result = 0; for(int i=0; i&lt;prices.size()-1; i++)&#123; if(prices[i+1] &gt; prices[i])&#123; result += prices[i+1]-prices[i]; &#125; &#125; return result; &#125;&#125;; 123. Best Time to Buy and Sell Stock IIIDescription: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. **Note: **You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: 123456Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 解题思路：经典题，代码如下： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int hold2=INT_MIN, hold1=INT_MIN; int release2=0, release1=0; for(int n : prices)&#123; release2=max(release2, hold2+n); hold2=max(hold2, release1-n); release1=max(release1, hold1+n); hold1=max(hold1,-n); &#125; return release2; &#125;&#125;; 605. Can Place FlowersDescription: Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die. Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule. Example 1: 123Input: flowerbed = [1,0,0,0,1], n = 1Output: True Example 2: 123Input: flowerbed = [1,0,0,0,1], n = 2Output: False Note: The input array won’t violate no-adjacent-flowers rule. The input array size is in the range of [1, 20000]. n is a non-negative integer which won’t exceed the input array size. 解题思路：根据本题题意直接作答，代码如下： 1234567891011121314151617class Solution &#123;public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; int count = 0; for(int i=0; i&lt;flowerbed.size(); i++)&#123; if(flowerbed[i] == 0)&#123; int next = (i==flowerbed.size()-1) ? 0 : flowerbed[i+1]; int pre = (i==0) ? 0 : flowerbed[i-1]; if(next == 0 &amp;&amp; pre == 0)&#123; flowerbed[i] = 1; count++; &#125; &#125; &#125; return count&gt;=n; &#125;&#125;; 189. Rotate ArrayDescription:Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 代码如下： 1234567891011class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); for(int i=0; i&lt;k;i++)&#123; int temp = nums[n-1]; nums.pop_back(); nums.insert(nums.begin(), temp); &#125; &#125;&#125;; 35. Search Insert PositionDescription: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 代码如下： 12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; if(i==0 &amp;&amp; nums[0] &gt; target)&#123; return 0; &#125; if(nums[i] - target == 0)&#123; return i; &#125; if(nums[i] &gt; target)&#123; return i; &#125; &#125; return nums.size(); &#125;&#125;; 53. Maximum SubarrayDescription:Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解题思路：本题很经典，使用动态规划，代码如下： 1234567891011121314151617181920212223242526class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0)&#123; return 0; &#125; if(nums.size() == 1)&#123; return nums[0]; &#125; int sum = 0; int max = nums[0]; for(int i=0; i&lt;nums.size(); i++)&#123; //sum += nums[i]; if(sum &lt;= 0)&#123; sum = nums[i]; &#125;else&#123; sum+= nums[i]; &#125; max = max &gt; sum ? max:sum; &#125; return max; &#125;&#125;; 665. Non-decreasing ArrayDescription: Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). Example 1: 1234Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: 1234Input: [4,2,1]Output: FalseExplanation: You can&#x27;t get a non-decreasing array by modify at most one element. Note: The n belongs to [1, 10,000]. 代码如下： 123456789101112131415161718class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int count = 0; for(int i=1; i&lt;nums.size() &amp;&amp; count&lt;=1; i++)&#123; if(nums[i-1] &gt; nums[i])&#123; count++; if(i-2&lt;0 || nums[i-2] &lt; nums[i])&#123; nums[i - 1] = nums[i]; &#125;else&#123; nums[i] = nums[i-1]; &#125; &#125; &#125; return count&lt;=1; &#125;&#125;; 532. K-diff Pairs in an ArrayDescription: Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: 12345Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: 1234Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: 1234Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Note: The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. 解题思路：本题有很强技巧性，使用了两个集合数据结构：map和set，代码如下： 123456789101112131415161718192021class Solution &#123;public: int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123; if(k &lt; 0)&#123; return 0; &#125; unordered_map&lt;int, int&gt; slot; unordered_set&lt;int&gt; result; for(int i=0; i&lt;nums.size(); i++)&#123; if(slot.count(nums[i] - k))&#123; result.insert(nums[i]-k); &#125; if(slot.count(nums[i] + k))&#123; result.insert(nums[i]); &#125; slot[nums[i]] +=1; &#125; return result.size(); &#125;&#125;; 643. Maximum Average Subarray IDescription:Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1: 1234Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note: 1 &lt;= k &lt;= n &lt;= 30,000. Elements of the given array will be in the range [-10,000, 10,000]. 代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0; int max = 0; for(int i=0; i&lt;nums.size(); i++)&#123; if(i&lt;k)&#123; sum += nums[i]; max = sum; &#125;else&#123; sum = sum+nums[i]-nums[i-k]; max = max &gt; sum ? max : sum; &#125; &#125; return max/(float)k; &#125; double findMaxAverage2(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0; for (int i = 0; i &lt; k; i++) sum += nums[i]; int max = sum; for (int i = k; i &lt; nums.size(); i++) &#123; sum += nums[i] - nums[i - k]; max = max &gt; sum ? max : sum; &#125; return max / 1.0 / k; &#125;&#125;; 628. Maximum Product of Three NumbersDescription: Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: 123Input: [1,2,3]Output: 6 Example 2: 123Input: [1,2,3,4]Output: 24 Note: The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer. 代码如下： 123456789101112class Solution &#123;public: int maximumProduct(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int len = nums.size(); int temp1 = nums[len-1]*nums[0]*nums[1]; int temp2 = nums[len-1]*nums[len-2]*nums[len-3]; return temp1&gt;temp2?temp1:temp2; &#125;&#125;; 566. Reshape the MatrixDescription: In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: 12345678910Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2: 1234567891011Input: nums = [[1,2], [3,4]]r = 2, c = 4Output: [[1,2], [3,4]]Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix. Note: The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123; int row = nums.size(); int col = nums[0].size(); if(row*col != r*c)&#123; return nums; &#125; vector&lt;vector&lt;int&gt;&gt; result(r); for(int i=0; i&lt;r;i++)&#123; result[i].resize(c); &#125; for(int i=0; i&lt;row*col; i++)&#123; result[i/c][i%c] = nums[i/col][i%col]; &#125; //delete result; return result; &#125;&#125;; 645. Set MismatchDescription:The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array. Example 1: 123Input: nums = [1,2,2,4]Output: [2,3] Note: The given array size will in the range [2, 10000]. The given array’s numbers won’t have any order. 解题思路：代码如下： 1234567891011121314class Solution &#123;public: vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) &#123; int[] res = new int[2]; for (int i : nums) &#123; if (nums[Math.abs(i) - 1] &lt; 0) res[0] = Math.abs(i); else nums[Math.abs(i) - 1] *= -1; &#125; for (int i=0;i&lt;nums.length;i++) &#123; if (nums[i] &gt; 0) res[1] = i+1; &#125; return res; &#125;&#125;; 106. Construct Binary Tree from Inorder and Postorder TraversalDescription: Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 123456 3 / \\9 20 / \\ 15 7 代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; //if(inorder.size()！=postorder.size()) return NULL; return treeHelper(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1); &#125; TreeNode* treeHelper(vector&lt;int&gt; &amp;in, int startIn, int endIn, vector&lt;int&gt; &amp;post, int startPost, int endPost)&#123; if(startIn&gt;endIn ||startPost&gt;endPost) return NULL; if(startIn==endIn &amp;&amp; startPost== endPost) return new TreeNode(in[startIn]); TreeNode* root = new TreeNode(post[endPost]); for(int i=startIn;i&lt;=endIn; i++)&#123; if(post[endPost]==in[i])&#123; root-&gt;left=treeHelper(in,startIn,i-1,post,startPost,startPost+i-startIn-1); root-&gt;right=treeHelper(in,i+1,endIn,post,startPost+i-startIn,endPost-1); &#125; &#125; return root; &#125;&#125;; 108. Convert Sorted Array to Binary Search TreeDescription: Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 解题思路：二叉搜索树与有序数组，直观的想法就是中序遍历，代码如下： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for a binary tree node.*/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return NULL; if(nums.size()==1) return new TreeNode(nums[0]); int mid = nums.size()/2; TreeNode* root = new TreeNode(nums[mid]); vector&lt;int&gt; l(nums.begin(), nums.begin()+mid); vector&lt;int&gt; r(nums.begin()+mid+1,nums.end()); root-&gt;left = sortedArrayToBST(l); root-&gt;right= sortedArrayToBST(r); return root; &#125;&#125;; 11. Container With Most WaterDescription: Given n non-negative integers a1, a2, …, *an *, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. **Note: **You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 解题思路：双指针法，代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int len = height.size(); if(len&lt;2) return 0; int lo=0, hi=len-1, container=0; while(lo&lt;hi)&#123; if(height[lo]&lt;height[hi])&#123; if(height[lo]*(hi-lo)&gt;container)&#123; container=height[lo]*(hi-lo); &#125; lo++; &#125; else&#123; if(height[hi]*(hi-lo)&gt;container)&#123; container=height[hi]*(hi-lo); &#125; hi--; &#125; &#125; return container; &#125;&#125;; 128. Longest Consecutive SequenceDescription: Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: 123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 解题思路：使用集合数据结构，代码如下： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res=0; unordered_map&lt;int, int&gt; hash; for(int n : nums)&#123; if(hash.find(n)==hash.end())&#123; int left = hash.find(n-1)!=hash.end()?hash[n-1]:0; int right = hash.find(n+1)!=hash.end()?hash[n+1]:0; int sum=left+right+1; res=max(res,sum); hash[n]=sum; hash[n-left]=sum; hash[n+right]=sum; &#125; else continue; &#125; return res; &#125;&#125;; 15. 3SumDescription: Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 代码如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; res; if(nums.size()==0) return res; for(int i=0; i&lt;nums.size()-1; i++)&#123; if(i==0 || (i&gt;0 &amp;&amp; nums[i]!=nums[i-1]))&#123; int lo=i+1, hi=nums.size()-1, sum=0-nums[i]; while(lo&lt;hi)&#123; if(nums[lo]+nums[hi]==sum)&#123; vector&lt;int&gt; tmp; tmp.push_back(nums[lo]); tmp.push_back(nums[i]); tmp.push_back(nums[hi]); res.push_back(tmp); while(lo&lt;hi &amp;&amp; nums[lo]==nums[lo+1]) lo++; while(lo&lt;hi &amp;&amp; nums[hi]==nums[hi-1]) hi--; lo++; hi--; &#125;else if(nums[lo]+nums[hi]&lt;sum) lo++; else hi--; &#125; //res.push_back(tmp); &#125; &#125; return res; &#125;&#125;; 154. Find Minimum in Rotated Sorted Array IIDescription: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12Input: [1,3,5]Output: 1 Example 2: 12Input: [2,2,2,0,1]Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? 经典题，代码如下： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int lo=0, hi=nums.size()-1; while(lo&lt;hi)&#123; int mid = (lo+hi)/2; if(nums[mid]&gt;nums[hi]) lo=mid+1; else if(nums[mid]&lt;nums[hi]) hi=mid; else hi--; &#125; return nums[lo]; &#125;&#125;; 16. 3Sum ClosetDescription: Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); int gap=INT_MAX; int res = 0; if(len==0) return 0; sort(nums.begin(),nums.end()); for(int i=0; i&lt;len-2; i++)&#123; if(i==0 || (i&gt;0 &amp;&amp; nums[i]!=nums[i-1]))&#123; int lo=i+1, hi=len-1, sum=target-nums[i]; while(lo&lt;hi)&#123; if(nums[lo]+nums[hi]==sum) return target; else if(nums[lo]+nums[hi]&lt;sum)&#123; if(abs(nums[lo]+nums[hi]-sum)&lt;gap)&#123; gap=abs(nums[lo]+nums[hi]-sum); res=target-gap; &#125; lo++; &#125;else&#123; if(abs(nums[lo]+nums[hi]-sum)&lt;gap)&#123; gap=abs(nums[lo]+nums[hi]-sum); res=target+gap; &#125; hi--; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; if(len&lt;4) return res; sort(nums.begin(),nums.end()); for(int i=0; i&lt;len-3; i++)&#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; for(int j=i+1; j&lt;len-2;j++)&#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; int sum=target-nums[i]-nums[j]; int m=j+1,n=len-1; while(m&lt;n)&#123; if(sum==nums[m]+nums[n])&#123; res.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[m],nums[n]&#125;); do&#123;m++;&#125;while(nums[m]==nums[m-1]&amp;&amp;m&lt;n); do&#123;n--;&#125;while(nums[n]==nums[n+1]&amp;&amp;m&lt;n); &#125;else if(sum&gt;nums[m]+nums[n]) m++; else n--; &#125; &#125; &#125; return res; &#125;&#125;; 228. Summary RangesDescription: Given a sorted integer array without duplicates, return the summary of its ranges. Example 1: 1234Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range. Example 2: 123Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range. 代码如下： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Solution &#123;public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;string&gt; res; if(len==0) return res; for(int i=0;i&lt;len;i++)&#123; int tmp = nums[i]; while(i+1&lt;len &amp;&amp; nums[i]+1==nums[i+1]) i++; if(tmp!=nums[i]) res.push_back(to_string(tmp)+&quot;-&gt;&quot;+to_string(nums[i])); else res.push_back(to_string(tmp)); &#125; return res; &#125;&#125;; 229. Majority Element IIDescription: Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. **Note: **The algorithm should run in linear time and in O(1) space. Example 1: 12Input: [3,2,3]Output: [3] Example 2: 12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 代码如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if(nums.size()==0) return res; int num1=nums[0], num2=nums[0], count1=1, count2=0; for(int n :nums)&#123; if(n==num1) count1++; else if(n==num2) count2++; else if(count1==0)&#123; num1=n; count1++; &#125;else if(count2==0)&#123; num2=n; count2++; &#125;else&#123; count1--; count2--; &#125; &#125; count1=0; count2=0; for(int n: nums)&#123; if(n==num1) count1++; else if(n==num2) count2++; &#125; if(count1&gt;nums.size()/3) res.push_back(num1); if(count2&gt;nums.size()/3) res.push_back(num2); return res; &#125;&#125;; 238. Product of Array Except SelfDescription: Given an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 123Input: [1,2,3,4]Output: [24,12,8,6] **Note: **Please solve it without division and in O(n). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) 经典题，代码如下： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len); res[0]=1; for(int i=1; i&lt;len; i++)&#123; res[i]=res[i-1]*nums[i-1]; &#125; int right = 1; for(int i=len-1; i&gt;=0;i--)&#123; res[i]*=right; right*=nums[i]; &#125; return res; &#125;&#125;; 此题有个trick，代码如下： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int m=board.size(), n=m?board[0].size():0; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; int count = 0; for(int I=max(i-1,0); I&lt;min(i+2,m); I++)&#123; for(int J=max(j-1,0); J&lt;min(j+2,n); J++)&#123; count+=board[I][J]&amp;1; &#125; &#125; if(count==3 || count-board[i][j]==3)&#123; board[i][j] |= 2; &#125; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; board[i][j]&gt;&gt;=1; &#125; &#125; &#125;&#125;; 31. Next PermutationDescription: Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 代码如下： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;2) return; int index=n-1; while(index)&#123; if(nums[index]&gt;nums[index-1]) break; index--; &#125; if(index==0) reverseSort(nums, 0, n-1); else&#123; int val = nums[index-1]; int j=n-1; while(j&gt;=index)&#123; if(nums[j]&gt;val) break; j--; &#125; swap(nums[index-1], nums[j]); reverseSort(nums, index, n-1); &#125; &#125; void reverseSort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start&gt;end) return; for(int i=start; i&lt;=(start+end)/2; i++) swap(nums[i],nums[start-i+end]); &#125;&#125;; 41. First Missing PositiveDescription: Given an unsorted integer array, find the smallest missing positive integer. Example 1: 123Input: [1,2,0]Output: 3 Example 2: 123Input: [3,4,-1,1]Output: 2 Example 3: 123Input: [7,8,9,11,12]Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 代码如下： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; while(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.size() &amp;&amp; nums[nums[i]-1]!=nums[i])&#123; swap(nums[i],nums[nums[i]-1]); &#125; &#125; for(int i=0;i&lt;nums.size(); i++)&#123; if(nums[i]!=i+1) return i+1; &#125; return nums.size()+1; &#125;&#125;; 42. Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: 12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 代码如下： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int l=0, r=height.size()-1; int lower=0, level=0; int water=0; while(l&lt;r)&#123; lower = height[height[l]&lt;height[r]?l++:r--]; level=max(level,lower); water+=level-lower; &#125; return water; &#125;&#125;; 45. Jump Game IIDescription: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: 1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. 代码如下： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len&lt;2) return 0; int curMax=0,nextMax=0,i=0, level=0; while(curMax-i+1&gt;0)&#123; level++; for(;i&lt;=curMax;i++)&#123; nextMax=max(nextMax,nums[i]+i); if(nextMax&gt;=len-1) return level; &#125; curMax=nextMax; &#125; return 0; &#125;&#125;; 48. Rotate ImageDescription: You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: 1234567891011121314Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2: 12345678910111213141516Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 代码如下： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; reverse(matrix.begin(),matrix.end()); for(int i=0; i&lt;matrix.size();i++)&#123; for(int j=i+1;j&lt;matrix[i].size();j++)&#123; swap(matrix[i][j],matrix[j][i]); &#125; &#125; &#125;&#125;; 54. Spiral MatrixDescription: Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: 12345678Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5] Example 2: 1234567Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] 代码如下： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int rows = matrix.size(); int cols = matrix[0].size(); int cicles = ((rows&lt;cols?rows:cols)-1)/2+1; vector&lt;int&gt; res; res.clear(); //if(rows==0) return res; for(int i=0; i&lt;cicles; i++)&#123; for(int j=i;j&lt;cols-i;j++) res.push_back(matrix[i][j]); for(int k=i+1;k&lt;rows-i;k++) res.push_back(matrix[k][cols-i-1]); for(int m=cols-i-2; m&gt;=i&amp;&amp;rows-i-1!=i;m--) res.push_back(matrix[rows-i-1][m]); for(int n=rows-i-2; n&gt;i&amp;&amp;cols-i-1!=i;n--) res.push_back(matrix[n][i]); &#125; return res; &#125;&#125;; 55. Jump GameDescription: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 1234Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int curMax=0, nextMax=0, i=0; while(curMax-i+1&gt;0)&#123; for(;i&lt;=curMax;i++)&#123; nextMax=max(nextMax,i+nums[i]); if(nextMax&gt;=len-1) return true; &#125; curMax=nextMax; &#125; return false; &#125;&#125;; 56. Merge IntervalsDescription: Given a collection of intervals, merge all overlapping intervals. Example 1: 1234Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for an interval.*/struct Interval &#123; int start; int end; Interval() : start(0), end(0) &#123;&#125; Interval(int s, int e) : start(s), end(e) &#123;&#125;&#125;; class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; if(intervals.empty()) return res; sort(intervals.begin(),intervals.end(), [](Interval a, Interval b)&#123;return a.start&lt;b.start;&#125;); res.push_back(intervals[0]); for(int i=1; i&lt;intervals.size();i++)&#123; if(res.back().end&lt;intervals[i].start) res.push_back(intervals[i]); else res.back().end=max(res.back().end, intervals[i].end); &#125; return res; &#125;&#125;; 57. Insert IntervalDescripition: Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: 123Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]] Example 2: 123Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;/** * Definition for an interval.*/struct Interval &#123; int start; int end; Interval() : start(0), end(0) &#123;&#125; Interval(int s, int e) : start(s), end(e) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; auto it = intervals.begin(); for(;it!=intervals.end();it++)&#123; if(newInterval.end&lt;(*it).start) break; else if(newInterval.start&gt;(*it).end) res.push_back(*it); else&#123; newInterval.start=min(newInterval.start,(*it).start); newInterval.end=max(newInterval.end, (*it).end); &#125; &#125; res.push_back(newInterval); for(;it!=intervals.end();++it)&#123; res.push_back(*it); &#125; return res; &#125;&#125;; 59. Spiral Matrix IIDescription: Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: 1234567Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 代码如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n)); if(n==1)&#123; res[0][0]=1; return res; &#125; int data=1; int circle = (n-1)/2+1; for(int i=0; i&lt;circle;i++)&#123; for(int j=i;j&lt;n-i;j++) res[i][j]=data++; for(int k=i+1;k&lt;n-i;k++) res[k][n-i-1]=data++; for(int m=n-i-2;m&gt;=i&amp;&amp;(n-i-1!=i);m--) res[n-i-1][m]=data++; for(int p=n-i-2;p&gt;i&amp;&amp;(n-i-1!=i);p--) res[p][i]=data++; &#125; return res; &#125;&#125;; 73. Set Matrix ZerosDescription: Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: 12345678910111213Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]] Example 2: 12345678910111213Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] Follow up: A straight forward solution using O(m**n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int rows = matrix.size(); int cols = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; tags; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(matrix[i][j]==0) tags.push_back(vector&lt;int&gt;&#123;i,j&#125;); &#125; &#125; for(int k=0;k&lt;tags.size();k++)&#123; int i=tags[k][0]; int j=tags[k][1]; for(int m=0;m&lt;cols;m++) matrix[i][m]=0; for(int m=0;m&lt;rows;m++) matrix[m][j]=0; &#125; &#125; void setZeroes2(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int col0 = 1, rows = matrix.size(), cols = matrix[0].size(); for (int i = 0; i &lt; rows; i++) &#123; if (matrix[i][0] == 0) col0 = 0; for (int j = 1; j &lt; cols; j++) if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; for (int i = rows - 1; i &gt;= 0; i--) &#123; for (int j = cols - 1; j &gt;= 1; j--) if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; if (col0 == 0) matrix[i][0] = 0; &#125; &#125;&#125;; 75. Sort ColorsDescription: Given an array with n objects colored red, white or blue, sort them **in-place **so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? 代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; hash; for(int n : nums)&#123; hash[n]++; &#125; int index=0; for(int i=0; i&lt;3; i++)&#123; while(hash[i]--)&#123; nums[index++]=i; &#125; &#125; &#125; void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; 84. Largest Rectangle in HistogramDescription: Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 12Input: [2,1,5,6,2,3]Output: 10 代码如下： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res=0; vector&lt;int&gt; index; heights.push_back(0); for(int i=0; i&lt;heights.size();i++)&#123; while(index.size()&gt;0 &amp;&amp; heights[index.back()]&gt;=heights[i])&#123; int h = heights[index.back()]; index.pop_back(); int idx = index.size()&gt;0?index.back():-1; if(res&lt;h*(i-idx-1)) res=h*(i-idx-1); &#125; index.push_back(i); &#125; return res; &#125;&#125;; 85. Maximal RectangleDescription: Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 12345678Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6 代码如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty()) return 0; const int m = matrix.size(); const int n = matrix[0].size(); int left[n], right[n], height[n]; fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0); int maxA = 0; for(int i=0; i&lt;m; i++) &#123; int cur_left=0, cur_right=n; for(int j=0; j&lt;n; j++) &#123; // compute height (can do this from either side) if(matrix[i][j]==&#x27;1&#x27;) height[j]++; else height[j]=0; &#125; for(int j=0; j&lt;n; j++) &#123; // compute left (from left to right) if(matrix[i][j]==&#x27;1&#x27;) left[j]=max(left[j],cur_left); else &#123;left[j]=0; cur_left=j+1;&#125; &#125; // compute right (from right to left) for(int j=n-1; j&gt;=0; j--) &#123; if(matrix[i][j]==&#x27;1&#x27;) right[j]=min(right[j],cur_right); else &#123;right[j]=n; cur_right=j;&#125; &#125; // compute the area of rectangle (can do this from either side) for(int j=0; j&lt;n; j++) maxA = max(maxA,(right[j]-left[j])*height[j]); &#125; return maxA; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"array","slug":"array","permalink":"http://example.com/tags/array/"}]},{"title":"阿里天池CIKM2017 Rank4比赛经验分享","slug":"CIKM2017比赛经验分享","date":"2017-08-20T13:43:51.000Z","updated":"2022-05-03T12:54:59.483Z","comments":true,"path":"2017/08/20/CIKM2017比赛经验分享/","link":"","permalink":"http://example.com/2017/08/20/CIKM2017%E6%AF%94%E8%B5%9B%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/","excerpt":"","text":"CIKM_AnalytiCup_2017: Combining the Traditional Methods and Deep Learning Approach for Precipitation NowcastingThis repo discribes the solution of Team 怀北村明远湖. CIKM AnalytiCup 2017 is an open competition that is sponsored by Shenzhen Meteorological Bureau, Alibaba Group and CIKM2017. Our team got the third place in the first phrase. And in the second phrase we got the fourth place. Team 怀北村明远湖：Zhang Rui, Qiao Fengchun, Guo Ran code IntroductionShort-term precipitation forecasting such as rainfall prediction is a task to predict a short-term rainfall amount based on current observations. In this challenge, sponsors provide a set of radar maps at different time spans where each radar map covers radar reflectivity of a target site and its surrounding areas. Radar maps are measured at different time spans, i.e., 15 time spans with an interval of 6 minutes, and different heights, i.e., 4 heights, from 0.5km to 3.5km with an interval of 1km; Each radar map covers an area of 101km*101km around the site. The area is marked as 101*101 grids, and the target site is located at the centre, i.e. (50, 50). Our task here is to predict the total rainfall amount on the ground between future 1-hour and 2-hour for each target site.In this challenge, we combine Random Forestry, XGBoost and Bidirectional Gated Recurrent Units (GRUs) into an ensemble model to tackle this problem and achieve satisfying result. Data ProcessPercentile MethodA statistical method was applied to reduce the dimension of radar data. For a single radar map, we pick the 25th, 50th, 75th, 100th percentile of reflectivity values in various scales of neighborhood around the target site from center to the whole map. “Wind” MethondWe first handle the original data (15*4*101*101) into a small size of data (15*4*10*10). Then shrink the data into 15*4*6*6 features through judging the wind direction. The entire preprocess learns from the idea of CNN, especially the convolutional calculation and max polling. We take the fourth layer of data to determine the wind direction. Then, in order to calculating the resulting wind direction, we carry out two ways of choosing representative data. The first one uses the maximum value in each 10*10 frame as the representation. The second one takes the average of the largest five data instead. After selecting the representative data, we determine the wind direction by calculating the deviation between the initial position and the following frames, voting the moving direction, finally get the maximum votes as the resulting wind direction based on the given thresholds. ModelRandom Forestry, XGBoost and Bidirectional GRUs are utilized for model ensemble. Requirements Python 3.6 Keras XGBoost sklearn Dataset Data Source","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"深度学习/机器学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"阿里天池大赛","slug":"阿里天池大赛","permalink":"http://example.com/tags/%E9%98%BF%E9%87%8C%E5%A4%A9%E6%B1%A0%E5%A4%A7%E8%B5%9B/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"数学知识","slug":"数学知识","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"机器学习","slug":"深度学习/机器学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"DenseNet","slug":"DenseNet","permalink":"http://example.com/tags/DenseNet/"},{"name":"ResNet","slug":"ResNet","permalink":"http://example.com/tags/ResNet/"},{"name":"LSTM","slug":"LSTM","permalink":"http://example.com/tags/LSTM/"},{"name":"GRU","slug":"GRU","permalink":"http://example.com/tags/GRU/"},{"name":"AlexNet","slug":"AlexNet","permalink":"http://example.com/tags/AlexNet/"},{"name":"VGG","slug":"VGG","permalink":"http://example.com/tags/VGG/"},{"name":"GoogleNet","slug":"GoogleNet","permalink":"http://example.com/tags/GoogleNet/"},{"name":"VGGNet","slug":"VGGNet","permalink":"http://example.com/tags/VGGNet/"},{"name":"虚函数","slug":"虚函数","permalink":"http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"XGBoost","slug":"XGBoost","permalink":"http://example.com/tags/XGBoost/"},{"name":"GBDT","slug":"GBDT","permalink":"http://example.com/tags/GBDT/"},{"name":"信息论","slug":"信息论","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"},{"name":"AE","slug":"AE","permalink":"http://example.com/tags/AE/"},{"name":"RNN","slug":"RNN","permalink":"http://example.com/tags/RNN/"},{"name":"tips","slug":"tips","permalink":"http://example.com/tags/tips/"},{"name":"CNN","slug":"CNN","permalink":"http://example.com/tags/CNN/"},{"name":"优化","slug":"优化","permalink":"http://example.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"正则化","slug":"正则化","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"},{"name":"Keras","slug":"Keras","permalink":"http://example.com/tags/Keras/"},{"name":"Sequential","slug":"Sequential","permalink":"http://example.com/tags/Sequential/"},{"name":"array","slug":"array","permalink":"http://example.com/tags/array/"},{"name":"阿里天池大赛","slug":"阿里天池大赛","permalink":"http://example.com/tags/%E9%98%BF%E9%87%8C%E5%A4%A9%E6%B1%A0%E5%A4%A7%E8%B5%9B/"}]}