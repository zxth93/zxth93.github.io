<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-03T13:06:12.270Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zxth93</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/05/03/hello-world/"/>
    <id>http://example.com/2022/05/03/hello-world/</id>
    <published>2022-05-03T13:06:12.269Z</published>
    <updated>2022-05-03T13:06:12.270Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode-backtrack类总结</title>
    <link href="http://example.com/2018/03/30/LeetCode-backtrack%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2018/03/30/LeetCode-backtrack%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2018-03-30T13:02:21.000Z</published>
    <updated>2022-05-03T13:07:06.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的backtracking类算法的总结，包含了各题的solution和常用解法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><blockquote><p>回溯法直观的理解：受限的分治算法</p></blockquote><h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><p>Description:</p><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,<br>If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>solution：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(res, temp,nums,i+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><p>Description:</p><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,<br>If <strong>nums</strong> = <code>[1,2,2]</code>, a solution is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">subsets</span>(res,tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subsets</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">subsets</span>(res,temp,nums,i+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Description:</p><p>Given a collection of <strong>distinct</strong> numbers, return all possible permutations.</p><p>For example,<br><code>[1,2,3]</code> have the following permutations:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, tmp, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; temp, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">contain</span>(temp, nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtrack</span>(res,temp,nums);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p>Description:</p><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p>For example,<br><code>[1,1,2]</code> have the following unique permutations:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, tmp, nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">bool</span>&gt; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i]|| i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; !used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtrack</span>(res,temp,nums, used);</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><p>Description:</p><p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2, 2, 3]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, tmp, candidates,target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> remain, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain==<span class="number">0</span>) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                <span class="built_in">backtrack</span>(res, temp, candidates, remain-candidates[i], i);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h2><p>Description:</p><p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, tmp, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> remain, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain==<span class="number">0</span>) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtrack</span>(res, temp, nums, remain-nums[i], i+<span class="number">1</span>);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的backtracking类算法的总结，包含了各题的solution和常用解法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-dp类总结</title>
    <link href="http://example.com/2017/12/29/LeetCode-dp%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/12/29/LeetCode-dp%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2017-12-29T06:34:07.000Z</published>
    <updated>2022-05-03T13:07:25.297Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的dp类算法的总结，包含了各题的solution和常用的解决方法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h2><p>Description:</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><p>解题思路：此题是动态规划中的经典问题，此题有个限制相邻两个房间不能同时被盗，那么最优子结构就是cur=max(pre+nums[i], cur)，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> pre=cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">max</span>(pre+nums[i], cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h2><p>Description:</p><p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p><p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3, 4, 2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">Delete 4 to earn 4 points, consequently 3 is also deleted.</span><br><span class="line">Then, delete 2 to earn 2 points. 6 total points are earned.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2, 2, 3, 3, 3, 4]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: </span><br><span class="line">Delete 3 to earn 3 points, deleting both 2&#x27;s and the 4.</span><br><span class="line">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class="line">9 total points are earned.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The length of <code>nums</code> is at most <code>20000</code>.</p><p>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</p><p>解题思路：此题本质上是house robber问题，参考上题，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">10001</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n :nums)</span><br><span class="line">            hash[n]+=n;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>, cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10001</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=cur;</span><br><span class="line">            cur=<span class="built_in">max</span>(pre+hash[i],cur);</span><br><span class="line">            pre=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h2><p>Description:Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1,3,1],</span><br><span class="line"> [1,5,1],</span><br><span class="line"> [4,2,1]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> Given the above grid map, return <code>7</code>. Because the path 1→3→1→1→1 minimizes the sum.</p><p>解题思路：在矩阵上求解从左上角到右下角最短路径，最优子结构关注当前元素的上方元素和左方元素，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">state</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, grid[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">            state[i][<span class="number">0</span>] = state[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            state[<span class="number">0</span>][j] = state[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                state[i][j] = <span class="built_in">min</span>(state[i<span class="number">-1</span>][j], state[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><a href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings" class="headerlink" title="712. Minimum ASCII Delete Sum for Two Strings"></a>712. Minimum ASCII Delete Sum for Two Strings</h2><p>Description:</p><p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;sea&quot;, s2 = &quot;eat&quot;</span><br><span class="line">Output: 231</span><br><span class="line">Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.</span><br><span class="line">Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.</span><br><span class="line">At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;delete&quot;, s2 = &quot;leet&quot;</span><br><span class="line">Output: 403</span><br><span class="line">Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,</span><br><span class="line">adds 100[d]+101[e]+101[e] to the sum.  Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.</span><br><span class="line">At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403.</span><br><span class="line">If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p><code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</p><p>All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p><p>解题思路：本题算是dp中一类经典题“字符串匹配”，利用矩阵解题，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=s1.<span class="built_in">size</span>(), n=s2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]+s2[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+s1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+s1[i<span class="number">-1</span>],dp[i][j<span class="number">-1</span>]+s2[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="647-Palindromic-Substrings"><a href="#647-Palindromic-Substrings" class="headerlink" title="647. Palindromic Substrings"></a>647. Palindromic Substrings</h2><p>Description:</p><p>Given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input string length won’t exceed 1000.</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; i-j &gt;= <span class="number">0</span> &amp;&amp; i+j &lt; n &amp;&amp; s[i-j] == s[i+j]; j++)res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; i<span class="number">-1</span>-j &gt;= <span class="number">0</span> &amp;&amp; i+j &lt; n &amp;&amp; s[i<span class="number">-1</span>-j] == s[i+j]; j++)res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="467-Unique-Substrings-in-Wraparound-String"><a href="#467-Unique-Substrings-in-Wraparound-String" class="headerlink" title="467. Unique Substrings in Wraparound String"></a>467. Unique Substrings in Wraparound String</h2><p>Description:</p><p>Consider the string <code>s</code> to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so <code>s</code> will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p><p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p><p><strong>Note:</strong> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cac&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;zab&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(string p)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxLenCur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;p.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (p[i]-p[i<span class="number">-1</span>]==<span class="number">1</span> || p[i<span class="number">-1</span>]-p[i]==<span class="number">25</span>))&#123;</span><br><span class="line">                maxLenCur++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxLenCur=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index=p[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            count[index]=<span class="built_in">max</span>(count[index],maxLenCur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : count) sum+=n;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a>95. Unique Binary Search Trees II</h2><p>Description:</p><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>.</p><p>For example,<br>Given <em>n</em> = 3, your program should return all 5 unique BST’s shown below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> vector&lt;TreeNode*&gt; &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generator</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generator</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> vector&lt;TreeNode*&gt; &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=end; i++)&#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; l = <span class="built_in">generator</span>(start, i<span class="number">-1</span>);</span><br><span class="line">            vector&lt;TreeNOde*&gt; r = <span class="built_in">generator</span>(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;l.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;r.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                  root-&gt;left = l[j];</span><br><span class="line">                    root-&gt;right = r[k];</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><p>Description:</p><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>?</p><p>For example,<br>Given <em>n</em> = 3, there are a total of 5 unique BST’s.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>]=res[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                res[i]+=res[j<span class="number">-1</span>]*res[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h2><p>Description:</p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p><p><strong>Note:</strong><br>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minArr</span><span class="params">(triangle.back())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> layer=n<span class="number">-2</span>; layer&gt;=<span class="number">0</span>; layer--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=layer;i++)&#123;</span><br><span class="line">                minArr[i]=<span class="built_in">min</span>(minArr[i],minArr[i+<span class="number">1</span>]) + triangle[layer][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="650-2-Keys-Keyboard"><a href="#650-2-Keys-Keyboard" class="headerlink" title="650. 2 Keys Keyboard"></a>650. 2 Keys Keyboard</h2><p>Description:</p><p>Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step:</p><ol><li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li><li><code>Paste</code>: You can paste the characters which are copied <strong>last time</strong>.</li></ol><p>Given a number <code>n</code>. You have to get <strong>exactly</strong> <code>n</code> ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> ‘A’.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Intitally, we have one character &#x27;A&#x27;.</span><br><span class="line">In step 1, we use Copy All operation.</span><br><span class="line">In step 2, we use Paste operation to get &#x27;AA&#x27;.</span><br><span class="line">In step 3, we use Paste operation to get &#x27;AAA&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The <code>n</code> will be in the range [1, 1000].</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSteps</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> i+<span class="built_in">minSteps</span>(n/i);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="474-Ones-and-Zeros"><a href="#474-Ones-and-Zeros" class="headerlink" title="474. Ones and Zeros"></a>474. Ones and Zeros</h2><p>Description:</p><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p><p>For now, suppose you are a dominator of <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p><p>Now your task is to find the maximum number of strings that you can form with given <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <strong>once</strong>.</p><p><strong>Note:</strong></p><ol><li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li><li>The size of given string array won’t exceed <code>600</code>.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You could form &quot;10&quot;, but then you&#x27;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;.</span><br></pre></td></tr></table></figure><p>解题思路：此题明显是一道dp题，本题适合二维矩阵，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : strs)&#123;</span><br><span class="line">            <span class="type">int</span> cZeros=<span class="number">0</span>, cOnes=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>) cZeros++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) cOnes++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m; i&gt;=cZeros; i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n; j&gt;=cOnes; j--)&#123;</span><br><span class="line">                    res[i][j]=<span class="built_in">max</span>(res[i][j], res[i-cZeros][j-cOnes]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a>486. Predict the Winner</h2><p>Description:</p><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p><p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 2]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: Initially, player 1 can choose between 1 and 2. </span><br><span class="line">If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). </span><br><span class="line">So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. </span><br><span class="line">Hence, player 1 will never be the winner and you need to return False.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 233, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.</span><br><span class="line">Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>1 &lt;= length of the array &lt;= 20.</li><li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li><li>If the scores of both players are equal, then player 1 is still the winner.</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) dp[i][i]=nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>; len&lt;n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n-len;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = i+len;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(nums[i]-dp[i+<span class="number">1</span>][j], nums[j]-dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums==NULL) return true;</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) dp[i]=nums[i];</span><br><span class="line">                <span class="keyword">else</span> dp[j]=<span class="built_in">max</span>(nums[i]-dp[j],nums[j]-dp[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h2><p>Description:</p><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure><p>解题思路：本质是dp题，只是套了一层，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum+=num;</span><br><span class="line">        <span class="keyword">if</span>((sum&amp;<span class="number">1</span>)==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(sum+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++) dp[i][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;sum+<span class="number">1</span>; j++) dp[<span class="number">0</span>][j]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;sum+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i<span class="number">-1</span>]) dp[i][j]=dp[i][j] || dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum+=num;</span><br><span class="line">        <span class="keyword">if</span>((sum&amp;<span class="number">1</span>)==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(sum+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=sum; i&gt;=num; i--)&#123;</span><br><span class="line">                dp[i]=dp[i]||dp[i-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a>494. Target Sum</h2><p>Description:</p><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.</li><li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ol><p>代码如下：此题套了上一题的dp，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum+=num;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;S||(S+sum)%<span class="number">2</span>&gt;<span class="number">0</span>?<span class="number">0</span>:<span class="built_in">subsetSum</span>(nums, (S+sum)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subsetSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=target; i&gt;=num; i--) dp[i]+=dp[i-num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h2><p>Description:</p><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p><p>For example, given<br><em>s</em> = <code>&quot;leetcode&quot;</code>,<br><em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.</p><p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p><p><strong>UPDATE (2017/1/4):</strong><br>The <em>wordDict</em> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p><p>解题思路：一般我都需要把子字符串都枚举出来，自然而然会想到dp，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(wordDict.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_set&lt;string&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(string str : wordDict) dict.<span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                    string word = s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">                    <span class="keyword">if</span>(dict.<span class="built_in">find</span>(word)!=dict.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Tree"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Tree" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Tree"></a>714. Best Time to Buy and Sell Stock with Transaction Tree</h2><p>Description:</p><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The maximum profit can be achieved by:</span><br><span class="line">Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p><code>0 &lt; prices.length &lt;= 50000</code>.</p><p><code>0 &lt; prices[i] &lt; 50000</code>.</p><p><code>0 &lt;= fee &lt; 50000</code>.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> t_ik0=<span class="number">0</span>, t_ik1=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price : prices)&#123;</span><br><span class="line">            <span class="type">long</span> t_ik0_old = t_ik0;</span><br><span class="line">            t_ik0 = <span class="built_in">max</span>(t_ik0, t_ik1+price-fee);</span><br><span class="line">            t_ik1 = <span class="built_in">max</span>(t_ik1, t_ik0_old-price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t_ik0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h2><p>Description:</p><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> pMax=<span class="number">0</span>, nMax=<span class="number">0</span>, m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>) <span class="built_in">swap</span>(pMax, nMax);</span><br><span class="line">            pMax=<span class="built_in">max</span>(pMax*nums[i], nums[i]);</span><br><span class="line">            nMax=<span class="built_in">min</span>(nMax*nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(pMax&gt;m) m = pMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="516-Longest-Palindromic-Subsequence"><a href="#516-Longest-Palindromic-Subsequence" class="headerlink" title="516. Longest Palindromic Subsequence"></a>516. Longest Palindromic Subsequence</h2><p>Description:</p><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong><br>Input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;bbbab&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is “bbbb”.</p><p><strong>Example 2:</strong><br>Input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;cbbd&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is “bb”.</p><p>解题思路：字符串=&gt;网格，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a>221. Maximal Square</h2><p>Description:</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>For example, given the following matrix:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return 4.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=matrix[i][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">            maxsize=<span class="built_in">max</span>(maxsize,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=matrix[<span class="number">0</span>][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            maxsize=<span class="built_in">max</span>(maxsize,dp[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    maxsize=<span class="built_in">max</span>(maxsize,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsize*maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h2><p>Description:</p><p>Follow up for “Unique Paths”:</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p>For example,</p><p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The total number of unique paths is <code>2</code>.</p><p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=obstacleGrid.<span class="built_in">size</span>(), n=obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span> || obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>||dp[i<span class="number">-1</span>][<span class="number">0</span>]==<span class="number">0</span>) dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>||dp[<span class="number">0</span>][j<span class="number">-1</span>]==<span class="number">0</span>) dp[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=obstacleGrid.<span class="built_in">size</span>(), n=obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span> || obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) dp[j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[j]+=dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a>264. Ugly Number II</h2><p>Description:</p><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p><p>Note that <code>1</code> is typically treated as an ugly number, and <em>n</em> <strong>does not exceed 1690</strong>.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><p>经典题，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t2=<span class="number">0</span>, t3=<span class="number">0</span>, t5=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[t2]*<span class="number">2</span>, <span class="built_in">min</span>(dp[t3]*<span class="number">3</span>, dp[t5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(dp[t2]*<span class="number">2</span>==dp[i]) t2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[t3]*<span class="number">3</span>==dp[i]) t3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[t5]*<span class="number">5</span>==dp[i]) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115. Distinct Subsequences"></a>115. Distinct Subsequences</h2><p>Description:</p><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]==s[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+dp[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a>140. Word Break II</h2><p>Description:</p><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        unordered_set&lt;string&gt; dict;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;string&gt;&gt; memo;</span><br><span class="line">        vector&lt;string&gt; output;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordDict) &#123;</span><br><span class="line">            dict.<span class="built_in">insert</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">wordBreakRecur</span>(s, <span class="number">0</span>, dict, memo);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : memo[<span class="number">0</span>])</span><br><span class="line">            output.<span class="built_in">push_back</span>(str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wordBreakRecur</span><span class="params">(string&amp; s, <span class="type">int</span> pos, unordered_set&lt;string&gt;&amp; dict, unordered_map&lt;<span class="type">int</span>, vector&lt;string&gt;&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos+offset &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            word += s[pos+offset]; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dict.<span class="built_in">find</span>(word) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos+offset+<span class="number">1</span> == s.<span class="built_in">size</span>())</span><br><span class="line">                    memo[pos].<span class="built_in">push_back</span>(word);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(memo.<span class="built_in">find</span>(pos+offset+<span class="number">1</span>) == memo.<span class="built_in">end</span>())</span><br><span class="line">                        <span class="built_in">wordBreakRecur</span>(s, pos+offset+<span class="number">1</span>, dict, memo);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> str : memo[pos+offset+<span class="number">1</span>]) &#123;</span><br><span class="line">                        memo[pos].<span class="built_in">push_back</span>(word + <span class="string">&quot; &quot;</span> + str);</span><br><span class="line">                    &#125;            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="174-Dungeon-Game"><a href="#174-Dungeon-Game" class="headerlink" title="174. Dungeon Game"></a>174. Dungeon Game</h2><p>Description:</p><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0’s</em>) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p><p>For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table><p><strong>Note:</strong></p><ul><li>The knight’s health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = dungeon.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">hp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, INT_MAX));</span><br><span class="line">        hp[m][n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        hp[m<span class="number">-1</span>][n]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="type">int</span> need = <span class="built_in">min</span>(hp[i+<span class="number">1</span>][j],hp[i][j+<span class="number">1</span>])-dungeon[i][j];</span><br><span class="line">                hp[i][j]=need&lt;=<span class="number">0</span>?<span class="number">1</span>:need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h2><p>Description:</p><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p><p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</span><br><span class="line">             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">解题思路</a>,代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> t_ik0=<span class="number">0</span>, t_ik1=INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> price : prices)&#123;</span><br><span class="line">                <span class="type">int</span> t_ik0_old=t_ik0;</span><br><span class="line">                t_ik0=<span class="built_in">max</span>(t_ik0,t_ik1+price);</span><br><span class="line">                t_ik1=<span class="built_in">max</span>(t_ik1,t_ik0_old-price);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t_ik0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t_ik0</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t_ik1</span><span class="params">(k+<span class="number">1</span>,INT_MIN)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price: prices)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=k;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                t_ik0[j]=<span class="built_in">max</span>(t_ik0[j],t_ik1[j]+price);</span><br><span class="line">                t_ik1[j]=<span class="built_in">max</span>(t_ik1[j],t_ik0[j<span class="number">-1</span>]-price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t_ik0[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h2><p>Description:</p><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j*j&lt;=i; j++)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h2><p>Description:</p><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>(), res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; s[st.<span class="built_in">top</span>()]==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="type">int</span> a=len, b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            b=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res = <span class="built_in">max</span>(res, a-b<span class="number">-1</span>);</span><br><span class="line">            a=b;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,a);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses2</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>(), res=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; i-dp[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)?dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                res = <span class="built_in">max</span>(dp[i],res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h2><p>Description:</p><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p><img src="https://leetcode.com/static/images/problemset/robot_maze.png" alt="img"><br>Above is a 7 x 3 grid. How many possible unique paths are there?</p><p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                dp[j]+=dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h2><p>Description:</p><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#x27;h&#x27; with &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (remove &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (remove &#x27;e&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (replace &#x27;i&#x27; with &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (replace &#x27;n&#x27; with &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (replace &#x27;n&#x27; with &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (insert &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h2><p>Description:</p><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(m+n!=s3.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i][j]=dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=(dp[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (dp[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的dp类算法的总结，包含了各题的solution和常用的解决方法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;198-House-</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-binary search类总结(会持续更新的...)</title>
    <link href="http://example.com/2017/11/20/LeetCode-binary-search%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/11/20/LeetCode-binary-search%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2017-11-20T10:07:47.000Z</published>
    <updated>2022-05-03T13:07:13.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的binary search类算法的总结，包含了各题的solution和常用的解决方法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关于二分查找的一些trick：</span><br><span class="line">1. mid=lo+(hi-lo)/2,防止大数溢出；</span><br><span class="line">2. 注意区分两种搜索空间：index search | range search;</span><br></pre></td></tr></table></figure><h2 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278. First Bad Version"></a>278. First Bad Version</h2><p>Description:</p><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><p>解题思路：本题数组为<strong>有序</strong> ，并且题目要求<strong>查找</strong> ，自然而然会想到二分查找，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> front = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tail = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (tail-front)/<span class="number">2</span> + front;</span><br><span class="line">            <span class="type">bool</span> res = <span class="built_in">isBadVersion</span>(mid);</span><br><span class="line">            <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isBadVersion</span>(mid<span class="number">-1</span>)) <span class="keyword">return</span> mid;</span><br><span class="line">                tail = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                front = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h2><p>Description:</p><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p><p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>解题思路：基本思路就是树的遍历，利用完全二叉树的性质优化程序，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">        TreeNode *lp=root, *rp=root;</span><br><span class="line">        <span class="keyword">while</span>(lp)&#123;l++; lp=lp-&gt;left;&#125;</span><br><span class="line">        <span class="keyword">while</span>(rp)&#123;r++; rp=rp-&gt;right;&#125;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,l)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h2><p>Description:</p><p>Divide two integers without using multiplication, division and mod operator.</p><p>If it is overflow, return MAX_INT.</p><p>解题思路：利用减法，加之<strong>移位</strong> 操作<strong>优化</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!divisor || (dividend==INT_MIN &amp;&amp; divisor==<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sign = (dividend&lt;<span class="number">0</span>)^(divisor&lt;<span class="number">0</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> divid=<span class="built_in">labs</span>(dividend);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> divis=<span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(divid&gt;=divis)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp=divis, multi=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(divid&gt;=(temp&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                multi&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divid-=temp;</span><br><span class="line">            res +=multi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?res:<span class="number">0</span>-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h2><p>Description:Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>解题思路：<strong>经典题型</strong> ，先找到最小值的位置，然后“平移”数组，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(r+l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[r]) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rot=l;</span><br><span class="line">        l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> realmid=(mid+rot)%nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span>(nums[realmid]==target) <span class="keyword">return</span> realmid;</span><br><span class="line">            <span class="keyword">if</span>(nums[realmid]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="436-Find-Right-Interval"><a href="#436-Find-Right-Interval" class="headerlink" title="436. Find Right Interval"></a>436. Find Right Interval</h2><p>Description:</p><p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.</p><p>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p><p><strong>Note:</strong></p><ol><li>You may assume the interval’s end point is always bigger than its start point.</li><li>You may assume none of these intervals have the same start point.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: [-1]</span><br><span class="line"></span><br><span class="line">Explanation: There is only one interval in the collection, so it outputs -1.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [3,4], [2,3], [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: [-1, 0, 1]</span><br><span class="line"></span><br><span class="line">Explanation: There is no satisfied &quot;right&quot; interval for [3,4].</span><br><span class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;</span><br><span class="line">For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,4], [2,3], [3,4] ]</span><br><span class="line"></span><br><span class="line">Output: [-1, 2, -1]</span><br><span class="line"></span><br><span class="line">Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].</span><br><span class="line">For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point.</span><br></pre></td></tr></table></figure><p>解题思路：我们需要对区间排序，并且需要记录原有索引，所以使用<strong>map</strong> 数据结构；然后使用二分查找找到相应的区间，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Interval</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="built_in">Interval</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">end</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Interval</span>(<span class="type">int</span> s, <span class="type">int</span> e) : <span class="built_in">start</span>(s), <span class="built_in">end</span>(e) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash[intervals[i].start]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> in : intervals)&#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = hash.<span class="built_in">lower_bound</span>(in.end);</span><br><span class="line">            <span class="keyword">if</span>(itr==hash.<span class="built_in">end</span>()) res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">push_back</span>(itr-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h2><p>Description:</p><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p><p>解题思路：此题属于index search,数组中会出现多个相同的目标值，我们需要确定起始和终止的位置。这样的话，其实我们需要做两次BS，即从两个反方向进行，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[l]!=target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>]=l;</span><br><span class="line">        </span><br><span class="line">        r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>]=r;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a>454. 4Sum II</h2><p>Description:</p><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code>is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; abHash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b : B)&#123;</span><br><span class="line">                ++abHash[a+b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d : D)&#123;</span><br><span class="line">                <span class="keyword">auto</span> itr = abHash.<span class="built_in">find</span>(<span class="number">0</span>-c-d);</span><br><span class="line">                <span class="keyword">if</span>(itr!=abHash.<span class="built_in">end</span>()) count+= itr-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a>74. Search a 2D Matrix</h2><p>Description:Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p>For example,</p><p>Consider the following matrix:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Given <strong>target</strong> = <code>3</code>, return <code>true</code>.</p><p>解题思路：将二维数组按照一维数组进行处理，属于index search, 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>, r=row*col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid%col]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[l/col][l%col]==target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a>81. Search in Rotated Sorted Array II</h2><p>Description:</p><blockquote><p><em>Follow up</em> for “Search in Rotated Sorted Array”:<br>What if <em>duplicates</em> are allowed?</p><p>Would this affect the run-time complexity? How and why?</p></blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Write a function to determine if a given target is in the array.</p><p>The array may contain duplicates.</p><p>解题思路：旋转数组问题关键是找到最小值位置，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> lo =<span class="number">0</span>, hi = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[hi])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; nums[lo] &lt;= target) hi = mid;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[hi])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; nums[hi] &gt;= target) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo] == target ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h2><p>Description:Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p><p>Your algorithm should run in O(<em>n2</em>) complexity.</p><p><strong>Follow up:</strong> Could you improve it to O(<em>n</em> log <em>n</em>) time complexity?</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/pbrother">@pbrother</a> for adding this problem and creating all test cases.</p><p>解题思路：动态规划，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h2><p>Description:</p><p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The repeated subarray with maximum length is [3, 2, 1].</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>1 &lt;= len(A), len(B) &lt;= 1000</li><li>0 &lt;= A[i], B[i] &lt; 100</li></ol><p>解题思路：动态规划，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=A.<span class="built_in">size</span>(), n=B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!m || !n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[j]=A[i]==B[j]?<span class="number">1</span>+dp[j+<span class="number">1</span>]:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h2><p>Description:</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><p>解题思路：旋转数组，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lo=<span class="number">0</span>, hi=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="type">int</span> mid= (lo+hi)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[hi]) lo=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h2><p>Description:</p><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p><p>**Note: **<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p>解题思路：本质就是计数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">treeCount</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;left, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;count+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;right,k<span class="number">-1</span>-count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">treeCount</span><span class="params">(TreeNode* n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">treeCount</span>(n-&gt;left)+<span class="built_in">treeCount</span>(n-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h2><p>Description:</p><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>For example,</p><p>Consider the following matrix:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Given <strong>target</strong> = <code>5</code>, return <code>true</code>.</p><p>Given <strong>target</strong> = <code>20</code>, return <code>false</code>.</p><p>解题思路：<strong>经典题</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>||matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cols&gt;=<span class="number">0</span> &amp;&amp; row &lt; rows)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][cols]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][cols]&lt;target) row++;</span><br><span class="line">            <span class="keyword">else</span> cols--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378. Kth Smallest Element in a Sorted Matrix"></a>378. Kth Smallest Element in a Sorted Matrix</h2><p>Description:</p><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p><p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**Note: **<br>You may assume k is always valid, 1 ≤ k ≤ n2.</p><p>解题思路：本题很经典，此题属于range search，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lo=matrix[<span class="number">0</span>][<span class="number">0</span>], hi=matrix[rows<span class="number">-1</span>][cols<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="type">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>, j=cols<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; matrix[i][j]&gt;mid) j--;</span><br><span class="line">                count+=(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k) lo=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a>658. Find K Closest Elements</h2><p>Description:Given a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5], k=4, x=3</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5], k=4, x=-1</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The value k is positive and will always be smaller than the length of the sorted array.</li><li>Length of the given array is positive and will not exceed 104</li><li>Absolute value of elements in the array and x will not exceed 104</li></ol><hr><p><strong>UPDATE (2017/9/19):</strong><br>The <em>arr</em> parameter had been changed to an <strong>array of integers</strong> (instead of a list of integers). <strong>Please reload the code definition to get the latest changes</strong>.</p><p>解题思路：先找到x（大于x的第一元素）在数组中的位置，然后在此位置周围找到k个元素，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">low_bound</span>(arr, len, x);</span><br><span class="line">        <span class="type">int</span> i=index<span class="number">-1</span>, j=index;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            i&lt;<span class="number">0</span>||(j&lt;len &amp;&amp; <span class="built_in">abs</span>(arr[i]-x)&gt;<span class="built_in">abs</span>(arr[j]-x))?j++:i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>()+i+<span class="number">1</span>,arr.<span class="built_in">begin</span>()+j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">low_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> len, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[len<span class="number">-1</span>]&lt;target) <span class="keyword">return</span> len<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> lo=<span class="number">0</span>, hi=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="type">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) lo=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="209-Minmum-Size-Subarray-Sum"><a href="#209-Minmum-Size-Subarray-Sum" class="headerlink" title="209. Minmum Size Subarray Sum"></a>209. Minmum Size Subarray Sum</h2><p>Description:</p><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p><p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p><p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/#">click to show more practice.</a></p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p><p>解题思路：双指针法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=INT_MAX;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len)&#123;</span><br><span class="line">            sum+=nums[j++];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=s)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res,j-i);</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX?<span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h2><p>Description:</p><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Note:</strong></p><ol><li>You <strong>must not</strong> modify the array (assume the array is read only).</li><li>You must use only constant, <em>O</em>(1) extra space.</li><li>Your runtime complexity should be less than <code>O(n2)</code>.</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ol><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><p>解题思路：代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">            fast=nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">            fast=nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的binary search类算法的总结，包含了各题的solution和常用的解决方法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>DenseNet论文总结</title>
    <link href="http://example.com/2017/11/17/DenseNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/11/17/DenseNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</id>
    <published>2017-11-17T03:32:19.000Z</published>
    <updated>2022-05-03T13:38:17.578Z</updated>
    
    <content type="html"><![CDATA[<p> 本篇文章是<strong>CVPR2017的oral</strong> ，提出了DenseNet(Dense Convolutional Network)。此网络结构借鉴了Inception和ResNet的思想，效果非常好。最近几年网络结构一般沿着两个方向发展：要么更深（ResNet解决了网络更深梯度消失的问题）；要么更宽（GoogleNet的Inception）。本文则是<strong>从feature入手，将feature的极致利用达到更好的效果和更少的参数</strong> 。</p><blockquote><p><strong>DenseNet有以下优点：</strong> </p><p><strong>1. 减轻梯度消失</strong> </p><p><strong>2. 加强feature传递</strong> </p><p><strong>3. 更有效地利用feature</strong> </p><p><strong>4. 减少了参数</strong> </p></blockquote><p>在深度学习网络中，随着网络深度的增加，梯度消失的问题愈发明显。针对此问题，目前提出了很多解决方案，比如：Highway Networks、ResNet、stochastic depth等。这些方法都有一个明显的特征：<strong>create short paths from early layers to later layers</strong> 。作者也是借鉴了这个思路，<strong>在保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层两两相连</strong> 。如下图所示：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/densenet1.png?raw=true"></p><p>在传统卷积神经网络中，假设有L层，那么就会有L个连接。而<strong>在DensNet中，则会有L(L+1)/2个连接。DenseNet的一个优点是网络更窄，参数更少，很大一部分原因得益于这种dense block的设计，后面有提到在dense block中每个卷积层的输出feature map的数量都很小（小于100），而不是像其他网络一样动不动就几百上千的宽度。同时这种连接方式使得特征和梯度的传递更加有效，网络也就更加容易训练。原文的一句话：Each layer has direct access to the gradients from the loss function and the original input signal, leading to an implicit deep supervision.直接解释了为什么这个网络的效果会很好。前面提到过梯度消失问题在网络深度越深的时候越容易出现，原因就是输入信息和梯度信息在很多层之间传递导致的，而现在这种dense connection相当于每一层都直接连接input和loss，因此就可以减轻梯度消失现象，这样更深网络不是问题。</strong> 另外作者还观察到这种dense connection有<strong>正则化的效果</strong> ，因此对于过拟合有一定的抑制作用。</p><p>Figure1给出了dense block的组成结构，下面给出DenseNet的整体结构，如下图所示：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/densenet2.png?raw=true"></p><p>Table1给出DenseNet在ImageNet上的详细设计，如下图所示：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/densenet3.png?raw=true"></p><p>这个表中的k=32，k=48中的k是growth rate，表示每个dense block中每层输出的feature map个数。为了避免网络变得很宽，作者都是采用较小的k，比如32这样，作者的实验也表明小的k可以有更好的效果。根据dense block的设计，后面几层可以得到前面所有层的输入，因此concat后的输入channel还是比较大的。<strong>另外这里每个dense block的3*3卷积前面都包含了一个1*1的卷积操作，就是所谓的bottleneck layer，目的是减少输入的feature map数量，既能降维减少计算量，又能融合各个通道的特征。</strong></p><h4 id="ResNet-vs-DenseNet"><a href="#ResNet-vs-DenseNet" class="headerlink" title="ResNet vs DenseNet"></a>ResNet vs DenseNet</h4><p>这两个网络有本质的区别，从它们的公式就可以看出：</p><p>第一个公式是ResNet的。这里的l表示层，xl表示l层的输出，Hl表示一个非线性变换。所以对于ResNet而言，l层的输出是l-1层的输出加上对l-1层输出的非线性变换。</p><p><img src="http://img.blog.csdn.net/20170715081918000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDM4MDE2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>第二个公式是DenseNet的。[x0,x1,…,xl-1]表示将0到l-1层的输出feature map做concatenation。concatenation是做通道的合并，就像Inception那样。而前面ResNet是做值的相加，通道数是不变的。<strong>Hl包括BN，ReLU和3*3的卷积</strong> 。</p><p><img src="http://img.blog.csdn.net/20170715081947337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDM4MDE2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><blockquote><p><strong>参考:</strong></p><p>论文：<a href="https://arxiv.org/pdf/1608.06993.pdf">《densely connected convolutinal networks》</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 本篇文章是&lt;strong&gt;CVPR2017的oral&lt;/strong&gt; ，提出了DenseNet(Dense Convolutional Network)。此网络结构借鉴了Inception和ResNet的思想，效果非常好。最近几年网络结构一般沿着两个方向发展：要么更深（</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="DenseNet" scheme="http://example.com/tags/DenseNet/"/>
    
    <category term="ResNet" scheme="http://example.com/tags/ResNet/"/>
    
  </entry>
  
  <entry>
    <title>LSTM和GRU比较</title>
    <link href="http://example.com/2017/11/10/LSTM%E5%92%8CGRU%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2017/11/10/LSTM%E5%92%8CGRU%E6%AF%94%E8%BE%83/</id>
    <published>2017-11-10T08:23:27.000Z</published>
    <updated>2022-05-03T13:07:35.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对论文<a href="https://arxiv.org/pdf/1412.3555.pdf">Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a> 的总结，我会通过两个方面介绍论文：一是传统RNN和门控RNN区别与联系；二是两种门控RNN LSTM和GRU的区别与联系。</p><blockquote><p><strong>注：</strong> 本文不涉及RNN、LSTM和GRU基本概念介绍。若想了解，可以看我之前写的<a href="https://zxth93.github.io/2017/09/16/%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">博客</a> 。</p></blockquote><h3 id="1-传统RNN-vs-门控RNN"><a href="#1-传统RNN-vs-门控RNN" class="headerlink" title="1. 传统RNN vs 门控RNN"></a>1. 传统RNN vs 门控RNN</h3><blockquote><p>传统RNN的<strong>问题</strong> ：长期依赖会造成<strong>梯度消失（多数情况下）</strong> 或<strong>梯度爆炸（少数情况下）</strong> 。</p><p>解决以上问题的方案：</p><ol><li>以新的方法改善或者代替传统的SGD方法，如Bengio提出的clipped gradient;</li><li>设计更为精妙的activation function或recurrent unit，如LSTM和GRU。原因：LSTM和GRU都能通过各种Gate将重要特征保留，保证其在long-term 传播的时候也不会被丢失；还有一个作用就是有利于BP的时候不容易梯度消失。</li></ol></blockquote><blockquote><p>传统RNN和门控RNN的<strong>不同点：</strong> </p><ol><li>传统RNN会每一步都重写”记忆“，而门控RNN可以在某些步骤保持原有”记忆“；</li><li>门控RNN收敛速度更快，泛化能力更好。</li></ol></blockquote><h3 id="2-LSTM-vs-GRU"><a href="#2-LSTM-vs-GRU" class="headerlink" title="2. LSTM vs GRU"></a>2. LSTM vs GRU</h3><blockquote><p><strong>相同点；</strong> 都属于”加模型“</p></blockquote><blockquote><p><strong>不同点：</strong> </p><ol><li>LSTM可控”记忆“的曝光度，而GRU完全暴露”记忆“，是不可控的；</li><li>  LSTM的新”记忆“是与forget gate独立的，而GRU的新”记忆“受update gate控制</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文针对论文&lt;a href=&quot;https://arxiv.org/pdf/1412.3555.pdf&quot;&gt;Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling&lt;/a&gt; 的总结，</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="LSTM" scheme="http://example.com/tags/LSTM/"/>
    
    <category term="GRU" scheme="http://example.com/tags/GRU/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-tree类总结（会持续更新...）</title>
    <link href="http://example.com/2017/10/20/LeetCode-tree%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/10/20/LeetCode-tree%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2017-10-20T07:48:12.000Z</published>
    <updated>2022-05-03T13:07:33.746Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的tree类算法的总结，包含了各题的solution和常用的解决方法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><p>此类题的常用思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 树的遍历</span><br><span class="line"><span class="number">2.</span> 递归</span><br><span class="line"><span class="number">3.</span> 树的搜索</span><br><span class="line"><span class="number">4.</span> 集合数据结构</span><br><span class="line"><span class="number">5.</span> BST的中序遍历</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h2><p>Description:</p><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解题思路：本题要求按层打印并且自底向上，故需要使用<strong>队列</strong>和<strong>栈</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">      queue&lt;TreeNode*&gt; q;</span><br><span class="line">      stack&lt;vector&lt;<span class="type">int</span>&gt;&gt; tower;</span><br><span class="line">      <span class="keyword">if</span>(root) q.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">          size = q.<span class="built_in">size</span>();</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">              q.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">              temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">          tower.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span>(!tower.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tower.<span class="built_in">top</span>());</span><br><span class="line">          tower.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h2><p>Description:</p><p>Find the sum of all left leaves in a given binary tree.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure><p>解题思路：使用递归，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root-&gt;left-&gt;val + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left)+<span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a>669. Trim a Binary Search Tree</h2><p>Description:</p><p>Given a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 2</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 3</span><br><span class="line"></span><br><span class="line">Output: </span><br><span class="line">      3</span><br><span class="line">     / </span><br><span class="line">   2   </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>解题思路：本题是BST，所以要用好BST特性。本质上本题考察的是BST的遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; L)&#123;</span><br><span class="line">            root = <span class="built_in">trimBST</span>(root-&gt;right, L, R);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; R)&#123;</span><br><span class="line">            root = <span class="built_in">trimBST</span>(root-&gt;left, L, R);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, L, R);</span><br><span class="line">            root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h2><p>Description:</p><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong>path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><p>解题思路：属于求树高的变体，思路是使用递归方式遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">depth</span>(root-&gt;left) + <span class="built_in">depth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="built_in">diameterOfBinaryTree</span>(root-&gt;left), <span class="built_in">diameterOfBinaryTree</span>(root-&gt;right)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left), <span class="built_in">depth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a>437. Path Sum III</h2><p>Description:</p><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><p> 解题思路：本题属于“串行递归”：因为根节点、左子节点和右节点都有可能满足题意，所以对它们要同等对待。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pathSumFrom</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left,sum) + <span class="built_in">pathSum</span>(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSumFrom</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (root-&gt;val==sum ? <span class="number">1</span> : <span class="number">0</span>) + <span class="built_in">pathSumFrom</span>(root-&gt;left, sum - root-&gt;val) + <span class="built_in">pathSumFrom</span>(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-Balance-Binary-Tree"><a href="#110-Balance-Binary-Tree" class="headerlink" title="110. Balance Binary Tree"></a>110. Balance Binary Tree</h2><p>Description:</p><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p><p>解题思路：使用<strong>搜索</strong> 的方式解决此题，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">dfsHeight</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> l = <span class="built_in">dfsHeight</span>(root-&gt;left);</span><br><span class="line">      <span class="keyword">if</span>(l==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span> r = <span class="built_in">dfsHeight</span>(root-&gt;right);</span><br><span class="line">      <span class="keyword">if</span>(r==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">dfsHeight</span>(root-&gt;left), <span class="built_in">dfsHeight</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h2><p>Description:</p><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>解题思路：本题是求深度的变形，重点区分含有双子节点的父节点和含有单子节点的父节点，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left == <span class="literal">NULL</span> || root-&gt;right == <span class="literal">NULL</span> ? <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) : <span class="number">1</span>+<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h2><p>Description:</p><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:</p><p>Given the below binary tree and </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = 22</span><br></pre></td></tr></table></figure><p>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p><p>解题思路：递归，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == sum &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum-root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a>501. Find Mode in Binary Search Tree</h2><p>Description:</p><p>Given a binary search tree (BST) with duplicates, find all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode(s)</a> (the most frequently occurred element) in the given BST.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>For example:<br>Given BST <code>[1,null,2,2]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>return <code>[2]</code>.</p><p><strong>Note:</strong> If a tree has more than one mode, you can return them in any order.</p><p><strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max, pre, cnt;</span><br><span class="line">        <span class="built_in">getMax</span>(root, max=<span class="number">0</span>, pre, cnt=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getMode</span>(root, max, pre, cnt=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMax</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;max, <span class="type">int</span> &amp;pre, <span class="type">int</span> &amp;cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">getMax</span>(root-&gt;left, max, pre, cnt);</span><br><span class="line">        <span class="built_in">getMax</span>(root-&gt;right, max=cnt&gt;max?cnt:max, pre=root-&gt;val, ++(cnt*=(pre==root-&gt;val)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMode</span><span class="params">(TreeNode* root, <span class="type">int</span> max, <span class="type">int</span> &amp;pre, <span class="type">int</span> &amp;cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">getMode</span>(root-&gt;left, max, pre, cnt);</span><br><span class="line">        <span class="keyword">if</span>(++(cnt*=(root-&gt;val==pre)) == max) res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">getMode</span>(root-&gt;right, max, pre=root-&gt;val, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a>538. Convert BST to Greater Tree</h2><p>Description:</p><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure><p>解题思路：本题考察BST的中序遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">travel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">travel</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">travel</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h2><p>Description:</p><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p><p>解题思路：根据题意来，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1!=<span class="literal">NULL</span> &amp;&amp; t2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a>637. Average of Levels in Binary Tree</h2><p>Description:</p><p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Output: [3, 14.5, 11]</span><br><span class="line">Explanation:</span><br><span class="line">The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The range of node’s value is in the range of 32-bit signed integer.</li></ol><p>解题思路：对树进行分层操作，自然而然会想到使用集合数据结构：<strong>队列</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">      queue&lt;TreeNode*&gt; q;</span><br><span class="line">      <span class="keyword">if</span>(root) q.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">          <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s; i++)&#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">              temp += node-&gt;val;</span><br><span class="line">              q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          res.<span class="built_in">push_back</span>(temp/(<span class="type">double</span>)s);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h2><p>Description:</p><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>解题思路：根据BST特点解题，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line">      <span class="type">int</span> mid = nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(nums.begin(), nums.begin()+mid)</span></span>;</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(nums.begin()+mid+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">      root-&gt;left = <span class="built_in">sortedArrayToBST</span>(l);</span><br><span class="line">      root-&gt;right = <span class="built_in">sortedArrayToBST</span>(r);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h2><p>Description:</p><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      /  \</span><br><span class="line">      3   5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>For example, the lowest common ancestor (LCA) of nodes <code>2</code> and <code>8</code> is <code>6</code>. Another example is LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself according to the LCA definition.</p><p>解题思路：结合BST特点，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; <span class="built_in">min</span>(p-&gt;val, q-&gt;val)) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; <span class="built_in">max</span>(p-&gt;val, q-&gt;val)) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="653. Two Sum IV - Input is a BST"></a>653. Two Sum IV - Input is a BST</h2><p>Description:</p><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 28</span><br><span class="line"></span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p>解题思路：结合BST特点，将BST转化为升序数组，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">travel</span>(root);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> sum = res[i]+res[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; k)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; k)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">travel</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travel</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">travel</span>(root-&gt;right);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h2><p>Description:</p><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p><p>解题思路：代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">NULL</span> || <span class="built_in">isSymmetricHelp</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetricHelp</span><span class="params">(TreeNode* l, TreeNode* r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span> || r==<span class="literal">NULL</span>) <span class="keyword">return</span> l==r;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSymmetricHelp</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="built_in">isSymmetricHelp</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="563-Binary-Tree-Tilt"><a href="#563-Binary-Tree-Tilt" class="headerlink" title="563. Binary Tree Tilt"></a>563. Binary Tree Tilt</h2><p>Description:</p><p>Given a binary tree, return the tilt of the <strong>whole tree</strong>.</p><p>The tilt of a <strong>tree node</strong> is defined as the <strong>absolute difference</strong> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p><p>The tilt of the <strong>whole tree</strong> is defined as the sum of all nodes’ tilt.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">Tilt of node 2 : 0</span><br><span class="line">Tilt of node 3 : 0</span><br><span class="line">Tilt of node 1 : |2-3| = 1</span><br><span class="line">Tilt of binary tree : 0 + 0 + 1 = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The sum of node values in any subtree won’t exceed the range of 32-bit integer.</li><li>All the tilt values won’t exceed the range of 32-bit integer.</li></ol><p>解题思路：代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">        result += <span class="built_in">abs</span>(l-r);</span><br><span class="line">        <span class="keyword">return</span> l+r+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a>572. Subtree of Another Tree</h2><p>Description:</p><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p><p><strong>Example 1:</strong><br>Given tree s:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>true</p><p><strong>Example 2:</strong><br>Given tree s:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /</span><br><span class="line">  0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>false</p><p>解题思路：判断高度，判断是否相同，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; nodes;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!t &amp;&amp; !s)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!t || !s)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">getDepth</span>(s, <span class="built_in">getDepth</span>(t, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(TreeNode* n : nodes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">identical</span>(n, t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">max</span>(<span class="built_in">getDepth</span>(r-&gt;left, d), <span class="built_in">getDepth</span>(r-&gt;right, d)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == d) nodes.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">identical</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s || !t || s-&gt;val!=t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">identical</span>(s-&gt;left, t-&gt;left) &amp;&amp; <span class="built_in">identical</span>(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="671-Second-Minimum-Node-In-a-Binary-Tree"><a href="#671-Second-Minimum-Node-In-a-Binary-Tree" class="headerlink" title="671. Second Minimum Node In a Binary Tree"></a>671. Second Minimum Node In a Binary Tree</h2><p>Descripiton:</p><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes.</p><p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p><p>If no such second minimum value exists, output -1 instead.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line">     / \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The smallest value is 2, but there isn&#x27;t any second smallest value.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;val &lt; root-&gt;right-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="built_in">findSecondMinimumValue</span>(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">-1</span>) <span class="keyword">return</span> root-&gt;right-&gt;val;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(l, root-&gt;right-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left-&gt;val &gt; root-&gt;right-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">findSecondMinimumValue</span>(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(r==<span class="number">-1</span>) <span class="keyword">return</span> root-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(r, root-&gt;left-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="built_in">findSecondMinimumValue</span>(root-&gt;left);</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">findSecondMinimumValue</span>(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">-1</span>) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="keyword">if</span>(r==<span class="number">-1</span>) <span class="keyword">return</span> l;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(l, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="687-Longest-Univalue-Path"><a href="#687-Longest-Univalue-Path" class="headerlink" title="687. Longest Univalue Path"></a>687. Longest Univalue Path</h2><p>Description:</p><p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><p><strong>Example 1:</strong></p><p>Input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \</span><br><span class="line">1   1   5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p>Input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \</span><br><span class="line">4   4   5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.</p><p>解题思路：本题需要使用<strong>搜索</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lup = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root) <span class="built_in">dfs</span>(root, lup);</span><br><span class="line">        <span class="keyword">return</span> lup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; lup)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = node-&gt;left ? <span class="built_in">dfs</span>(node-&gt;left, lup) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = node-&gt;right ? <span class="built_in">dfs</span>(node-&gt;right, lup) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> resl = node-&gt;left &amp;&amp; node-&gt;left-&gt;val == node-&gt;val ? l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> resr = node-&gt;right &amp;&amp; node-&gt;right-&gt;val == node-&gt;val ? r + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        lup = <span class="built_in">max</span>(lup, resl + resr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(resl, resr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><p>Description:</p><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its level order traversal as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><p>Description:</p><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return its zigzag level order traversal as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s1;</span><br><span class="line">        stack&lt;TreeNode*&gt; s2;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">        s1.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()||!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(l%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    TreeNode* node=s1.<span class="built_in">top</span>();</span><br><span class="line">                    s1.<span class="built_in">pop</span>();</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;left) s2.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;right) s2.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    TreeNode* node=s2.<span class="built_in">top</span>();</span><br><span class="line">                    s2.<span class="built_in">pop</span>();</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;right) s1.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;left) s1.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h2><p>Description:</p><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><p>Given the below binary tree and <code>sum = 22</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Return:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">getPath</span>(res,tmp,root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;tmp, TreeNode* root, <span class="type">int</span> remain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span> &amp;&amp; root-&gt;val==remain) res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="built_in">getPath</span>(res,tmp,root-&gt;left,remain-root-&gt;val);</span><br><span class="line">        <span class="built_in">getPath</span>(res,tmp,root-&gt;right,remain-root-&gt;val);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h2><p>Description:</p><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example, given the following tree:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The flattened tree should look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right=pre;</span><br><span class="line">        root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        pre=root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h2><p>Description:</p><p>Given a binary tree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p><strong>Example:</strong></p><p>Given the following perfect binary tree,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \  / \</span><br><span class="line">4  5  6  7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>After calling your function, the tree should look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \  / \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeLinkNode</span> &#123;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   TreeLinkNode *left, *right, *next;</span><br><span class="line">   <span class="built_in">TreeLinkNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode* pre=root;</span><br><span class="line">        TreeLinkNode* cur=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;left)&#123;</span><br><span class="line">            cur=pre;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                cur-&gt;left-&gt;next=cur-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next) cur-&gt;right-&gt;next=cur-&gt;next-&gt;left;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h2><p>Description:</p><p>Given a binary tree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li></ul><p><strong>Example:</strong></p><p>Given the following binary tree,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \    \</span><br><span class="line">4   5    7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>After calling your function, the tree should look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Definition for binary tree with next pointer.*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">TreeLinkNode</span> &#123;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   TreeLinkNode *left, *right, *next;</span><br><span class="line">   <span class="built_in">TreeLinkNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode* head = <span class="literal">NULL</span>; <span class="comment">//head of the next level</span></span><br><span class="line">        TreeLinkNode* prev = <span class="literal">NULL</span>; <span class="comment">//the leading node on the next level</span></span><br><span class="line">        TreeLinkNode* cur = root;  <span class="comment">//current node of current level</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="comment">//left child</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        prev-&gt;next = cur-&gt;left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//right child</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        prev-&gt;next = cur-&gt;right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//move to next node</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            cur = head;</span><br><span class="line">            head = <span class="literal">NULL</span>;</span><br><span class="line">            prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h2><p>Description:</p><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxVal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxVal=INT_MIN;</span><br><span class="line">        <span class="built_in">maxPathSumDown</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSumDown</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">maxPathSumDown</span>(node-&gt;left));</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">maxPathSumDown</span>(node-&gt;right));</span><br><span class="line">        maxVal=<span class="built_in">max</span>(maxVal,left+right+node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a>129. Sum Root to Leaf Numbers</h2><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p><p>Find the total sum of all root-to-leaf numbers.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumNumbersHelp</span>(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbersHelp</span><span class="params">(TreeNode* node, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span> &amp;&amp; node-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> n*<span class="number">10</span>+node-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumNumbersHelp</span>(node-&gt;left,n*<span class="number">10</span>+node-&gt;val)+<span class="built_in">sumNumbersHelp</span>(node-&gt;right,n*<span class="number">10</span>+node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h2><p>Description:</p><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preHelp</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preHelp</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preHelp</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preHelp</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h2><p>Description:</p><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postHelp</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postHelp</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postHelp</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">postHelp</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a>173. Binary Search Tree Iterator</h2><p>Description:</p><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling <code>next()</code> will return the next smallest number in the BST.</p><p>**Note: **<code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">pushAll</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushAll</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;node!=<span class="literal">NULL</span>;st.<span class="built_in">push</span>(node),node=node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* tmp=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">pushAll</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h2><p>Description:</p><p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                TreeNode* tmp=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>) res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) q.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) q.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h2><p>Description:</p><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of of nodes 5 and 1 is 3.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself</span><br><span class="line">             according to the LCA definition.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>All of the nodes’ values will be unique.</li><li>p and q are different and both values will exist in the binary tree.</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> || root==p || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> !left?right:!right?left:root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. Binary Tree Inorder Traversal</h2><p>Description:</p><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* curr=root;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>()||curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(curr);</span><br><span class="line">                curr=curr-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* node=sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                curr=node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h2><p>Description:</p><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#x27;s value</span><br><span class="line">             is 5 but its right child&#x27;s value is 4.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">validate</span>(root, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validate</span><span class="params">(TreeNode* root, TreeNode* &amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">validate</span>(root-&gt;left, pre)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;val&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre=root;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">validate</span>(root-&gt;right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h2><p>Description:</p><p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><ul><li>A solution using O(<em>n</em>) space is pretty straight forward.</li><li>Could you devise a constant space solution?</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* first=<span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* second=<span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* prev = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)   first=prev;</span><br><span class="line">        <span class="keyword">if</span>(first!=<span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)   second=root;</span><br><span class="line">        prev=root;</span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的tree类算法的总结，包含了各题的solution和常用的解决方法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此类题的常用思路：&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>对比AlexNet、VGG、GoogleNet和ResNet</title>
    <link href="http://example.com/2017/10/14/%E5%AF%B9%E6%AF%94AlexNet%E3%80%81VGG%E3%80%81GoogleNet%E5%92%8CResNet/"/>
    <id>http://example.com/2017/10/14/%E5%AF%B9%E6%AF%94AlexNet%E3%80%81VGG%E3%80%81GoogleNet%E5%92%8CResNet/</id>
    <published>2017-10-14T12:08:23.000Z</published>
    <updated>2022-05-03T13:07:49.257Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天阅读了AlexNet、VGG、GoogleNet和ResNet的论文，并且对<a href="https://zxth93.github.io/2017/10/13/AlexNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/">AlexNet</a> 和<a href="https://zxth93.github.io/2017/10/11/VGGNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">VGG</a> 进行了总结。本文主要内容就是对比这四类网络结构。通过下表，我们看出这四种网络的各自的特点：</p><table><thead><tr><th align="center">模型名</th><th align="center">AlexNet</th><th align="center">VGG</th><th align="center">GoogleNet</th><th align="center">ResNet</th></tr></thead><tbody><tr><td align="center">出现时间</td><td align="center">2012</td><td align="center">2014</td><td align="center">2014</td><td align="center">2015</td></tr><tr><td align="center">层数</td><td align="center">8</td><td align="center">19</td><td align="center">22</td><td align="center">152</td></tr><tr><td align="center">Top-5错误</td><td align="center">16.4%</td><td align="center">7.3%</td><td align="center">6.7%</td><td align="center">3.57%</td></tr><tr><td align="center">Data Augmentation</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">Inception</td><td align="center">-</td><td align="center">-</td><td align="center">+</td><td align="center">-</td></tr><tr><td align="center">卷积层数</td><td align="center">5</td><td align="center">16</td><td align="center">21</td><td align="center">151</td></tr><tr><td align="center">卷积核大小</td><td align="center">11,5,3</td><td align="center">3</td><td align="center">7,1,3,5</td><td align="center">7,1,3,5</td></tr><tr><td align="center">全连接层数</td><td align="center">3</td><td align="center">3</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">Dropout</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">-</td></tr><tr><td align="center">Local Response Normalization</td><td align="center">+</td><td align="center">-</td><td align="center">+</td><td align="center">-</td></tr><tr><td align="center">Batch Normalization</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">+</td></tr></tbody></table><blockquote><p><strong>参考</strong> </p><p>论文：<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">AlexNet</a></p><p>论文：<a href="https://arxiv.org/abs/1409.1556">VGG</a></p><p>论文：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/html/Szegedy_Going_Deeper_With_2015_CVPR_paper.html">GoogleNet</a></p><p>论文：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/html/He_Deep_Residual_Learning_CVPR_2016_paper.html">ResNet</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近几天阅读了AlexNet、VGG、GoogleNet和ResNet的论文，并且对&lt;a href=&quot;https://zxth93.github.io/2017/10/13/AlexNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/&quot;&gt;Alex</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ResNet" scheme="http://example.com/tags/ResNet/"/>
    
    <category term="AlexNet" scheme="http://example.com/tags/AlexNet/"/>
    
    <category term="VGG" scheme="http://example.com/tags/VGG/"/>
    
    <category term="GoogleNet" scheme="http://example.com/tags/GoogleNet/"/>
    
  </entry>
  
  <entry>
    <title>AlexNet论文总结</title>
    <link href="http://example.com/2017/10/13/AlexNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/10/13/AlexNet%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</id>
    <published>2017-10-13T02:40:14.000Z</published>
    <updated>2022-05-03T13:05:58.206Z</updated>
    
    <content type="html"><![CDATA[<p>最近我对CNN网络结构比较感兴趣，所以阅读了AlexNet、VGGNet、ResNet等论文。本文介绍AlexNet，在ILSVRC-2012大赛中，它夺得了第一名的佳绩。本文通过宏观和微观两个角度介绍AlexNet结构。</p><h3 id="1-宏观"><a href="#1-宏观" class="headerlink" title="1. 宏观"></a>1. 宏观</h3><p>我们通过下面两个图对AlexNet有一个宏观的认识：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/alexnet1.png?raw=true"></p><p><img src="http://img.blog.csdn.net/20150908092946422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p><p>AlexNet由5层卷积，3层Max pooling，3层全连接层组成，激活函数为ReLU.</p><blockquote><p>用ReLU代替了传统的tanh或者logistic,好处有：收敛速度快。</p></blockquote><h3 id="2-微观"><a href="#2-微观" class="headerlink" title="2. 微观"></a>2. 微观</h3><ul><li><p>硬件平台</p><blockquote><p>两台GTX-530 3GB GPU，训练时间5-6天</p></blockquote></li></ul><ul><li><p>数据预处理</p><blockquote><p>每个像素<strong>减去平均活跃度（像素均值）</strong> </p></blockquote></li><li><p>输入</p><blockquote><p>图像规定大小：256*256</p></blockquote></li><li><p>卷积规格</p><blockquote><p>11 * 11 with stride 4, 5 * 5, 3 * 3</p><p>其中第二、第四和第五层卷积只连接同一GPU上前一层网络</p><p>第三层卷积是跨GPU连接前一层网络</p></blockquote></li><li><p>Max pooling规格</p><blockquote><p>overlapping pooling: 3 * 3 with stride 2</p></blockquote></li><li><p>训练</p><blockquote><p>优化器：SGD+momentum（0.9）</p><p>batch size：128</p><p>weight decay：0.0005</p><p>权重初始化：随机选取自N(0, 0.01)</p><p>偏置初始化：第2、4、5层卷积和全连接层设置为1，其他层为0</p></blockquote></li><li><p>减少过拟合</p><blockquote><p><strong>数据增强：</strong> </p><ol><li>水平反转：对图像先进行水平反转，然后随机裁剪为224*224的图像</li><li>改变训练图像中RGB通道的强度。具体来说，遍及整个ImageNet训练集的RGB像素值集合中执行PCA。</li></ol><p><strong>Dropout</strong> </p></blockquote></li></ul><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h3><p><strong>Local Response Normalization:</strong> 就是利用临近的数据做归一化，提高泛化问题。</p><blockquote><p>参考</p><p>论文原文：<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">ImageNet Classification with Deep Convolutional Neural Networks</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近我对CNN网络结构比较感兴趣，所以阅读了AlexNet、VGGNet、ResNet等论文。本文介绍AlexNet，在ILSVRC-2012大赛中，它夺得了第一名的佳绩。本文通过宏观和微观两个角度介绍AlexNet结构。&lt;/p&gt;
&lt;h3 id=&quot;1-宏观&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="AlexNet" scheme="http://example.com/tags/AlexNet/"/>
    
  </entry>
  
  <entry>
    <title>VGGNet论文笔记</title>
    <link href="http://example.com/2017/10/11/VGGNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2017/10/11/VGGNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2017-10-11T10:47:47.000Z</published>
    <updated>2022-05-03T13:07:39.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h3><p>VGGNet是由牛津大学和Google DeepMind团队提出的，他们在ILSVRC-2014定位任务夺得第一名，分类任务获得第二名（GoogleNet是分类任务的第一名）。VGGNet具有很好的泛化能力，在其他数据集上也有较好的表现。</p><p>卷积网络现在在大规模图像和视频识别中取得了巨大的成功，成为了计算机视觉领域的常用工具。AlexNet是具有重要意义的网络结构，有很多人企图改进ALexNet，比如：ZFNet。ZFNet在第一卷积层使用更小的<strong>卷积</strong>(receptive window size)和更小的<strong>步长</strong>(stride)，而VGGNet强调了卷积神经网络设计中另一个重要方面—深度。并且VGGNet在所有层使用3*3的卷积核。</p><h3 id="2-CONVNET-CONFIGURATIONS"><a href="#2-CONVNET-CONFIGURATIONS" class="headerlink" title="2 CONVNET CONFIGURATIONS"></a>2 CONVNET CONFIGURATIONS</h3><p>为了公平测试深度带来的性能提升，VGGNet所有层的配置都遵循了同样的原则。</p><h4 id="2-1-ARCHITECHTURE"><a href="#2-1-ARCHITECHTURE" class="headerlink" title="2.1 ARCHITECHTURE"></a>2.1 ARCHITECHTURE</h4><ul><li>唯一的<strong>预处理</strong> ：训练集中的每个像素上减去RGB的<strong>均值</strong> ；</li><li>训练时，<strong>输入</strong>是固定大小的224 * 224 RGB图像；</li><li>使用了非常小的<strong>感受野</strong>(receptive field)：3 * 3，甚至有的地方使用1 * 1的卷积,这种1 * 1的卷积可以被看做是对输入通道(input channel)的线性变换，卷积步长是1个像素；</li><li><strong>池化层</strong> 采用max-pooling,共有5层，max-pooling的窗口是2 * 2，步长是2；</li><li>一系列卷积层之后跟着<strong>全连接层</strong>(fully-connected layers)。前两个全连接层均有4096个通道。第三个全连接层有1000个通道，用来分类。所有网络的全连接层配置相同。</li><li>最后一层是soft-max层</li></ul><blockquote><p><strong>注：</strong> 所有隐层使用激活函数是<strong>ReLu</strong> .VGGNet不使用局部响应标准化(LRN)，这种标准化并不能在ILSVRC数据集上提升性能，却导致更多的内存消耗和计算时间。</p></blockquote><h4 id="2-2-CONFIGURATIONS"><a href="#2-2-CONFIGURATIONS" class="headerlink" title="2.2 CONFIGURATIONS"></a>2.2 CONFIGURATIONS</h4><p>Table1给出了所有的网络配置</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg1.png?raw=true"></p><h4 id="2-3-DISCUSSION"><a href="#2-3-DISCUSSION" class="headerlink" title="2.3 DISCUSSION"></a>2.3 DISCUSSION</h4><p>相比于AlexNet和ZFNet，VGGNet在网络中使用<strong>很小的卷积</strong>。AlexNet和ZFNet在第一个卷积层的卷积分别是11 * 11 with stride 4和7 * 7 with stride 2。</p><p>VGGNet使用三个3 * 3卷积而不是一个7 * 7的卷积的优势有两点：一，<strong>包含三个ReLu层而不是一个</strong>，使决策函数更有判别性；二，<strong>减少了参数</strong>。比如输入输出都是C个通道，使用3 * 3的3个卷积层需要3（3 * 3 * C * C）=27 * C * C,使用7 * 7的1个卷积层需要7 * 7 * C * C=49C * C。这可看为是对7 * 7卷积施加一种正则化，使它分解为3个3 * 3的卷积。</p><p><strong>1*1卷积</strong>层主要是为了增加决策函数的<strong>非线性</strong>，而不影响卷积层的感受野。虽然1 * 1的卷积操作是线性的，但是ReLu增加了非线性。</p><p>GoogleNet采用了更深更复杂的网络结构（22层），多种卷积核（1 * 1，3 * 3， 5 * 5），并且在第一层中特征比VGGNet更少。</p><h3 id="3-CLASSIFICATION-FRAMEWORK"><a href="#3-CLASSIFICATION-FRAMEWORK" class="headerlink" title="3 CLASSIFICATION FRAMEWORK"></a>3 CLASSIFICATION FRAMEWORK</h3><h4 id="3-1-TRAINING"><a href="#3-1-TRAINING" class="headerlink" title="3.1 TRAINING"></a>3.1 TRAINING</h4><ul><li>优化函数：SGD+momentum（0.9）</li><li>batch size：256</li><li>正则：采用L2正则化，weight decay是5e-4；dropout在前两个全连接层后，p=0.5。</li><li>参数初始化：随机初始化，权重w从N(0，0.01)中采样，偏差bias初始化为0。</li><li>为了获得224*224的输入图像，要在每个sgd迭代中对每张重新缩放(rescale)的图像随机裁剪。为了增强数据集，裁剪的图像还要随机水平翻转和RGB色彩偏移。</li></ul><blockquote><p>尽管相比于AlexNet网络更深，参数更多，但是我们推测VGGNet在更少的周期内就能收敛，原因有二：一，更大的深度和更小的卷积带来<strong>隐式的正则化</strong>；二，一些层的预训练。</p></blockquote><h4 id="3-2-TESTING"><a href="#3-2-TESTING" class="headerlink" title="3.2 TESTING"></a>3.2 TESTING</h4><p>测试阶段步骤：</p><ol><li>对输入图像各向同性地重缩放到一个预定义的最小图像边的尺寸Q；</li><li>网络密集地应用在重缩放后的测试图像上。也就是说全连接层转化为卷积层（第一个全连接层转化为7 * 7的卷积层，后两个全连接层转化为1 * 1的卷积层） ，然后将转化后的全连接层应用在整张图像上。结果就是一个类别分数图(class score map)，其通道数等于类别数量，依赖于图像尺寸，具有不同的空间分辨率；</li><li>为了获得固定尺寸的类别分数向量(class score vector)，对class score map进行空间平均化处理(sum-pooled)。</li></ol><h4 id="3-3-IMPLEMENTATION-DETAILS"><a href="#3-3-IMPLEMENTATION-DETAILS" class="headerlink" title="3.3 IMPLEMENTATION DETAILS"></a>3.3 IMPLEMENTATION DETAILS</h4><p>基于C++ Caffe, 在4个Titan GPU上训练了2-3周。</p><h3 id="4-CLASSIFICATION-EXPERIMENTS"><a href="#4-CLASSIFICATION-EXPERIMENTS" class="headerlink" title="4 CLASSIFICATION EXPERIMENTS"></a>4 CLASSIFICATION EXPERIMENTS</h3><h4 id="4-1-SINGLE-SCALE-EVALUATION"><a href="#4-1-SINGLE-SCALE-EVALUATION" class="headerlink" title="4.1 SINGLE SCALE EVALUATION"></a>4.1 SINGLE SCALE EVALUATION</h4><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg2.png?raw=true"></p><p>通过分析Table3结果，得出如下结论：</p><ol><li>我们发现使用local response normalization(A-LRN)并不能改善A网络性能。</li><li>分类误差随着深度增加而降低。</li><li>在训练时采用图像尺度抖动(scale jittering)可以改善图像分类效果。</li></ol><h4 id="4-2-MULTI-SCALE-EVALUATION"><a href="#4-2-MULTI-SCALE-EVALUATION" class="headerlink" title="4.2 MULTI-SCALE EVALUATION"></a>4.2 MULTI-SCALE EVALUATION</h4><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg3.png?raw=true"></p><p>通过分析Table4结果，得出如下结论：</p><ol><li>相对于单一尺度评估，多尺度评估提高了分类精度。 </li><li>在训练时采用图像尺度抖动(scale jittering)可以改善图像分类效果。</li></ol><h4 id="4-3-MULTI-CROP-EVALUATION"><a href="#4-3-MULTI-CROP-EVALUATION" class="headerlink" title="4.3 MULTI-CROP EVALUATION"></a>4.3 MULTI-CROP EVALUATION</h4><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg4.png?raw=true"></p><p>多裁剪(multi-crop)评估比起密集(dense)评估，效果更好。而且两者具有互补作用，结合两种方式，效果更好。</p><h4 id="4-4-CONVNET-FUSION"><a href="#4-4-CONVNET-FUSION" class="headerlink" title="4.4 CONVNET FUSION"></a>4.4 CONVNET FUSION</h4><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg5.png?raw=true"></p><p>通过分析Table6结果，得出如下结论：</p><ol><li>如果结合多个卷积网络的sofamax输出，分类效果会更好。 </li><li>在ILSVRC-2014中，我们结合7个网络，实现测试误差7.3%。之后，结合最好的两个模型(D&amp;E)并使用密集评估(dense evaluation)，测试误差降低到7.0%，而使用密集评估和多裁剪评估相结合，测试误差为6.8%。最好的单一模型验证误差为7.1%。 </li></ol><h4 id="4-5-COMPARISON-WITH-THE-STATE-OF-THE-ART"><a href="#4-5-COMPARISON-WITH-THE-STATE-OF-THE-ART" class="headerlink" title="4.5 COMPARISON WITH THE STATE OF THE ART"></a>4.5 COMPARISON WITH THE STATE OF THE ART</h4><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/vgg6.png?raw=true"></p><p>与ILSVRC-2012和ILSVRC-2013最好结果相比，VGGNet优势很大。与GoogLeNet对比，虽然7个网络集成效果不如GoogLeNet，但是单一网络测试误差好一些，而且只用2个网络集成效果与GoogLeNet的7网络集成差不多。</p><h3 id="5-CONCLUSION"><a href="#5-CONCLUSION" class="headerlink" title="5 CONCLUSION"></a>5 CONCLUSION</h3><p>我们将卷积网络深度设置为19，相比于其他网络，VGGNet效果更好，并且在其他不同的任务或数据集上有很好的泛化能力。</p><blockquote><p><strong>参考</strong></p><p>论文原文：<a href="https://arxiv.org/pdf/1409.1556.pdf">VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION</a></p><p><a href="http://blog.csdn.net/muyiyushan/article/details/62895202">http://blog.csdn.net/muyiyushan/article/details/62895202</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-INTRODUCTION&quot;&gt;&lt;a href=&quot;#1-INTRODUCTION&quot; class=&quot;headerlink&quot; title=&quot;1 INTRODUCTION&quot;&gt;&lt;/a&gt;1 INTRODUCTION&lt;/h3&gt;&lt;p&gt;VGGNet是由牛津大学和Google De</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="VGGNet" scheme="http://example.com/tags/VGGNet/"/>
    
  </entry>
  
  <entry>
    <title>虚函数的作用</title>
    <link href="http://example.com/2017/10/10/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2017/10/10/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2017-10-10T10:37:50.000Z</published>
    <updated>2022-05-03T13:07:57.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1. 虚函数"></a>1. 虚函数</h3><blockquote><p><strong>虚函数</strong> 的目的是为了允许用基类的指针调用子类的虚函数，是<strong>必须实现</strong> 的函数。虚函数是C++实现<strong>动态单分派子类型多态</strong> 的方式：</p><ul><li>动态：在运行时决定的</li><li>单分派：基于一个类型去选择调用哪个函数</li><li>子类型多态：以子类-父类关系实现多态</li></ul></blockquote><p>下面通过一个例子来具体说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虚函数只能借助于指针或者引用来达到多态的目的，核心理念就是通过基类访问派生类定义的函数。</p></blockquote><h3 id="2-纯虚函数"><a href="#2-纯虚函数" class="headerlink" title="2. 纯虚函数"></a>2. 纯虚函数</h3><blockquote><p><strong>纯虚函数</strong> 是在基类中定义，但<strong>不能实现</strong> ，只能由其派生类自己定义实现此函数。形式如下：</p><p>virtual ReturnType Function()<strong>=0</strong> </p></blockquote><p>引入纯虚函数的好处：</p><ul><li>纯虚函数定义了一个<strong>接口</strong> ，起到了规范作用</li><li>包含纯虚函数的类是抽象类，抽象类是不能被实例化的。如果派生类没有实现纯虚函数，那么此派生类也是抽象类；如果派生类给出了基类中的纯虚函数的实现，那么此派生类就不是抽象类。</li></ul><blockquote><p><strong>注：</strong> </p><ul><li>析构函数是虚函数；</li><li>友元函数不是虚函数，但它可以通过调用虚函数来解决友元的虚拟问题。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-虚函数&quot;&gt;&lt;a href=&quot;#1-虚函数&quot; class=&quot;headerlink&quot; title=&quot;1. 虚函数&quot;&gt;&lt;/a&gt;1. 虚函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虚函数&lt;/strong&gt; 的目的是为了允许用基类的指针调用子类的虚函数</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="虚函数" scheme="http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-math类总结(会持续更新...)</title>
    <link href="http://example.com/2017/10/07/LeetCode-math%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/10/07/LeetCode-math%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2017-10-07T11:21:31.000Z</published>
    <updated>2022-05-03T13:07:29.502Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的math类算法的总结，包含了各题的solution和常用的解决方法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><h2 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h2><p><strong>Description:</strong></p><p>Count the number of prime numbers less than a non-negative number, <strong>n</strong>.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p><p>解题思路：本题利用了素数的概念和<strong>打表法</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">check</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//bool []check = new bool[n];</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;i*j&lt;n;j++)&#123;</span><br><span class="line">                    check[j*i]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="263-Ugly-Number"><a href="#263-Ugly-Number" class="headerlink" title="263. Ugly Number"></a>263. Ugly Number</h2><p>Description:Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p><p>Note that <code>1</code> is typically treated as an ugly number.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><p>解题思路：直接除以2，3，5，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                num /= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                num /= <span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                num /= <span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="400-Nth-Digit"><a href="#400-Nth-Digit" class="headerlink" title="400. Nth Digit"></a>400. Nth Digit</h2><p>Description:Find the <em>n</em>th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …</p><p><strong>Note:</strong><br><em>n</em> is positive and will fit within the range of a 32-bit signed integer (<em>n</em> &lt; 231).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> base = <span class="number">9</span>;</span><br><span class="line">        <span class="type">long</span> digits = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n-base*digits &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n -= base*digits;</span><br><span class="line">            base *=<span class="number">10</span>;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> index = n%digits;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            index=digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;digits; i++)&#123;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        num += (index==digits) ? n/digits - <span class="number">1</span> : n/digits;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index; i&lt;digits; i++)&#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num%<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="633-Sum-of-Square-Numbers"><a href="#633-Sum-of-Square-Numbers" class="headerlink" title="633. Sum of Square Numbers"></a>633. Sum of Square Numbers</h2><p>Description:Given a non-negative integer <code>c</code>, your task is to decide whether there’re two integers <code>a</code> and <code>b</code> such that a2 + b2 = c.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p>解题思路：使用双指针逼近，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> r = (<span class="type">int</span>)<span class="built_in">sqrt</span>(c);</span><br><span class="line">      <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">temp = l*l + r*r;</span><br><span class="line">          <span class="keyword">if</span>(temp &lt; c)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; c)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="367-Valid-Perfect-Square"><a href="#367-Valid-Perfect-Square" class="headerlink" title="367. Valid Perfect Square"></a>367. Valid Perfect Square</h2><p>Description:</p><p>Given a positive integer <em>num</em>, write a function which returns True if <em>num</em> is a perfect square else False.</p><p><strong>Note:</strong> <strong>Do not</strong> use any built-in library function such as <code>sqrt</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Returns: True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Returns: False</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Credits:</strong><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; num&gt;<span class="number">0</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare2</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = num;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> temp = mid*mid;</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; num)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; num)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a>172. Factorial Trailing Zeroes</h2><p>Description:</p><p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p><p>**Note: **Your solution should be in logarithmic time complexity.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">            result += n/x;</span><br><span class="line">            x *=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的math类算法的总结，包含了各题的solution和常用的解决方法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;204-Coun</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-string类总结（会持续更新...）</title>
    <link href="http://example.com/2017/09/29/LeetCode-string%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2017/09/29/LeetCode-string%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2017-09-29T09:03:09.000Z</published>
    <updated>2022-05-03T13:07:31.211Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对leetcode中的string类算法的总结，包含了各题的solution和常用的解决方法。</p><p>相关源码：<a href="https://github.com/zxth93/leetcode">code</a></p><h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h2><p>Description:</p><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is <em>not</em> a palindrome.</p><p><strong>Note:</strong><br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p><p>For the purpose of this problem, we define empty string as valid palindrome.</p><p>解题思路：本题判读回文，看到回文我们通常会直接想到使用<strong>栈</strong> ，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; bag;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                str += <span class="built_in">char</span>(s[i]+<span class="number">32</span>);</span><br><span class="line">                bag.<span class="built_in">push</span>(s[i]+<span class="number">32</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)||(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                str += s[i];</span><br><span class="line">                bag.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = bag.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//if(len==1 &amp;&amp; s.size()&gt;1) return false;</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != bag.<span class="built_in">top</span>()) <span class="keyword">break</span>;</span><br><span class="line">            count++;</span><br><span class="line">            bag.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="168. Excel Sheet Column Title"></a>168. Excel Sheet Column Title</h2><p>Description:</p><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p><p>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br></pre></td></tr></table></figure><p>解题思路：本题考察进制，需要注意的一点是：此题中不是从0才是，而是从1开始。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">27</span>)&#123;</span><br><span class="line">            s+=<span class="built_in">char</span>(<span class="number">64</span>+n);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = n%<span class="number">26</span>;</span><br><span class="line">        n /= <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            x=<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">convertToTitle</span>(n) + <span class="built_in">char</span>(<span class="number">64</span>+x);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="459-Repeated-Substring-Pattern"><a href="#459-Repeated-Substring-Pattern" class="headerlink" title="459. Repeated Substring Pattern"></a>459. Repeated Substring Pattern</h2><p>Description:</p><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&#x27;s the substring &quot;ab&quot; twice.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">Output: False</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: It&#x27;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure><p>解题思路：本题判断字符串是否是由重复子串组成的，这题有个trick：将原始串扩增一倍，去掉首尾各一个字符，判断此串是否含有原始串，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string temp = s+s;</span><br><span class="line">        temp = temp.<span class="built_in">substr</span>(<span class="number">1</span>,temp.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">find</span>(s)!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="606-Construct-String-from-Binary-Tree"><a href="#606-Construct-String-from-Binary-Tree" class="headerlink" title="606. Construct String from Binary Tree"></a>606. Construct String from Binary Tree</h2><p>Description:</p><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p><p>The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, </span><br><span class="line">but you need to omit all the unnecessary empty parenthesis pairs. </span><br><span class="line">And it will be &quot;1(2(4))(3)&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Almost the same as the first example, </span><br><span class="line">except we can&#x27;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</span><br></pre></td></tr></table></figure><p>解题思路：本题涉及到了树，我们首先确定树的遍历方式，本题适合前序遍历，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      result += <span class="built_in">to_string</span>(t-&gt;val);</span><br><span class="line">      string left = <span class="built_in">tree2str</span>(t-&gt;left);</span><br><span class="line">      string right = <span class="built_in">tree2str</span>(t-&gt;right);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(left==<span class="string">&quot;&quot;</span> &amp;&amp; right==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">if</span>(left==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> result+<span class="string">&quot;()&quot;</span>+<span class="string">&quot;(&quot;</span>+right+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span>(right==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> result+<span class="string">&quot;(&quot;</span>+right+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> result+<span class="string">&quot;(&quot;</span>+left+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;(&quot;</span>+right+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="557-Reverse-Words-in-a-String-III"><a href="#557-Reverse-Words-in-a-String-III" class="headerlink" title="557. Reverse Words in a String III"></a>557. Reverse Words in a String III</h2><p>Description:Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Let&#x27;s take LeetCode contest&quot;</span><br><span class="line">Output: &quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> In the string, each word is separated by single space and there will not be any extra space in the string.</p><p>解题思路：本题要求反转字符串，很自然的会想到用<strong>栈</strong> ，但是本题提示不能使用额外的空间，那只能STL中的方法reverse(), 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;   <span class="comment">// when i is a non-space</span></span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; s.<span class="built_in">length</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>; j++) &#123; &#125; <span class="comment">// move j to the next space</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h2><p>Description:</p><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital if it has more than one letter, like “Google”.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;word.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i]&lt;<span class="number">97</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==word.<span class="built_in">size</span>() || count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> word[<span class="number">0</span>] &lt; <span class="number">97</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a>392. Is Subsequence</h2><p>Description:</p><p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p><p>You may assume that there is only lower case English letters in both <strong>s</strong> and <strong>t</strong>. <strong>t</strong> is potentially a very long (length ~= 500,000) string, and <strong>s</strong>is a short string (&lt;=100).</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p><p><strong>Example 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>Return <code>true</code>.</p><p><strong>Example 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p><p>Return <code>false</code>.</p><p><strong>Follow up:</strong><br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/pbrother/">@pbrother</a> for adding this problem and creating all test cases.</p><p>解题思路：代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> indexT=<span class="number">0</span>, indexS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(indexT&lt;t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[indexT]==s[indexS])&#123;</span><br><span class="line">                indexS++;</span><br><span class="line">                <span class="keyword">if</span>(indexS==s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexT++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是对leetcode中的string类算法的总结，包含了各题的solution和常用的解决方法。&lt;/p&gt;
&lt;p&gt;相关源码：&lt;a href=&quot;https://github.com/zxth93/leetcode&quot;&gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;125-Va</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost算法原理</title>
    <link href="http://example.com/2017/09/29/XGBoost%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2017/09/29/XGBoost%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2017-09-29T01:43:26.000Z</published>
    <updated>2022-05-03T13:07:47.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>XGBoost</strong>是数据挖掘类竞赛中经常使用的一大利器，它帮助选手在Kaggle、阿里天池大数据比赛等比赛取得了很好的成绩。XGBoost被很多人使用，但很少人知道其原理，前几天看了一下陈天奇大神的论文有了更多的理解。XGBoost是基于<strong>GBDT(Gradient Boosting Decision Tree)</strong> 改进而来的，本文将对XGBoost算法原理进行介绍，主要通过以下几个部分进行介绍：boosted trees、目标函数正则化、节点切分算法。</p></blockquote><blockquote><p><strong>注：</strong> 本文假设读者理解回归树算法、泰勒公式、梯度下降法和牛顿法</p></blockquote><h3 id="1-Boosted-trees"><a href="#1-Boosted-trees" class="headerlink" title="1. Boosted trees"></a>1. Boosted trees</h3><p>Boosted trees是一种集成方法，Boosting算法是一种加法模型(additive training)，定义如下：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/boostedtreedefine1.png?raw=true"></p><p>这里K是树的棵数，f(x)是函数空间中的一个函数：<img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/boostedtreedefine2.png?raw=true"></p><p>q(x)表示将样本x分到了某个叶子节点上，w是叶子节点的分数（leaf score）</p><p>下面通过一个具体的例子来说明：预测一个人是否喜欢电脑游戏，下图表明小男孩更喜欢打游戏。</p><p><img src="https://raw.githubusercontent.com/dmlc/web-data/master/xgboost/model/twocart.png"></p><h3 id="2-目标函数正则化"><a href="#2-目标函数正则化" class="headerlink" title="2. 目标函数正则化"></a>2. 目标函数正则化</h3><p>XGBoost使用的目标函数如下：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostobjectivefunc.png?raw=true"></p><p>我们可以看出XGBoost在GBDT的误差函数基础上加入了L1和L2正则项，其中Loss函数可以是平方损失或逻辑损失，T代表叶子节点数，w代表叶子节点的分数。加入正则项的好处是防止过拟合，这个好处是由两方面体现的：一是预剪枝，因为正则项中有限定叶子节点数；二是正则项里leaf scroe的L2模平方的系数，对leaf scroe做了平滑。</p><p>接下来我们对目标函数进行目标函数的求解：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostOF2.png?raw=true"></p><p>该目标函数表示：第i样本的第t次迭代误差函数，后面的推导基于上式。这种学习方式已经从函数空间转到了函数空间：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti1.png?raw=true"></p><p>下面对目标函数进行泰勒公式二级展开、化简：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti2.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti3.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti4.png?raw=true"></p><p>如果确定了树的结构，为了使目标函数最小，可以令其导数为0，解得每个叶节点的最优预测分数为：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti5.png?raw=true"></p><p>代入目标函数，解得最小损失为：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostopti6.png?raw=true"></p><h3 id="3-节点切分算法"><a href="#3-节点切分算法" class="headerlink" title="3. 节点切分算法"></a>3. 节点切分算法</h3><p>我们已经确定了损失函数，以及最优解，接下来我们需要缺点树的结构，即如何选出最优分裂节点。我们可以参照决策树算法：ID3选择信息增益为切分准则，C4.5选择信息增益率为切分准则。XGBoost基本思想是和决策树一致的：贪心法枚举所有节点，计算各个节点分裂前后的信息增益，选出信息增益最大的。下面是XGBoost信息增益的定义：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostsplit1.png?raw=true"></p><p>XGBoost提供了两种切分算法：精确贪心算法和近似算法</p><blockquote><p><strong>精确贪心算法：</strong> 在所有特征上暴力枚举所有可能的切分点，算法如下：</p></blockquote><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostsplitalg1.png?raw=true"></p><blockquote><p><strong>近似算法：</strong> 其基本思想：首先根据特征的统计分布（分位数）选出候选切分点；然后对于连续属性特征，根据候选切分点进行离散化；最后会从这些候选切分点中选出最优的。近似算法提出了两种版本：global variant和local variant. global variant在树初始化时就确定了候选切分点；local variant是在每次节点分裂后重新选出候选点。论文中的实验表明：在同等精度下，相对于global variant, local variant需要的候选切分点更少。近似算法如下：</p></blockquote><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostsplitalg2.png?raw=true"></p><p>近似算法举例：三分位数</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostquantile.png?raw=true"></p><blockquote><p><strong>注：</strong> 近似算法中使用到了分位数，关于分位数的选取，论文提出了一种算法<strong>Weighted Quantile Sketch</strong> 。XGBoost不是按照样本个数进行分位，而是以二阶导数为权重。</p></blockquote><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostquantile2.png?raw=true"></p><blockquote><p>Q: 为什么使用hi加权？</p><p>A: 比较直观的解释是因为目标函数可以化简为如下形式：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostweight.png?raw=true"></p></blockquote><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><blockquote><p>在实际工作中，大多数输入是稀疏的。造成稀疏的原因有很多种，比如：缺失值、one-hot编码等。因此，论文提出为树中的节点设置一个默认方向来应对稀疏输入。论文实验表明<strong>稀疏感知算法</strong> 要比传统方法快50倍，算法如下：</p></blockquote><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostsparse.png?raw=true"></p><p>下面通过例子具体说明：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/xgboostsparsedemo.png?raw=true"></p><blockquote><p><strong>注：</strong> 红色路径代表默认方向</p></blockquote><blockquote><p><strong>Shrinkage:</strong> 可以理解为学习率，算法每次迭代后会乘这个系数；</p><p><strong>列采样：</strong> 降低过拟合，论文实验表明列采样比行采样效果好。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://arxiv.org/pdf/1603.02754v1.pdf">XGBoost: A Scalable Tree Boosting System</a></li><li><a href="https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf">Introduction to Boosted Trees</a></li><li><a href="https://tianchi.aliyun.com/competition/new_articleDetail.html?spm=5176.9876270.0.0.54f0faeelrqguX&raceId=&postsId=2781">Wepon的GBDT算法原理与系统设计简介PPT</a></li><li><a href="http://www.flickering.cn/machine_learning/2016/08/gbdt%E8%AF%A6%E8%A7%A3%E4%B8%8A-%E7%90%86%E8%AE%BA/">GBDT详解，火光摇曳</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;XGBoost&lt;/strong&gt;是数据挖掘类竞赛中经常使用的一大利器，它帮助选手在Kaggle、阿里天池大数据比赛等比赛取得了很好的成绩。XGBoost被很多人使用，但很少人知道其原理，前几天看了一下陈天奇大神的论文有了更多的理解。</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="XGBoost" scheme="http://example.com/tags/XGBoost/"/>
    
    <category term="GBDT" scheme="http://example.com/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>KL散度、JS散度、Wasserstein距离</title>
    <link href="http://example.com/2017/09/27/KL%E6%95%A3%E5%BA%A6JS%E6%95%A3%E5%BA%A6Wasserstein%E8%B7%9D%E7%A6%BB/"/>
    <id>http://example.com/2017/09/27/KL%E6%95%A3%E5%BA%A6JS%E6%95%A3%E5%BA%A6Wasserstein%E8%B7%9D%E7%A6%BB/</id>
    <published>2017-09-27T02:26:28.000Z</published>
    <updated>2022-05-03T13:06:54.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-KL散度"><a href="#1-KL散度" class="headerlink" title="1. KL散度"></a>1. KL散度</h3><blockquote><p><strong>KL散度</strong>又称为<strong>相对熵</strong>，信息散度，信息增益。KL散度是是两个概率分布P和Q <strong>差别</strong>的非对称性的度量。 KL散度是用来 度量使用基于Q的编码来编码来自P的样本平均所需的额外的位元数。 典型情况下，P表示数据的真实分布，Q表示数据的理论分布，模型分布，或P的近似分布。</p></blockquote><p>定义如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3596589-dc6bdef12f91d925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>因为对数函数是凸函数，所以KL散度的值为非负数。</p><blockquote><p>有时会将KL散度称为KL距离，但它并不满足距离的性质：</p><ol><li>KL散度不是对称的；</li><li>KL散度不满足三角不等式。</li></ol></blockquote><h3 id="2-JS散度-Jensen-Shannon"><a href="#2-JS散度-Jensen-Shannon" class="headerlink" title="2. JS散度(Jensen-Shannon)"></a>2. JS散度(Jensen-Shannon)</h3><blockquote><p><strong>JS散度</strong>度量了两个概率分布的相似度，基于KL散度的变体，解决了KL散度非对称的问题。一般地，JS散度是对称的，其取值是0到1之间。定义如下：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3596589-26065ae8c3b8b87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>KL散度和JS散度度量的时候有一个问题：</p><p>如果两个分配P,Q离得很远，完全没有重叠的时候，那么KL散度值是没有意义的，而JS散度值是一个常数。这在学习算法中是比较致命的，这就意味这这一点的梯度为0。梯度消失了。</p></blockquote><h3 id="3-Wasserstein距离"><a href="#3-Wasserstein距离" class="headerlink" title="3. Wasserstein距离"></a>3. Wasserstein距离</h3><blockquote><p><strong>Wasserstein距离</strong>度量两个概率分布之间的距离，定义如下：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3596589-72a9092dd247615f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>Π(P1,P2)是P1和P2分布组合起来的所有可能的联合分布的集合。对于每一个可能的联合分布γ，可以从中采样(x,y)∼γ得到一个样本x和y，并计算出这对样本的距离||x−y||，所以可以计算该联合分布γ下，样本对距离的期望值E(x,y)∼γ[||x−y||]。在所有可能的联合分布中能够对这个期望值取到的下界infγ∼Π(P1,P2)E(x,y)∼γ[||x−y||]就是Wasserstein距离。</p><p>直观上可以把E(x,y)∼γ[||x−y||]理解为在γ这个路径规划下把土堆P1挪到土堆P2所需要的消耗。而Wasserstein距离就是在最优路径规划下的最小消耗。所以Wesserstein距离又叫Earth-Mover距离。</p><p>Wessertein距离相比KL散度和JS散度的<strong>优势</strong>在于：即使两个分布的支撑集没有重叠或者重叠非常少，仍然能反映两个分布的远近。而JS散度在此情况下是常量，KL散度可能无意义。</p><blockquote><p>References:</p><ol><li>维基百科<a href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E5%AF%B9%E7%86%B5">KL散度</a></li><li>维基百科<a href="https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence">JS散度</a></li><li>维基百科<a href="https://en.wikipedia.org/wiki/Wasserstein_metric">Wasserstein距离</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-KL散度&quot;&gt;&lt;a href=&quot;#1-KL散度&quot; class=&quot;headerlink&quot; title=&quot;1. KL散度&quot;&gt;&lt;/a&gt;1. KL散度&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;KL散度&lt;/strong&gt;又称为&lt;strong&gt;相对熵&lt;/st</summary>
      
    
    
    
    <category term="数学知识" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="信息论" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>自编码器</title>
    <link href="http://example.com/2017/09/19/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://example.com/2017/09/19/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/</id>
    <published>2017-09-19T02:21:59.000Z</published>
    <updated>2022-05-03T13:08:01.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>自编码器（auto-encoder）</strong>是神经网络的一种，经过训练后能尝试将输入复制到输出。自编码器内部有一个隐藏层h,可以产生<strong>编码</strong>表示输入。该网络可以看作由两个部分组成：一个由函数h=f(x)表示的编码器和一个生成重构的解码器r=g(h)。我们会将自编码器设计成输入到输出近似相等，通常需要向自编码器强加一些一些约束，使它只能近似地复制。这些约束强制模型考虑输入数据的哪些部分需要被优先复制，因此它往往能学习到数据的有用特性。传统自编码器被用于降维或特征学习。</p><h3 id="1-欠完备自编码器"><a href="#1-欠完备自编码器" class="headerlink" title="1. 欠完备自编码器"></a>1. 欠完备自编码器</h3><p>我们通常不关心解码器的输出，一般希望通过训练自编码器对输入进行复制而使h获得有用特性。从自编码器获得有用特征的一种方法是限制h的维度比x小，这种编码维度小于输入维度的自编码器称为<strong>欠完备</strong>自编码器。学习欠完备的表示将强制自编码器捕捉训练数据中最显著的特征。</p><p>拥有非线性编码器函数f 和非线性解码器函数g 的自编码器能够学习出更强大的PCA 非线性推广。不幸的是，如果编码器和解码器被赋予过大的容量，自编码器会执行复制任务而捕捉不到任何有关数据分布的有用信息。</p><h3 id="2-正则自编码器"><a href="#2-正则自编码器" class="headerlink" title="2. 正则自编码器"></a>2. 正则自编码器</h3><p>理想情况下，根据要建模的数据分布的复杂性，选择合适的编码维数和编码器、解码器容量，就可以成功训练任意架构的自编码器。正则自编码器提供这样的能力。正则自编码器使用的损失函数可以鼓励模型学习其他特性（除了将输入复制到输出），而不必限制使用浅层的编码器和解码器以及小的编码维数来限制模型的容量。<br>这些特性包括稀疏表示、表示的小导数、以及对噪声或输入缺失的鲁棒性。即使模型容量大到足以学习一个无意义的恒等函数，非线性且过完备的正则自编码器仍然能够从数据中学到一些关于数据分布的有用信息。</p><ul><li><p><strong>稀疏自编码器</strong></p><p>稀疏自编码器简单地在训练时结合编码层的稀疏惩罚项和重构误差：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/autoencoder.png?raw=true"></p><p>其中g(h)是解码器输出，通常h是编码器的输出，即h=f(x)。</p><p>稀疏自编码器一般用来学习特征，以便用于像分类这样的任务。稀疏正则化的自编码器必须反映训练数据集的独特统计特征，而不是简单地充当恒等函数。以这种方式训练，执行附带稀疏惩罚的复制任务可以得到能学习有用特征的模型。</p><p>我们可以认为整个稀疏自编码器框架是对带有潜变量的生成模型的近似最大似然训练，而不将稀疏惩罚视为复制任务的正则化。</p></li><li><p><strong>去噪自编码器</strong></p><p>去噪自编码器（denoising autoencoder, DAE）最小化</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/autoencoder2.png?raw=true"></p><p>其中x~是被某种噪声损坏的x的副本。因此去噪自编码器必须撤销这些损坏，而不是简单地复制输入。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/autoencoder3.png?raw=true"></p></li></ul><h3 id="3-表示能力、层的大小和深度"><a href="#3-表示能力、层的大小和深度" class="headerlink" title="3. 表示能力、层的大小和深度"></a>3. 表示能力、层的大小和深度</h3><p>自编码器通常只有单层的编码器和解码器，但这不是必然的。实际上深度编码器和解码器能提供更多优势。</p><p>万能近似定理保证至少有一层隐藏层且隐藏单元足够多的前馈神经网络能以任意精度近似任意函数（在很大范围里），这是非平凡深度（至少有一层隐藏层）的一个主要优点。这意味着具有单隐藏层的自编码器在数据域内能表示任意近似数据的恒等函数。但是，从输入到编码的映射是浅层的。这意味这我们不能任意添加约束，比如约束编码稀疏。深度自编码器（编码器至少包含一层额外隐藏层）在给定足够多的隐藏单元的情况下，能以任意精度近似任何从输入到编码的映射。</p><p>深度可以指数地降低表示某些函数的计算成本。深度也能指数地减少学习一些函数所需的训练数据量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;自编码器（auto-encoder）&lt;/strong&gt;是神经网络的一种，经过训练后能尝试将输入复制到输出。自编码器内部有一个隐藏层h,可以产生&lt;strong&gt;编码&lt;/strong&gt;表示输入。该网络可以看作由两个部分组成：一个由函数h=f(x)表示的编码器和一</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="AE" scheme="http://example.com/tags/AE/"/>
    
  </entry>
  
  <entry>
    <title>循环和递归网络学习笔记</title>
    <link href="http://example.com/2017/09/16/%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2017/09/16/%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%80%92%E5%BD%92%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2017-09-16T06:46:41.000Z</published>
    <updated>2022-05-03T13:07:59.555Z</updated>
    
    <content type="html"><![CDATA[<p>循环神经网络（recurrent neural network）是一类用于处理序列数据的神经网络；就像卷积网络是专门处理网格化数据的神经网络。循环神经网络共享参数方式与卷积网络是不同的，它的输出项是前一项的函数，即输出的每一项对先前的输出应用相同的更新规则而产生。</p><h2 id="1-展开计算图"><a href="#1-展开计算图" class="headerlink" title="1. 展开计算图"></a>1. 展开计算图</h2><p>本质上任何涉及循环的函数都可以被认为是一个循环神经网络，比如下面的表达式：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/rnn_1.png?raw=true"></p><p>典型的RNN会增加额外的架构特性，如读取状态信息h进行预测的输出层，下图是其展开的结构：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/rnn_unfold.png?raw=true"></p><p>展开过程带来了两个主要优点：</p><ol><li>无论序列的长度，学成的模型始终具有相同的输入大小，因为它指定的是从一种状态到另一种状态的转移，而不是在可变长度的历史状态上操作；</li><li>我们可以在每个时间步使用相同参数的相同转移函数f。</li></ol><h2 id="2-循环神经网络"><a href="#2-循环神经网络" class="headerlink" title="2. 循环神经网络"></a>2. 循环神经网络</h2><p>基于上面所说的图展开和参数共享的思想，我们可以设计各种循环神经网络。循环神经网络中一些重要的设计模式包括以下几种：</p><ul><li>每个时间步都有输出，并且隐藏单元之间有循环连接的循环网络，如图 A 所示。</li></ul><p><img src="http://xiaosheng.me/img/article/article_68_3.png" alt="**图A**"></p><p><strong>图A</strong></p><ul><li>每个时间步都产生一个输出，只有当前时刻的输出到下个时刻的隐藏单元之间有循环连接的循环网络，如图 B 所示。</li></ul><p><img src="http://xiaosheng.me/img/article/article_68_4.png"></p><p><strong>图B</strong></p><ul><li>隐藏单元之间存在循环连接，但读取整个序列后产生单个输出的循环网络，如图 C 所示。</li></ul><p><img src="http://xiaosheng.me/img/article/article_68_5.png"></p><p><strong>图C</strong></p><p>现在我们研究<strong>图A</strong> 中 <strong>RNN</strong> 的<strong>前向传播公式</strong>，假设隐藏单元的激活函数为双曲正切激活函数，并且输出是离散的，如用于预测词或字符的<strong>RNN</strong>，表示离散变量的常规方式是把输出<strong>o</strong> 作为每个离散变量可能值的非标准化对数概率。然后可以应用 <strong>softmax</strong>函数后续处理，获得标准化后概率的输出向量 。更新方程如下：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/rnn_update.png?raw=true"></p><p>这个循环网络将一个输入序列映射到相同长度的输出序列，与x序列配对的y的总损失就是所有时间步的损失之和。</p><h2 id="3-双向RNN"><a href="#3-双向RNN" class="headerlink" title="3. 双向RNN"></a>3. 双向RNN</h2><p>目前为止我们考虑的所有循环神经网络有一个“因果”结构，意味着在时刻t的状态只能从过去的序列以及当前的输入捕获信息。然而，在许多应用中，我们要输出的预测可能依赖于整个输入序列。双向循环神经网络为满足这种需要而被发明的。顾名思义，双向 RNN 结合时间上从序列起点开始移动的 RNN 和另一个时间上从序列末尾开始移动的 RNN。典型的双向 RNN 如下图所示：</p><p><img src="http://xiaosheng.me/img/article/article_73_1.png"></p><h2 id="4-基于编码-解码的序列到序列结构"><a href="#4-基于编码-解码的序列到序列结构" class="headerlink" title="4. 基于编码-解码的序列到序列结构"></a>4. 基于编码-解码的序列到序列结构</h2><p>本节主要讨论如何训练RNN，使其将输入序列映射到不一定等长的输出序列。</p><p><strong>编码-解码或序列到序列架构</strong>的想法非常简单：</p><ol><li><strong>编码器(encoder)<strong>或</strong>读取器(reader)<strong>或</strong>输入(input)</strong> RNN 处理输入序列，输出上下文 C（通常是最终隐藏状态的简单函数）。</li><li><strong>解码器(decoder)<strong>或</strong>写入器(writer)<strong>或</strong>输出(output)</strong> RNN 则以固定长度的向量为条件，产生输出序列 Y=(y(1),⋯,y(ny))Y=(y(1),⋯,y(ny))。</li></ol><p>这种架构的创新之处在于长度 nx和 ny可以彼此不同，而之前的架构约束 nx=ny=τ。编码-解码或序列到序列架构如下图所示：</p><p><img src="http://xiaosheng.me/img/article/article_73_2.png"></p><p>编码-解码或序列到序列的 RNN 架构由读取输入序列的编码器 RNN 以及生成输出序列（或计算给定输出序列的概率）的解码器 RNN 组成。编码器 RNN 的最终隐藏状态用于计算一般为固定大小的上下文变量 C，C 表示输入序列的语义概要并且作为解码器 RNN 的输入。</p><p>此架构的一个明显不足是，编码器 RNN输出的上下文 C 的维度太小而难以适当地概括一个长序列。有人提出让 C成为可变长度的序列，而不是一个固定大小的向量，他们还引入了将序列 C 的元素和输出序列的元素相关联的**注意力机制(attention mechanism)**，这在《深度学习之自然语言处理》中会详细介绍。</p><h2 id="5-深度循环网络"><a href="#5-深度循环网络" class="headerlink" title="5. 深度循环网络"></a>5. 深度循环网络</h2><p>大多数 RNN 中的计算可以分解成三块参数及其相关的变换：</p><ol><li>从输入到隐藏状态</li><li>从前一隐藏状态到下一隐藏状态</li><li>从隐藏状态到输出</li></ol><p>实验证据表明在这些操作中引入深度会有利，与我们需要足够的深度以执行所需映射的想法一致。Graves 第一个展示了将 RNNRNN 的状态分为多层的显著好处，如下图所示：</p><p><img src="http://xiaosheng.me/img/article/article_73_3.png"></p><p>循环神经网络可以通过许多方式变得更深：(a) 隐藏循环状态可以被分解为具有层次的组。(b) 可以向输入到隐藏，隐藏到隐藏以及隐藏到输出的部分引入更深的计算 (如 MLP)。这可以延长链接不同时间步的最短路径。(c) 可以引入跳跃连接来缓解路径延长的效应。</p><p>我们可以认为，在 (a) 所示层次结构中较低的层起到了将原始输入转化为对更高层的隐藏状态更合适表示的作用。上图 (b) 更进一步提出在上述三个块中各使用一个单独的 MLP（可能是深度的），考虑表示容量，我们建议在这三个步中都分配足够的容量，但增加深度可能会因为优化困难而损害学习效果。在一般情况下，更容易优化较浅的架构，加入 (b) 的额外深度导致从时间步 t 的变量到时间步 t+1 的最短路径变得更长。例如，如果具有单个隐藏层的 MLP 被用于状态到状态的转换，那么与之前的图相比，我们就会加倍任何两个不同时间步变量之间最短路径的长度。然而 Pascanu 认为，在隐藏到隐藏的路径中引入跳跃连接可以缓和这个问题，如 (c) 所示。</p><h2 id="6-递归神经网络"><a href="#6-递归神经网络" class="headerlink" title="6. 递归神经网络"></a>6. 递归神经网络</h2><p>递归神经网络代表循环网络的另一个扩展， 它被构造为深的树状结构而不是 RNN 的链状结构，因此是不同类型的计算图。递归网络的典型计算图如下图所示：</p><p><img src="http://xiaosheng.me/img/article/article_73_4.png"></p><p>递归网络将循环网络的链状计算图推广到树状计算图。可变大小的序列 x(1),x(2),⋯,x(t) 可以通过固定的参数集合（权重矩阵 U,V,W）映射到固定大小的表示（输出 o）。</p><p>递归网络的一个明显优势是，对于具有相同长度 τ 的序列，深度（通过非线性操作的组合数量来衡量）可以急剧地从 τ 减小为 O(logτ)，这可能有助于解决长期依赖。一个悬而未决的问题是如何以最佳的方式构造树。一种选择是使用不依赖于数据的树结构，如平衡二叉树。理想的情况下，人们希望学习器自行发现和推断适合于任意给定输入的树结构。</p><h2 id="7-长期依赖的挑战"><a href="#7-长期依赖的挑战" class="headerlink" title="7. 长期依赖的挑战"></a>7. 长期依赖的挑战</h2><p>在前馈网络或循环网络中，当计算图变得极深时，神经网络优化算法会面临的一个难题就是长期依赖问题——经过许多阶段传播后的梯度倾向于消失（大部分情况）或爆炸（很少，但对优化过程影响很大），即：变深的结构使模型丧失了学习到先前信息的能力，让优化变得极其困难。因为循环网络要在很长时间序列的各个时刻重复应用相同操作来构建非常深的计算图，并且模型参数共享，这使问题更加凸显。</p><p>有人可能会希望通过简单地停留在梯度不消失或爆炸的参数空间来避免这个问题。不幸的是，为了储存记忆并对小扰动具有鲁棒性，RNN 必须进入参数空间中的梯度消失区域。具体来说，每当模型能够表示长期依赖时，长期相互作用的梯度幅值就会变得指数小（相比短期相互作用的梯度幅值）。这并不意味着这是不可能学习的，由于长期依赖关系的信号很容易被短期相关性产生的最小波动隐藏，因而学习长期依赖可能需要很长的时间。实验表明，当我们增加了需要捕获的依赖关系的跨度， 基于梯度的优化变得越来越困难，SGD 在长度仅为 10 或 20 的序列上成功训练传统 RNN 的概率迅速变为 0。</p><h2 id="8-渗漏单元和其他多时间尺度的策略"><a href="#8-渗漏单元和其他多时间尺度的策略" class="headerlink" title="8. 渗漏单元和其他多时间尺度的策略"></a>8. 渗漏单元和其他多时间尺度的策略</h2><p>处理长期依赖的一种方法是设计工作在多个时间尺度的模型，使模型的某些部分在细粒度时间尺度上操作并能处理小细节，而其他部分在粗时间尺度上操作并能把遥远过去的信息更有效地传递过来。</p><ul><li><p><strong>时间维度的跳跃连接</strong></p><p>增加从遥远过去的变量到目前变量的直接连接是得到粗时间尺度的一种方法。在普通的循环网络中，循环从时刻 t 的单元连接到时刻 t+1 单元。</p><p>正如之前所说，梯度可能关于时间步数呈指数消失或爆炸。有人引入了 d 延时的循环连接以减轻这个问题。现在导数指数减小的速度与 τ/d 相关而不是 τ。既然同时存在延迟和单步连接，梯度仍可能成 t 指数爆炸。这允许学习算法捕获更长的依赖性，但不是所有的长期依赖都能在这种方式下良好地表示。</p></li><li><p><strong>渗漏单元和一系列不同时间尺度</strong></p><p>获得 导数乘积接近1 的另一方式是设置线性自连接单元，并且这些连接的权重接近1。</p><p>我们对某些 vv 值应用更新 μ(t)←αμ(t−1)+(1−α)v(t) 累积一个滑动平均值 μ(t)， 其中 α 是一个从 μ(t−1) 到 μ(t) 线性自连接的例子。当 α 接近 11 时，滑动平均值能记住过去很长一段时间的信息，而当 α 接近 00，关于过去的信息被迅速丢弃。线性自连接的隐藏单元可以模拟滑动平均的行为，这种隐藏单元称为**渗漏单元(leaky unit)**。</p><p>d 时间步的跳跃连接可以确保单元总能被先前的 d 个时间步值影响。使用权重接近 1 的线性自连接是确保该单元可以访问过去值的不同方式。线性自连接通过调节实值 α 更平滑灵活地调整这种效果，而不是调整整数值的跳跃长度。</p><p>我们可以通过两种基本策略设置渗漏单元使用的时间常数。一种策略是手动将其固定为常数，例如在初始化时从某些分布采样它们的值。另一种策略是使时间常数成为自由变量，并学习出来。在不同时间尺度使用这样的渗漏单元似乎能帮助学习长期依赖。</p></li><li><p><strong>删除连接</strong></p><p>处理长期依赖另一种方法是在多个时间尺度组织 RNN 状态的想法，信息在较慢的时间尺度上更容易长距离流动。</p><p>这个想法与之前讨论的时间维度上的跳跃连接不同，因为它涉及主动删除长度为一的连接并用更长的连接替换它们。以这种方式修改的单元被迫在长时间尺度上运作。收到这种新连接的单元，可以学习在长时间尺度上运作，但也可以选择专注于自己其他的短期连接。</p><p>强制一组循环单元在不同时间尺度上运作有不同的方式。一种选择是使循环单元变成渗漏单元，但不同的单元组关联不同的固定时间尺度。另一种选择是使显式且离散的更新发生在不同的时间，不同的单元组有不同的频率。</p></li></ul><h2 id="9-长短期记忆和其他门控RNN"><a href="#9-长短期记忆和其他门控RNN" class="headerlink" title="9. 长短期记忆和其他门控RNN"></a>9. 长短期记忆和其他门控RNN</h2><p>目前实际应用中最有效的序列模型称为<strong>门控RNN</strong>（gated RNN），包括基于长短期记忆（long short-term memory）和基于<strong>门控循环单元</strong>（gated recurrent unit）的网络。 </p><p>像渗漏单元一样，门控 RNN 想法也是基于生成通过时间的路径，其中导数既不消失也不发生爆炸。渗漏单元通过手动选择常量的连接权重或参数化的连接权重来达到这一目的。门控 RNN 将其推广为在每个时间步都可能改变的连接权重。</p><p>渗漏单元允许网络在较长持续时间内积累信息（诸如用于特定特征或类的线索）。然而，一旦该信息被使用，让神经网络遗忘旧的状态可能是有用的。例如，如果一个序列是由子序列组成，我们希望渗漏单元能在各子序列内积累线索，我们需要将状态设置为 0 以忘记旧状态的的机制。我们希望神经网络学会决定何时清除状态，而不是手动决定，这就是门控 RNN 要做的事。</p><ul><li><p><strong>LSTM</strong></p><p>引入自循环的巧妙构思，以产生梯度长时间持续流动的路径是初始**长短期记忆(long short-term memory, LSTM)**模型的核心贡献。其中一个关键扩展是使自循环的权重视上下文而定，而不是固定的。门控此自循环（由另一个隐藏单元控制）的权重，累积的时间尺度可以动态地改变。在这种情况下，即使是具有固定参数的 LSTM，累积的时间尺度也可以因输入序列而改变，因为时间常数是模型本身的输出。</p><p>LSTM块如图所示：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/LSTM.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/lstm2.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/lstm3.png?raw=true"></p><p><img src="http://xiaosheng.me/img/article/article_74_2.png"></p><p>上图为 LSTM 循环网络“细胞”的框图。细胞彼此循环连接，代替一般循环网络中普通的隐藏单元。这里使用常规的人工神经元计算输入特征。如果 sigmoid 输入门允许，它的值可以累加到状态。状态单元具有线性自循环，其权重由遗忘门控制。细胞的输出可以被输出门关闭。所有门控单元都具有 sigmoid 非线性，而输入单元可具有任意的压缩非线性。状态单元也可以用作门控单元的额外输入。黑色方块表示单个时间步的延迟。</p><p>LSTM 循环网络除了外部的 RNN 循环外， 还具有内部的“LSTM 细胞”循环（自环），因此 LSTM 不是简单地向输入和循环单元的仿射变换之后施加一个逐元素的非线性。与普通的循环网络类似，每个单元有相同的输入和输出，但也有更多的参数和控制信息流动的门控单元系统。</p><p>LSTM 网络比简单的循环架构更易于学习长期依赖，目前各种 LSTM 的变体和替代也已经被研究和使用。</p></li><li><p><strong>其他门控RNN</strong></p><p>LSTM 架构中哪些部分是真正必须的？还可以设计哪些其他成功架构允许网络动态地控制时间尺度和不同单元的遗忘行为？</p><p>最近关于门控 RNN 的工作给出了这些问题的某些答案，其单元也被称为<strong>门控循环单元</strong>或 GRU。与 LSTM 的主要区别是，单个门控单元同时控制遗忘因子和更新状态单元的决定。</p><p>复位和更新门能独立地“忽略”状态向量的一部分。更新门像条件渗漏累积器一样可以线性门控任意维度，从而选择将它复制（在 sigmoid 的一个极端）或完全由新的“目标状态”值（朝向渗漏累积器的收敛方向）替换并完全忽略它（在另一个极端）。 复位门控制当前状态中哪些部分用于计算下一个目标状态，在过去状态和未来状态之间引入了附加的非线性效应。</p><p>围绕这一主题可以设计更多的变种。例如复位门（或遗忘门）的输出可以在多个隐藏单元间共享。或者，全局门的乘积（覆盖一整组的单元，例如整一层）和一个局部门（每单元）可用于结合全局控制和局部控制。然而，一些调查发现这些 LSTM 和 GRU 架构的变种，在广泛的任务中难以明显地同时击败这两个原始架构。</p><blockquote><p>本文内容摘取自 <a href="http://www.deeplearningbook.org/">《Deep Learning》</a>，部分内容有修改。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;循环神经网络（recurrent neural network）是一类用于处理序列数据的神经网络；就像卷积网络是专门处理网格化数据的神经网络。循环神经网络共享参数方式与卷积网络是不同的，它的输出项是前一项的函数，即输出的每一项对先前的输出应用相同的更新规则而产生。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RNN" scheme="http://example.com/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>Tips of Deep Learning课程笔记</title>
    <link href="http://example.com/2017/09/15/Tips-of-Deep-learning/"/>
    <id>http://example.com/2017/09/15/Tips-of-Deep-learning/</id>
    <published>2017-09-15T12:59:10.000Z</published>
    <updated>2022-05-03T13:07:37.106Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于李宏毅老师的机器学习<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2017/Lecture/DNN%20tip.pdf">课程</a>笔记，有些部分稍有改动。本文主要介绍Deep Learning(DL)调参技巧，下图表示了DL的一般流程，在这个过程中，我们会着重关注<strong>overfitting</strong>的问题。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_step.png?raw=true"></p><p>当我们发现模型overfitting时，不要总以为是参数太多导致overfitting，我们应该首先去看模型在training data上效果如何。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_overfitting.png?raw=true"></p><p>同时，我们在修正overfitting时，要注意不同的方法针对不同的问题。有的方法是针对训练误差，而有的方法是针对测试误差的，比如：Dropout</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_dropout.png?raw=true"></p><p>下面就是一些经常用到策略：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTip_stategy.png?raw=true"></p><p>我们发现当深度越深，会造成浅层梯度更新慢，深层梯度更新快，深层会快速收敛。这样的话，学习到参数是不好的，因为浅层的参数是随机初始化的，并且无法更新到浅层参数。</p><p>另外当我们使用的激活函数是sigmoid的时，会造成梯度更新越来越小，梯度消失。因此，我们平时经常使用ReLU。ReLU在使用过程在小范围内是线性的，不会是梯度太小。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_relu.png?raw=true"></p><p>不同的激活函数，有不同的效果；因此，提出了可学习激活函数—Maxout。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_maxout.png?raw=true"></p><p>在测试集上调整overfitting时，我们一般通过三种方法进行调整<strong>early stopping</strong>、<strong>regularization</strong>、<strong>Dropout</strong>，现在主要介绍一下Dropout：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_dropout3.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/DLTips_dropout2.png?raw=true"></p><p>Dropout其实是一种集成方法，因为每次mini-batch进行一次dropout操作，产生不同的网络。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是关于李宏毅老师的机器学习&lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2017/Lecture/DNN%20tip.pdf&quot;&gt;课程&lt;/a&gt;笔记，有些部分稍有改动。本文主要介绍Deep Learning(</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="tips" scheme="http://example.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>卷积网络</title>
    <link href="http://example.com/2017/09/14/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2017/09/14/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/</id>
    <published>2017-09-14T11:40:37.000Z</published>
    <updated>2022-05-03T13:07:51.262Z</updated>
    
    <content type="html"><![CDATA[<p>卷积网络是一种专门用来处理具有类似网格结构的数据的神经网络。在卷积网络的术语中，卷积的第一个参数通常叫做<strong>输入</strong>，第二个参数叫做<strong>核函数</strong>，输出有时被称为<strong>特征映射</strong>。在机器学习的应用中，输入通常是多维数组的数据，而核通常是由学习算法优化得到的多维数组的参数。一般地，单独使用卷积运算在机器学习中比较少见，卷积通常和其他函数一起使用。下面演示一个在2维tensor上的卷积：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/cnn_example.png?raw=true"></p><p>为什么我们可以用卷积网络处理图像：</p><ul><li>我们不必去观察整张图来发现pattern，只需要关注一小部分就可以了；</li><li>相同的pattern可能出现在图像的不同区域；</li><li>使用子采样不改变对象</li></ul><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><p>卷积运算通过三个策略来改进机器学习系统：<strong>稀疏交互</strong>、<strong>参数共享</strong>、<strong>等变表示</strong>。</p><ul><li><p><strong>稀疏交互</strong></p><p>稀疏交互就是稀疏连接，神经网络属于局部连接，不再是全连接。这样做可以带来两方面的好处：一是参数更少；二是计算量下降，存储空间降低。下图可以直观说明：</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/sparse_connection.png?raw=true"></p></li><li><p><strong>参数共享</strong></p><p>参数共享是指在一个模型的多个函数中使用相同的参数，保证了我们只需要学习一个参数集合，而不是对于每一个位置都需要学习一个单独的参数集合。</p></li><li><p><strong>等变表示</strong></p><p>对于卷积，参数共享的特殊形式使得神经网络层具有对平移等变的性质。如果一个函数满足输入改变，输出也以同样的方式改变这一性质。</p></li></ul><h3 id="2-池化"><a href="#2-池化" class="headerlink" title="2. 池化"></a>2. 池化</h3><p>卷积网络有一个典型层包含三级：在第一级中，并行地计算多个卷积产生一组线性变换；在第二级中，每个线性变换会经过一个非线性激活函数；在第三级中，使用池化函数调整输出。池化函数使用某一位置的相邻输出的总体统计特征来代替该位置的输出。</p><p>对于平移不变性是指当我们对输入进行少量平移时，经过池化函数后的大多数输出并不会发生改变。因为池化综合了全部邻居的反馈，这使得池化单元少于探测单元成为可能，这种方法提高了网络的计算效率，减小了存储需求。</p><blockquote><p>本文内容摘取自《Deep Learning》，部分内容有所修改</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;卷积网络是一种专门用来处理具有类似网格结构的数据的神经网络。在卷积网络的术语中，卷积的第一个参数通常叫做&lt;strong&gt;输入&lt;/strong&gt;，第二个参数叫做&lt;strong&gt;核函数&lt;/strong&gt;，输出有时被称为&lt;strong&gt;特征映射&lt;/strong&gt;。在机器学习的应用</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>深度模型中的优化</title>
    <link href="http://example.com/2017/09/08/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2017/09/08/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2017-09-08T02:33:09.000Z</published>
    <updated>2022-05-03T13:07:54.608Z</updated>
    
    <content type="html"><![CDATA[<p>大多数深度学习算法都涉及到优化，优化是指改变x来最大化或最小化某个函数f(x)。</p><h3 id="1-学习和纯优化有什么不同"><a href="#1-学习和纯优化有什么不同" class="headerlink" title="1. 学习和纯优化有什么不同"></a>1. 学习和纯优化有什么不同</h3><p>用于深度模型训练的优化算法与传统的优化有几方面是不同的：机器学习通常是间接作用的，比如间接地优化P，一般通过降低损失函数来提高P；</p><ul><li><p><strong>经验风险最小化</strong></p><p>我们将最小化平均训练误差的过程称为经验风险最小化(Empirical Risk Minimization)，这种情况下，机器学习仍然和传统的直接优化很相似。我们不是直接最优化风险，而是最优化经验风险，希望也能够同时显著降低风险。然而，经验风险最小化容易导致过拟合，在深度学习中我们很少使用它。</p></li><li><p><strong>代理损失函数和提前终止</strong></p><p>有时，真正的损失函数（比如分类误差）并不能被高效地优化。这种情况下，我们通常会优化<strong>代理损失函数</strong>。代理损失函数作为原目标的代理，还具备一些优点。在某些情况下，代理损失函数比原函数学到的更多。一般的优化和训练算法的优化有一个重要的不同：训练算法一般不会停止在局部极小点。这么做是为了防止过拟合，一般会使用提前终止机制。与纯优化相比，提前终止时代理损失函数仍有很大的导数，而纯优化终止时导数比较小。</p></li><li><p><strong>批量算法和小批量算法</strong></p><p>机器学习算法和一般优化算法不同的一点是：机器学习算法的目标函数通常可以分解为训练样本上的求和。机器学习中的优化算法在计算参数的每一次更新时通常仅使用整个代价函数中一部分项来估计代价函数的期望值。使用整个训练集的优化算法被称为<strong>批量</strong>或<strong>确定性</strong>梯度算法，因为它们会在一个大批量中同时处理所有样本。每次只使用单个样本的优化算法有时被称为<strong>随机</strong>或者<strong>在线</strong>算法。术语“在线”通常是指从连续产生样本的数据流中抽取样本的情况，而不是从一个固定大小的训练集中遍历多次采样的情况。小批量的大小通常用以下几个因素决定：</p><ol><li>更大的批量会计算精度更高的梯度估计，但是回报却是小于线性。</li><li>极小批量通常难以充分利用多核架构，这促使我们使用一些绝对最小批量。</li><li>如果批量处理中的所有样本可以并行地处理，那么内存消耗和批量大小会成正比。</li><li>在某些硬件上使用特定大小的数组时，运行时间会更少。尤其是在使用GPU时，通常使用2的幂数作为批量大小可以获得更少的运行时间。</li><li>可能由于小批量在学习过程中加入了噪声，它们会有一些正则化效果。泛化误差通常在批量大小为1时最好。</li></ol><p>小批量是随机抽取的，这一点很重要。一般地，我们会将样本顺序随机打乱，然后一组组小批量样本连续读取。</p></li></ul><h3 id="2-神经网络优化中的挑战"><a href="#2-神经网络优化中的挑战" class="headerlink" title="2. 神经网络优化中的挑战"></a>2. 神经网络优化中的挑战</h3><p>传统的机器学习会小心设计目标函数和约束，以确保优化问题是凸的，从而避免一般优化问题的复杂度。在训练神经网络时，我们肯定会碰到非凸的情况。即便是凸优化，也可能会碰到其他问题。</p><ul><li><p><strong>病态</strong></p><p>病态问题一般是指在神经网络训练过程中，随机梯度下降会被“卡”在某些情况，此时即使很小的更新步长也会增加损失函数。牛顿法在解决带有病态条件的Hessian矩阵的凸优化问题时，是一个非常优秀的工具。</p></li><li><p><strong>局部极小值</strong></p><p>由于<strong>模型可辨识性</strong>问题，神经网络中会存在多个等效的局部极小值。一方面神经网络中会存在多个局部极小值，另一方面每个局部极小值的求解代价是不同的。有可能一个等效的局部极小值，它的代价更大。我们无法去辨识哪个代价更大。</p><p>PS：模型可辨识性：一个模型只能由唯一确定的参数所确定，不存在其他参数来等效确定。</p></li><li><p><strong>高原、鞍点和其他平坦区域</strong></p><p>对于很多高维非凸函数而言，相比局部极小值，鞍点存在的可能性更大。在低维空间中，局部极小值很普遍。在更高维空间中，局部极小值点很罕见，而鞍点却很常见。对于牛顿法而言，鞍点显然是一个问题。梯度下降旨在朝“下坡”移动，而非明确寻找临界点。而牛顿法的目标是寻求梯度为0的点。如果没有适当修改，牛顿法就会跳进一个鞍点。</p></li><li><p><strong>悬崖和梯度爆炸</strong></p><p>多层神经网络通常存在像悬崖一样的斜率较大区域，这是因为几个较大的权重相乘导致的。遇到这种悬崖结构时，梯度更新会很大程度地改变参数值，可能会使大量已完成的优化工作成为无用功。因此，我们通常选择完全跳过这类悬崖结构，常用的方法是启发式<strong>梯度截断</strong>来避免其严重的后果。其基本思想是：因为梯度并没有说明最佳不畅，只是说明无限小区域内的最佳方向，所以当传统的梯度下降算法提议更新很大一步时，启发式梯度截断就会干涉来减小步长。从而使其不太可能走出梯度近似为最陡下降方向的悬崖区。悬崖结构在循环神经网络的损失函数中很常见，因为它涉及到很多个因子的相乘。</p></li><li><p><strong>长期依赖</strong></p><p>当计算图变得极深时，神经网络优化算法会面临的另一个难题就是长期依赖问题：由于变深的结构使模型丧失了学习到先前信息的能力，让优化变得极其困难。同时会造成梯度消失与梯度爆炸问题。梯度消失使得我们难以知道参数朝哪个方向移动来改进损失函数；而梯度爆炸会使得学习不稳定。在循环网络中，一般使用相同权重矩阵来避免这个问题。 </p></li></ul><h3 id="3-基本算法"><a href="#3-基本算法" class="headerlink" title="3. 基本算法"></a>3. 基本算法</h3><ul><li><p><strong>随机梯度下降</strong></p><p>基本思想：将数据中抽取m个小批量样本，通过计算它们梯度均值，我们可以得到梯度的无偏估计。SGD算法中的一个关键参数学习率。在实践中，推荐使用随着时间的推移逐渐降低学习率的策略。对于大数据集，SGD只需非常少量样本计算梯度从而实现初始快速更新，远远超过了其缓慢的渐近收敛。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/SGD.png?raw=true"></p></li><li><p><strong>动量</strong></p><p>虽然随机梯度下降仍然是非常受欢迎的优化方法，但其学习过程有时会很慢。动量方法旨在加速学习，特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。动量算法积累了之前梯度指数级衰减的移动平均，并且继续沿该方向移动。</p><p>从形式上看，动量算法引入了变量v充当速度角色，它即代表参数的移动方向，又代表速率。速度被设为负梯度的指数衰减平均。梯度下降算法基于每个梯度简单地更新一步，而使用动量算法的牛顿方案则使用该力改变粒子的速度。我们可以将粒子视作在冰面上滑行的冰球。每当它沿着表面最陡的部分下降时，它会累积继续在该方向上滑行的速度，直到其开始向上滑动为止。</p><p>形象地，我们可以将损失函数看出山的高度，然后我们将一个小球从这个山上滚下来。小球的速度会越来越快，使得小球可以越过山腰上的沟壑，有机会快速到达谷底。并且为了防止小球速度过快，我们会设置一个超参，该参数相当于物理中的阻尼系数。</p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/momentum.png?raw=true"></p><p><img src="https://github.com/zxth93/zxth93.github.io/blob/master/images/favatar/momentum2.png?raw=true"></p></li><li><p><strong>Nesterov动量</strong></p><p>Nesterov动量和标准动量之间的区别体现在梯度计算上，Nesterov动量中，梯度计算发生在施加当前速度之后。因此，Nesterov动量可以解释为往标准方法中添加了一个校正因子。</p><p><img src="https://www.jiqizhixin.com/data/upload/ueditor/20161121/58329b0dc9624.png"></p><p>如上图所示，我们可以对比一下Nesterov动量法和标准动量法区别。动量法首先计算当前的梯度值（小蓝色向量），然后在更新的积累向量（大蓝色向量）方向前进一大步。但 NAG 法则首先（试探性地）在之前积累的梯度方向（棕色向量）前进一大步，再根据当前地情况修正，以得到最终的前进方向（绿色向量）。这种基于预测的更新方法，使我们避免过快地前进，并提高了算法地响应能力（responsiveness），大大改进了 RNN 在一些任务上的表现。</p></li></ul><h3 id="4-参数初始化策略"><a href="#4-参数初始化策略" class="headerlink" title="4. 参数初始化策略"></a>4. 参数初始化策略</h3><p>深度模型的训练算法通常是迭代的，所以需要指定一些开始迭代的初始点，这些初始点会影响算法是否收敛。并且当算法收敛时，初始点还可以影响其收敛的速度，以及是否收敛到一个代价高或低的点。现在的初始化策略是简单的、启发式的。我们对于初始点如何影响泛化的理解相当原始的，几乎没有提供如何选择初始点的任何指导。</p><p>到目前为止，唯一确知的特性是初始参数需要在不同单元间“破坏对称性”：如果两个隐藏层单元有着相同的激活函数以及相同的输入，那么它们必须使用不同的初始参数。通常情况下，我们可以为每个单元的偏置设置启发式挑选的常数，仅随机初始化权重。我们经常 对权重的选取随机取自高斯或均匀分布中的值。</p><p>关于初始化网络，正则化和优化有着不同的观点。优化观点建议权重 尽可能成功地传播信息，而正则化希望其小一点。优化算法倾向于最终参数应接近初始参数。</p><p>设置偏置的方法必须和设置权重的方法协调。设置偏置为0在大多数初始化方案中是可行的，但也存在一些设置为非0 的情况：</p><ol><li>如果偏置是作为输出单元，那么初始化偏置以获取正确的输出边缘统计通常是有利的。我们假设初始权重足够小，该单元的输出仅由偏置决定。这说明设置偏置为应用于训练集上输出边缘统计的激活函数的逆。</li><li>有时，我们会选择偏置来避免初始化引起太大饱和。</li></ol><h3 id="5-自适应学习率算法"><a href="#5-自适应学习率算法" class="headerlink" title="5. 自适应学习率算法"></a>5. 自适应学习率算法</h3><p>学习率会对模型的性能有显著的影响，Delta-bar-delta算法是一个早期的在训练时适应模型参数各自学习率的启发式方法。其基本思想：如果损失对于某个给定模型参数的偏导保持相同的符号，那么学习率应该增加。如果对于该参数的偏导变化了符号，那么学习率应减小。这种方法只能应用于全批量优化中，最近提出一些增量（或基于小批量）的算法来自适应模型参数的学习率。</p><ul><li><p><strong>AdaGrad</strong></p><p>此算法独立地适应模型所有参数的学习率，缩放每个参数反比于其所有梯度历史平方值总和的平方根。具有损失最大的偏导的参数相应地有一个快速下降的学习率，而具有小偏导的参数在学习率上有相对较小的下降。然而在实践中，发现从训练开始时积累梯度平方会导致有效学习率过早和过量的减小。</p></li><li><p><strong>RMSProp</strong></p><p>此算法修改AdaGrad以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。RMSProp使用指数衰减平均以丢失遥远过去的历史，使其能够在找到凸碗状结构后快速收敛。</p></li><li><p><strong>Adam</strong></p><p>Adam利用了AdaGrad和RMSProp在稀疏数据上的优点，对初始化的偏差修正也让Adam表现的更好。很多deep learning的优化问题都用Adam。</p></li></ul><h3 id="6-二阶近似方法"><a href="#6-二阶近似方法" class="headerlink" title="6. 二阶近似方法"></a>6. 二阶近似方法</h3><ul><li><p><strong>牛顿法</strong></p><p>牛顿法是基于二阶泰勒级数展开在某地$\theta_0$附件来近似$J(\theta)$的优化方法，其忽略了高阶导数。对于局部的二次函数，用Hession矩阵的逆来重新调整梯度，牛顿法会直接跳到极小值。如果目标函数是凸的但非二次的（有高阶项），该更新将是迭代的。牛顿法要保证Hession矩阵是正定才能使其是有效的，并且牛顿法还受限于其显著的计算负担。这就导致只有参数很少的网络才能在实际中用牛顿法训练。</p></li><li><p><strong>共轭梯度</strong></p><p>共轭梯度是一种通过迭代下降的共轭方向以有效避免Hession矩阵求逆计算的方法，其中在于梯度相关的方向上使用了线搜索。该方法在二次碗型目标中是一个相当低效的来回往复，锯齿形模式。这是因为每个由梯度给定的线搜索方向，都保证正交于上一个线搜索方向。</p><p>在共轭梯度法中，我们寻求一个和先前线搜索方向共轭的搜索方向，即它不会撤销该方向上的进展。</p></li><li><p><strong>BFGS</strong></p><p>Broyden-Fletcher-Goldfarb-Shanno(BFGS)算法具有牛顿法的一些优点，但没有牛顿法的计算负担。在这方面，BFGS和CG很像。然而，BFGS使用了一个更直接的方法近似牛顿更新，使用矩阵M近似逆，迭代地低秩更新精度以更好的近似Hession的逆。</p><p>与共轭梯度法相似，BFGS算法迭代一系列线搜索，其方向含二阶信息。与共轭梯度不同的是，该方法的成功并不严重依赖于线搜索寻找该方向上和真正极小值很近的一点，这样的话，BFGS花费较少的时间改进每个线搜索。另一方面，BFGS算法必须存储Hession逆矩阵M，使得BFGS不适用于大多数具有百万级参数的现代深度学习模型。</p></li><li><p><strong>存储受限的BFGS（L-BFGS）</strong></p><p>通过避免存储完整的Hession逆近似M，BFGS算法的存储代价可以显著降低。</p><p>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文内容摘取自《Deep Learning》，部分内容有所修改</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大多数深度学习算法都涉及到优化，优化是指改变x来最大化或最小化某个函数f(x)。&lt;/p&gt;
&lt;h3 id=&quot;1-学习和纯优化有什么不同&quot;&gt;&lt;a href=&quot;#1-学习和纯优化有什么不同&quot; class=&quot;headerlink&quot; title=&quot;1. 学习和纯优化有什么不同&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="优化" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
